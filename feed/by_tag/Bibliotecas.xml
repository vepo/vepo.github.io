<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/Bibliotecas.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2026-02-21T19:42:20+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/Bibliotecas.xml</id><title type="html">vepo</title><subtitle>Um repositório para todos os posts, palestras e tutoriais que já fiz. Java, Desenvolvimento de Software e reflexões sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">Collections!?!? Listas, conjuntos e mapas… as classes mais usadas do Java!</title><link href="https://blog.vepo.dev/posts/java-101-collections" rel="alternate" type="text/html" title="Collections!?!? Listas, conjuntos e mapas… as classes mais usadas do Java!" /><published>2022-05-06T00:00:00+00:00</published><updated>2022-05-06T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/17-38-00-java-101-collections</id><content type="html" xml:base="https://blog.vepo.dev/posts/java-101-collections"><![CDATA[<div class="paragraph">
<p>No post anterior nós falamos sobre o que é a JVM e sobre como criar seu primeiro projeto Java. Se você não leu e não sabe escrever um código Java, volta aí no post anterior e veja.</p>
</div>
<div class="paragraph">
<p>Agora vamos dar um segundo passo, pois para quem está começando a entender Java uma das dificuldades é conhecer a extensa biblioteca que a JVM provê. Essa biblioteca trás para nos dá a capacidade de não reescrever códigos básicos para qualquer software, por isso não conhecer é um risco, pois podemos precisar reescrever código que já estão a nossa disposição. Precisamos também compreender alguns conceitos para usar bem os recursos a nossa disposição, vou dar um exemplo fora do contexto desse post, ninguém precisa implementa uma conexão socket, basta usar a classe <a href="https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html"><code>java.net.Socket</code></a>.</p>
</div>
<div class="paragraph">
<p>Na figura abaixo, temos a lista de todos os módulos da versão 17 do Java (uma versão é chamada de JDK, <em>Java Development Kit</em>). É essencial conhecermos o módulo <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/module-summary.html"><code>java.base</code></a>, já os demais módulos podem ser necessários para funcionalidades específica.</p>
</div>
<div id="jdk-libs" class="imageblock text-center text-center">
<div class="content">
<a class="image" href="https://docs.oracle.com/en/java/javase/18/docs/api/index.html"><img src="/assets/images/java-101/cap-03/jdk-libs.PNG" alt="jdk libs"></a>
</div>
<div class="title">Figura 1. Módulos do JDK 17</div>
</div>
<div class="paragraph">
<p><em>— Tem muita biblioteca aí! Pode onde devo começar?</em></p>
</div>
<div class="paragraph">
<p>Eu recomendaria pelo que conhecemos como <em>Collections</em>. Ela não é especificamente um pacote, mas uma interface, a <a href="https://cr.openjdk.java.net/~iris/se/18/build/latest/api/java.base/java/util/Collection.html"><code>Collection</code></a>, e uma série de classes que a usam. A Collections é praticamente onipresente em todo código Java.</p>
</div>
<div class="paragraph">
<p>Quando ouvimos falar das Java Collections, podemos assumir que estamos falando de classes da biblioteca padrão do Java que estendem a interface Collection, essa interface por sua vez irá implementar uma serie de métodos que são comuns em todas as classes que implementam ela. Mas ter métodos em comum não implica em comportamento similar. Para entender o comportamento, precisamo olhar para interfaces que estendem a interface Collection, as principais são <a href="https://cr.openjdk.java.net/~iris/se/18/build/latest/api/java.base/java/util/List.html"><code>List</code></a> e <a href="https://cr.openjdk.java.net/~iris/se/18/build/latest/api/java.base/java/util/Set.html"><code>Set</code></a>.</p>
</div>
<div class="paragraph">
<p>Mas a biblioteca Collections não está restrita a interface Collection, outras interfaces podem ser incluídas como a <a href="https://cr.openjdk.java.net/~iris/se/18/build/latest/api/java.base/java/util/Map.html"><code>Map</code></a> e a <a href="https://cr.openjdk.java.net/~iris/se/18/build/latest/api/java.base/java/util/stream/Stream.html"><code>Stream</code></a>.</p>
</div>
<div class="paragraph">
<p>Vamos olhar como usar cada uma dessas interfaces e classes? No diagrama abaixo estão listadas as classes mais importantes, exceto a <code>Stream</code> da qual discutiremos no final.</p>
</div>
<div id="jdk-lib-collections" class="imageblock text-center text-center">
<div class="content">
<img src="/assets/images/java-101/cap-03/Collections.png" alt="Collections">
</div>
<div class="title">Figura 2. Pacote Java Collections</div>
</div>
<div class="sect1">
<h2 id="_listas-conjuntos-e-mapas">Listas, Conjuntos e Mapas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Listas, Conjuntos e Mapas são os conceitos básicos da biblioteca Collections. Esses conceitos podem ser abstratos a primeira vista, mas a diferença é percebida quando perguntamos o que indexa cada um deles.</p>
</div>
<div class="paragraph">
<p>Se você não entendeu o significado de indexar (indexação), podemos assumir que estou falando da forma como os elementos são agrupados. Vamos pensar uma lista (<code>List</code>), nela os elementos são agrupados de forma sequencial, ou seja, indexados pela posição. Mas quando temos um conjuntos (<code>Set</code>), eles estão agrupados pela identidade própria deles, ou seja, elementos iguais não devem ser repetidos, sendo contado apenas uma vez. Já nos Mapas (<code>Map</code>), os elementos são indexados por uma chave externa a própria natureza do elemento, nesse caso podemos afirmar que temos um par de chave/valor. É por isso que <code>List</code> e <code>Set</code> estendem a interface <code>Collection</code> enquanto <code>Map</code> não estende, porque essa classe não é apenas uma coleção, mas uma indexação composta por dois valores.</p>
</div>
<div id="indexacao-significado" class="imageblock text-center text-center">
<div class="content">
<img src="/assets/images/java-101/cap-03/indexação.PNG" alt="indexação">
</div>
<div class="title">Figura 3. Significado de indexação</div>
</div>
<div class="paragraph">
<p><em>— Cara, você falou um monte aí, mas eu não entendi nada!</em></p>
</div>
<div class="paragraph">
<p>OK! Então vamos demonstrar isso por código? No pequeno trecho abaixo estou inicializando uma lista, um conjunto e um mapa e usando eles para adicionar alguns valores. Você pode ser por exemplo Strings, tente executar o código abaixo usando a ferramenta <em>jshell</em> (ferramenta REPL excelente adicionada na JDK 9), preste bem atenção no trecho de código a esquerda e no resultado a direta (<code>$x</code> representa o resultado retornado pela operação).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="kt">var</span> <span class="n">lista</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>       <span class="c1">// lista ==&gt; []</span>
<span class="n">lista</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Valor 1"</span><span class="o">);</span>                      <span class="c1">// $5 ==&gt; true</span>
<span class="n">lista</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Valor 2"</span><span class="o">);</span>                      <span class="c1">// $6 ==&gt; true</span>
<span class="n">lista</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Valor 1"</span><span class="o">);</span>                      <span class="c1">// $7 ==&gt; true</span>
<span class="n">lista</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span>                          <span class="c1">// $8 ==&gt; true</span>
<span class="n">lista</span><span class="o">;</span>                                     <span class="c1">// lista ==&gt; [Valor 1, Valor 2, Valor 1]</span>

<span class="kt">var</span> <span class="n">conjunto</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>      <span class="c1">// conjunto ==&gt; []</span>
<span class="n">conjunto</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Valor 1"</span><span class="o">);</span>                   <span class="c1">// $11 ==&gt; true</span>
<span class="n">conjunto</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Valor 2"</span><span class="o">);</span>                   <span class="c1">// $12 ==&gt; true</span>
<span class="n">conjunto</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Valor 1"</span><span class="o">);</span>                   <span class="c1">// $13 ==&gt; false</span>
<span class="n">conjunto</span><span class="o">;</span>                                  <span class="c1">// conjunto ==&gt; [Valor 1, Valor 2]</span>

<span class="kt">var</span> <span class="n">mapa</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;();</span> <span class="c1">// mapa ==&gt; {}</span>
<span class="n">mapa</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Valor 1"</span><span class="o">);</span>                    <span class="c1">// $16 ==&gt; null</span>
<span class="n">mapa</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"Valor 2"</span><span class="o">);</span>                    <span class="c1">// $17 ==&gt; null</span>
<span class="n">mapa</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"Valor 1"</span><span class="o">);</span>                    <span class="c1">// $18 ==&gt; null</span>
<span class="n">mapa</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Valor 3"</span><span class="o">);</span>                    <span class="c1">// $19 ==&gt; "Valor 1"</span>
<span class="n">mapa</span><span class="o">;</span>                                      <span class="c1">// mapa ==&gt; {1=Valor 3, 2=Valor 2, 3=Valor 1}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dá pra ver claramente que em uma <code>List</code> podemos adicionar (<code>add</code>) elementos repetidos, mas ao adicionar um elemento repetido em um <code>Set</code> ele não é alterado. Apesar de nosso exemplo manter a ordem, um <code>Set</code> não garante a ordem dos elementos. Observe também que quando adicionamos um elemento em um <code>Set</code> o método <code>add</code> irá retornar se o valor já existia ou não no conjunto.</p>
</div>
<div class="paragraph">
<p>Para um <code>Map</code> temos o comportamento um pouco diferente. Temos que usar a operação <code>put</code> com uma chave e um valor como parâmetros. Valores repetidos podem ser adicionados desde que com chaves diferentes, mas quando reutilizamos uma chave, o antigo valor associado a ele é o retorno da operação.</p>
</div>
<div class="paragraph">
<p>Essas três classes são muito usadas e por isso é bom conhecer cada método dela. Recomendo ler o <em>Javadoc</em> mesmo que você não saiba ler em inglês, tente usar o Google Translator. Você deve ficar atento é a versão da documentação que você está lendo. Cada método e classe terá uma referência sobre a versão do Java na qual ela foi introduzida. Por exemplo, abaixo tempos o método <a href="https://cr.openjdk.java.net/~iris/se/18/build/latest/api/java.base/java/util/Map.html#copyOf(java.util.Map">Map#copyOf</a>) que foi introduzida na JDK 9.</p>
</div>
<div id="javadoc-map-copyof" class="imageblock text-center text-center">
<div class="content">
<img src="/assets/images/java-101/cap-03/javadoc.png" alt="javadoc">
</div>
<div class="title">Figura 4. Documentação da classe Map, método copyOf</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tipos-de-listas">Tipos de Listas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como falamos anteriormente, listas servem para armazenar objetos sequencialmente. No nosso exemplo, usamos a class <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/ArrayList.html"><code>ArrayList</code></a>, mas ela não é a única classe de lista existente, temos também a <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/LinkedList.html"><code>LinkedList</code></a>. Vamos ver a diferença das duas?</p>
</div>
<div class="paragraph">
<p>Para compreender bem a diferença das duas classes, precisamos conhecer um pouco de como elas são implementadas.</p>
</div>
<div class="paragraph">
<p>A classe <code>ArrayList</code> é uma abstração de uma lista sobre um vetor. A classe é inicializada, por padrão, alocando um vetor de tamanho 10. Esse tamanho só será alterado quando a capacidade máxima dela for atingida, o que significa que a operação <code>add</code> pode significar que um vetor inteiro foi criado com o tamanho <code>n + 1</code> e depois todos os elementos foram copiados para o novo vetor.</p>
</div>
<div class="paragraph">
<p><em>— Isso não me parece uma boa coisa&#8230;&#8203;</em></p>
</div>
<div class="paragraph">
<p>Exato! Se a classe é utilizada para uma lista que removemos e adicionamos elementos constantemente, ela terá uma péssima performance. Quando adicionamos um elemento, no melhor caso é uma operação de tempo constante, mas no pior caso pode ser que o tempo dessa operação dependa do tamanho da lista (aqui tem o conceito de <a href="https://pt.wikipedia.org/wiki/An%C3%A1lise_assint%C3%B3tica"><strong>Análise assintótica</strong></a> que vamos falar em outro post). Já para se remover um elemento é preciso copiar todos os elementos posteriores a posição do elemento removido, o que significa que essa operação só é ótima quando removemos o último elemento.</p>
</div>
<div class="paragraph">
<p><em>— Então a classe ArrayList é péssima!</em></p>
</div>
<div class="paragraph">
<p>Não! Nós só falamos as desvantagens dessa classe! Ela é a classe do Java Collection mais utilizada, pois ela é ótima quando você tem uma lista de acesso aleatório.</p>
</div>
<div class="paragraph">
<p><em>— Que raios é acesso aleatório?!?!</em></p>
</div>
<div class="paragraph">
<p>Acesso aleatório é quando você precisa acessar um elemento qualquer da lista sem nenhuma ordenação. Digamos que você deseja acessar a posição <em>541</em> de uma lista com <em>9172</em> elementos, o tempo de acesso é constante. O mesmo acontece se você precisa substituir um elemento dentro da lista.</p>
</div>
<div class="paragraph">
<p>Logo, essa classe é ótima para listas de tamanhos fixos (ou com pouca variação) e que precise de acesso aleatório. Se você já sabe o tamanho da lista que irá preencher, você pode já iniciar a classe com o tamanho deseja, isso vai poupar muito processamento do seu software!</p>
</div>
<div class="paragraph">
<p>A outra classe é a <code>LinkedList</code>, ela é bem mais complexa que a <code>ArrayList</code>. Se você abrir o código dela, vai ver que a classe só armazena o primeiro elemento, o último elemento e o tamanho da lista. Cada elemento é um nó da lista, que contém uma referência ao elemento posterior e anterior. Isso significa que para acessar um elemento, é preciso navegar na lista pelos nós.</p>
</div>
<div class="paragraph">
<p><em>— OI?!?!</em></p>
</div>
<div class="paragraph">
<p>Vamos demonstrar&#8230;&#8203; Se tivermos uma lista com 10 elementos, e eu preciso acessar o elemento na 5ͣ  a operação vai acessar os elementos 1, 2, 3, 4 e depois retornar o 5. Isso significa que qualquer operação que não seja na cabeça ou na calda da lista vai depender da posição do elemento.</p>
</div>
<div class="paragraph">
<p><em>— Então ela não serve para acesso aleatórios como a <code>ArrayList</code>?!?</em></p>
</div>
<div class="paragraph">
<p>Servir ela serve&#8230;&#8203; Devemos usar a palavra <strong>ótimo</strong>! Ótimo é um conceito que sempre associamos a algo bom, mas na verdade ótimo é quando atingimos uma situação satisfatória de acordo com certos parâmetros. Servir não é um termo correto porque independente do uso as duas classes vão responder corretamente, mas se considerarmos o parâmetro velocidade, podemos escolher uma implementação de lista ótima.</p>
</div>
<div class="paragraph">
<p>Mas voltando a resposta&#8230;&#8203; A <code>LinkedList</code> é ótima para usos em que elementos são adicionados/removidos no inicio e no final constantemente. É por esse motivo que a classe implementa duas interfaces que adicionam métodos importantes para o acesso direto desses elementos, a <code>Queue</code> e <code>Deque</code>.</p>
</div>
<div class="paragraph">
<p>Por fim podemos falar da <code>PriorityQueue</code>&#8230;&#8203; Essa classe é especial porque ela pode funcionar como uma lista comum, mas podemos associar ela a um <code>Comparator</code> que irá definir a prioridade que os elementos devem ser acessados. Internamente os elementos são armazenados pela ordem de inserção, mas eles são retornados pelos métodos <code>poll()</code> de acordo com a ordem estabelecida pelo comparador usado no construtor, isso significa que você sempre inicializar com um comparador.</p>
</div>
<div class="paragraph">
<p>Vamos ver ela em execução? No exemplo abaixo vamos adicionar algumas Strings e ver como elas são retornadas pelo método <code>poll()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">var</span> <span class="n">lista</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>  <span class="c1">// lista ==&gt; []</span>
<span class="n">lista</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>                           <span class="c1">// $2 ==&gt; true</span>
<span class="n">lista</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"d"</span><span class="o">);</span>                           <span class="c1">// $3 ==&gt; true</span>
<span class="n">lista</span><span class="o">;</span>                                    <span class="c1">// lista ==&gt; [a, d]</span>
<span class="n">lista</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"b"</span><span class="o">);</span>                           <span class="c1">// $5 ==&gt; true</span>
<span class="n">lista</span><span class="o">;</span>                                    <span class="c1">// lista ==&gt; [a, d, b]</span>
<span class="n">lista</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"d"</span><span class="o">);</span>                           <span class="c1">// $7 ==&gt; true</span>
<span class="n">lista</span><span class="o">;</span>                                    <span class="c1">// lista ==&gt; [a, d, b, d]</span>
<span class="n">lista</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>                             <span class="c1">// $9 ==&gt; "a"</span>
<span class="n">lista</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>                             <span class="c1">// $10 ==&gt; "b"</span>
<span class="n">lista</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>                             <span class="c1">// $11 ==&gt; "d"</span>
<span class="n">lista</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>                             <span class="c1">// $12 ==&gt; "b"</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe que existe uma ordenação no retorno, tanto que a falta de ordem na adição foi resolvida. Essa classe é muito útil quando precisamos implementar uma lista de prioridades.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tipos-de-conjuntos">Tipos de Conjuntos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os conjuntos são mais simples que as Listas, vamos ter duas classes importantes: <code>HashSet</code> e <code>TreeSet</code>.</p>
</div>
<div class="paragraph">
<p><code>HashSet</code> deve ser usada quando a ordem dos elementos não é importante, tanto que a interface não dispõe de métodos para acesso sequencial aos elementos. Os elementos são tratados como um conjunto. Se você for abrir a implementação do <code>HashSet</code>, ela usa um <code>HashMap</code> internamente, a seguir veremos como o <code>HashMap</code> funciona. A adição/remoção em um <code>HashSet</code> são mais rápidas que em uma <code>TreeSet</code>.</p>
</div>
<div class="paragraph">
<p>Já a <code>TreeSet</code> é um conjunto ordenado, por isso existe a necessidade de um <code>Comparator</code>, isso significa que os elementos podem ser acessados em ordem, mas ao se adicionar há uma penalidade pois haverá uma operação de balanceamento da árvore interna.</p>
</div>
<div class="paragraph">
<p>Em resumo, use <code>HashSet</code> se a ordem não importa e <code>TreeSet</code> se a ordem importa!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tipos-de-mapas">Tipos de Mapas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os mapas são a base de implementação dos conjuntos, <code>HashMap</code> terá o mesmo comportamento do <code>HashSet</code> exceto pelo fato de que ao invés de indexar pelo próprio elemento, ele será indexado pela chave. Já o <code>TreeMap</code> vai armazenar os elementos seguindo a ordenação das chaves.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_streams">Streams</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Stream</code> é uma interface pela qual teremos um post especifico futuramente pois essa foi uma das maiores contribuições do Java 8. Quando usamos o método <code>stream()</code> presente em cada Collection, nós não criamos uma nova coleção, nós apenas iniciamos o processo de criação de uma pipeline. O principal conceito de um Stream é que a construção da nova collection será postergada até que o final dela seja conhecido. Essa propriedade é o que chamamos de <a href="https://pt.wikipedia.org/wiki/Avalia%C3%A7%C3%A3o_pregui%C3%A7osa"><em>Lazy Evaluation</em></a>, isso significa que existirá um algoritmo para criação dessa lista, mas ele só será executado ao final.</p>
</div>
<div class="paragraph">
<p><em>— Entendi bulhufas!</em></p>
</div>
<div class="paragraph">
<p>OK! Vamos demonstrar usando o JShell&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="java"><span class="kt">var</span> <span class="n">lista</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"aaa"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"aaaaa"</span><span class="o">,</span> <span class="s">"asdada"</span><span class="o">);</span>       <span class="c1">// lista ==&gt; [a, aaa, b, c, aaaaa, asdada]</span>
<span class="n">lista</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"a"</span><span class="o">)).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span> <span class="c1">// $2 ==&gt; [a, aaa, aaaaa, asdada]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>No código acima nós criamos uma lista e depois criamos um <code>Stream</code> baseado nela. Até chamar o método <code>collect</code>, o <code>Stream</code> não passava de uma sequência de operações sob a lista, depois se cria uma nova lista (poderia ser qualquer coisa) usando as operações. A lista original não é alterada!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cap-03-conclusao">Conclusão</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Collections é uma biblioteca onipresente! Em qualquer código você verá vestígio dela. Experimente e conheça.</p>
</div>
</div>
</div>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Java" /><category term="Tutorial" /><category term="Collections" /><category term="Bibliotecas" /><summary type="html"><![CDATA[Continuando a série sobre Java, vamos apresentar o que é o Java Collections. Vou apresentar um panorama sobre a biblioteca contendo as principais classes. A ideia desta série é criar um tutorial Java onde mostrarei todos os segredos da linguagem e do ecossistema.]]></summary></entry></feed>