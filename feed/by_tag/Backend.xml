<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/Backend.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2025-10-07T11:58:40+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/Backend.xml</id><title type="html">vepo</title><subtitle>Um repositório para todos os posts, palestras e tutoriais que já fiz. Java, Desenvolvimento de Software e reflexões sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">A Evolução do Java no Backend: Jakarta EE, Spring e Quarkus</title><link href="https://blog.vepo.dev/posts/java-no-backend" rel="alternate" type="text/html" title="A Evolução do Java no Backend: Jakarta EE, Spring e Quarkus" /><published>2023-10-16T00:00:00+00:00</published><updated>2023-10-16T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/11-15-52-java-no-backend</id><content type="html" xml:base="https://blog.vepo.dev/posts/java-no-backend"><![CDATA[<p>O ecossistema Java para desenvolvimento backend passou por diversas transformações ao longo dos anos, desde os primórdios da orientação a objetos até as modernas soluções como microsserviços e contêineres. Neste post, exploramos essa jornada, destacando as tecnologias que moldaram o Java no backend e como elas se relacionam hoje.</p>

<hr />
<iframe width="560" height="315" src="https://www.youtube.com/embed/uTHZet430rs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<hr />

<h2 id="1-as-fases-do-java-no-backend"><strong>1. As Fases do Java no Backend</strong></h2>

<h3 id="orientação-a-objetos-e-servidores-de-aplicação"><strong>Orientação a Objetos e Servidores de Aplicação</strong></h3>
<ul>
  <li><strong>Anos 90</strong>: Java surgiu em 1995 incorporando conceitos como CORBA e servlets (1996).</li>
  <li><strong>J2EE (1999)</strong>: Trouxe soluções como EJB (Enterprise JavaBeans) para objetos distribuídos e JDBC para conexão com bancos de dados.</li>
  <li><strong>Servidores de Aplicação (2001)</strong>: Como JBoss e WebLogic, permitiam deploy de aplicações em um único processo Java, facilitando a gestão de recursos.</li>
</ul>

<h3 id="a-revolução-do-docker-2013"><strong>A Revolução do Docker (2013)</strong></h3>
<ul>
  <li>A conteinerização mudou a forma como aplicações eram deployadas, eliminando a necessidade de servidores de aplicação monolíticos.</li>
  <li>Java 8 (2014) e Spring Boot surgiram como respostas ágeis a essa nova era.</li>
</ul>

<hr />

<h2 id="2-jakarta-ee-o-modelo-baseado-em-especificações"><strong>2. Jakarta EE: O Modelo Baseado em Especificações</strong></h2>
<p>Jakarta EE (antigo Java EE) é um <strong>modelo de programação baseado em specs</strong>, garantindo compatibilidade e flexibilidade.</p>

<h3 id="principais-especificações"><strong>Principais Especificações</strong></h3>
<ul>
  <li><strong>JPA</strong>: Persistência de dados.</li>
  <li><strong>JAX-RS</strong>: Desenvolvimento de APIs REST.</li>
  <li><strong>Bean Validation</strong>: Validação de dados com anotações.</li>
  <li><strong>CDI</strong>: Injeção de dependências.</li>
</ul>

<h3 id="vantagens"><strong>Vantagens</strong></h3>
<ul>
  <li><strong>Estabilidade</strong>: Código escrito há 20 anos ainda roda em servidores modernos.</li>
  <li><strong>Portabilidade</strong>: Depende de interfaces, não de implementações específicas.</li>
</ul>

<h3 id="microprofile-jakarta-ee-para-microsserviços"><strong>MicroProfile: Jakarta EE para Microsserviços</strong></h3>
<ul>
  <li>Extensão do Jakarta EE com foco em:
    <ul>
      <li>Observabilidade (OpenTelemetry).</li>
      <li>Tolerância a falhas.</li>
      <li>Autenticação via JWT.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="3-spring-acelerando-o-desenvolvimento"><strong>3. Spring: Acelerando o Desenvolvimento</strong></h2>
<ul>
  <li><strong>Contexto</strong>: Surgiu para simplificar o desenvolvimento Java EE, que era lento e burocrático.</li>
  <li><strong>Spring Boot (2014)</strong>: Revolucionou com:
    <ul>
      <li>Executáveis independentes (sem servidor de aplicação).</li>
      <li>Configuração simplificada (menos XML, mais anotações).</li>
    </ul>
  </li>
</ul>

<h3 id="comparação-com-jakarta-ee"><strong>Comparação com Jakarta EE</strong></h3>
<p>| <strong>Spring</strong>          | <strong>Jakarta EE</strong>       |
|———————-|———————-|
| <code class="language-plaintext highlighter-rouge">@GetMapping</code>       | <code class="language-plaintext highlighter-rouge">@Path</code> (JAX-RS)    |
| <code class="language-plaintext highlighter-rouge">@RestController</code>   | <code class="language-plaintext highlighter-rouge">@ApplicationScoped</code> (CDI) |
| Foco em produtividade | Foco em padrões empresariais |</p>

<hr />

<h2 id="4-quarkus-java-para-a-era-kubernetes"><strong>4. Quarkus: Java para a Era Kubernetes</strong></h2>
<ul>
  <li><strong>Origem</strong>: Evolução do JBoss/WildFly, focada em:
    <ul>
      <li><strong>Tempo de inicialização rápido</strong> (crucial para microsserviços).</li>
      <li><strong>Experiência do desenvolvedor</strong> (live coding, integração com Kubernetes).</li>
    </ul>
  </li>
  <li><strong>Relacionamento com Jakarta EE</strong>: Implementa specs como JAX-RS e CDI, mas com abordagem moderna.</li>
</ul>

<hr />

<h2 id="conclusão-qual-escolher"><strong>Conclusão: Qual Escolher?</strong></h2>
<ul>
  <li><strong>Jakarta EE</strong>: Ideal para aplicações empresariais robustas e de longa vida.</li>
  <li><strong>Spring</strong>: Melhor para produtividade e adoção rápida.</li>
  <li><strong>Quarkus</strong>: Focado em microsserviços e cloud-native.</li>
</ul>

<h3 id="dicas-para-aprofundar"><strong>Dicas para Aprofundar</strong></h3>
<ol>
  <li>Explore specs como <strong>JAX-RS</strong> e <strong>Bean Validation</strong>.</li>
  <li>Experimente starters em <a href="https://start.jakarta.ee">start.jakarta.ee</a> e <a href="https://code.quarkus.io">code.quarkus.io</a>.</li>
  <li>Para Spring, use <a href="https://start.spring.io">start.spring.io</a>.</li>
</ol>

<p>O Java no backend continua evoluindo, e entender essas tecnologias é essencial para escolher a melhor ferramenta para seu projeto.</p>

<p><strong>#Java #JakartaEE #Spring #Quarkus #Backend</strong></p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Java" /><category term="Backend" /><category term="Quarkus" /><category term="Spring" /><category term="Jakarta EE" /><summary type="html"><![CDATA[O ecossistema Java para desenvolvimento backend passou por diversas transformações ao longo dos anos, desde os primórdios da orientação a objetos até as modernas soluções como microsserviços e contêineres. Neste post, exploramos essa jornada, destacando as tecnologias que moldaram o Java no backend e como elas se relacionam hoje.]]></summary></entry><entry><title type="html">REST &amp;amp; HTTP</title><link href="https://blog.vepo.dev/posts/rest-e-http" rel="alternate" type="text/html" title="REST &amp;amp; HTTP" /><published>2021-09-09T00:00:00+00:00</published><updated>2021-09-09T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/15-40-00-rest-e-http</id><content type="html" xml:base="https://blog.vepo.dev/posts/rest-e-http"><![CDATA[<p>Ano passado eu me dediquei a escrever sobre HTTP e REST. Estava com alguns objetivos claro em mente, queria mostrar quando usar e como usar o HTTP. Depois me fiz algumas perguntas e fui pesquisar se existem padrões de projeto em REST. Dessa peqquisa saiu dois POST enormes. O primeiro eu decidi tornar um livreto, mas sem muita revisão e sem muita experiência.</p>

<p>Com esse “livreto” eu acabei conseguindo ser aceito como escritor na <a href="https://www.casadocodigo.com.br/">Casa do Código</a>, a ideia é escrever um livro sobre desenvolvimento backend, mas focado nos protocolos e não nos frameworks. A parte HTTP já está pronta, e o tal “livreto” é só um capitulo, tem muito mais.</p>

<p>Esse tal livreto está disponível na Amazon, de graça pra quem gosta de sustentar o Jeff Benzos.</p>

<p><a href="https://www.amazon.com.br/Anatomia-Protocolo-HTTP-protocolos-frameworks-ebook/dp/B08PSDT35Y/?_encoding=UTF8&amp;pd_rd_w=uCTIy&amp;pf_rd_p=4b9652c9-ac45-4535-ac4d-eec51129bb6c&amp;pf_rd_r=15TFWDDHRR59X7MWSBNM&amp;pd_rd_r=57f799bb-5689-4dd4-8b73-f7ba4703b773&amp;pd_rd_wg=1Ar7d&amp;ref_=pd_gw_ci_mcx_mr_hp_d"><img src="/assets/images/Anatomia-do-Protocolo-HTTP-medium.png" alt="Anatomia do Protocolo HTTP" /></a></p>

<p>Se você quiser pegar no Leanpub, também está lá: <a href="https://leanpub.com/anatomiahttp/">leanpub.com/anatomiahttp</a></p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="REST" /><category term="HTTP" /><category term="Backend" /><category term="Livros" /><summary type="html"><![CDATA[Mais conteúdo sobre REST e HTTP... Agora um pouco melhor!]]></summary></entry></feed>