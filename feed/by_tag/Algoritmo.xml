<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/Algoritmo.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2025-10-07T11:58:40+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/Algoritmo.xml</id><title type="html">vepo</title><subtitle>Um reposit√≥rio para todos os posts, palestras e tutoriais que j√° fiz. Java, Desenvolvimento de Software e reflex√µes sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">Algoritmos - Uma introdu√ß√£o</title><link href="https://blog.vepo.dev/posts/algoritmos-uma-introducao" rel="alternate" type="text/html" title="Algoritmos - Uma introdu√ß√£o" /><published>2022-06-10T00:00:00+00:00</published><updated>2022-06-10T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/12-47-30-algoritmos-uma-introducao</id><content type="html" xml:base="https://blog.vepo.dev/posts/algoritmos-uma-introducao"><![CDATA[<blockquote>
  <p><em>A NO√á√ÉO de um algoritmo √© b√°sica para toda a programa√ß√£o de computadores.</em> 
Donald E. Knuth</p>
</blockquote>

<p>Mesmo que voc√™ n√£o se importe com algoritmos, se voc√™ programa em qualquer linguagem, voc√™ usa, produz e l√™ algoritmos. Talvez voc√™ n√£o saiba definir o que √© um algoritmo, ou talvez voc√™ tenha uma ideia errada do que √©. Mas √© uma ideia b√°sica para todo programa, tanto que foram com as palavras acima que Donald E. Knuth decidiu abrir seu livro <strong>The Art of Computer Programming</strong>.</p>

<p>Antes de falar em algoritmos, vamos tentar entender o que √© uma linguagem de programa√ß√£o?</p>

<h1 id="o-que-√©-um-computador">O que √© um computador?</h1>

<p>Devemos considerar computadores como m√°quinas extremamente burras. Ao contr√°rio do senso comum, os computadores n√£o avan√ßaram nos √∫ltimos 40 anos, todos eles seguem a mesma arquitetura de l√™ uma instru√ß√£o, executar a instru√ß√£o e l√™ a instru√ß√£o seguinte. Essas instru√ß√µes v√£o alterar valores na mem√≥ria, ou em registradores, que podem alterar o fluxo do programa. Todo avan√ßo que tivemos foi na velocidade de processamento dessas instru√ß√µes, na quantidade de mem√≥ria dispon√≠vel e na velocidade de comunica√ß√£o entre computadores.</p>

<p>Essas instru√ß√µes s√£o armazenadas na mem√≥ria em algo chamado linguagem de m√°quina que s√£o dados bin√°rios. A gera√ß√£o desse bin√°rio √© feita a partir de uma linguagem poss√≠vel de ser compreendida pelo ser humano. √â a√≠ que entra uma linguagem de programa√ß√£o.</p>

<p>Uma Linguagem de Programa√ß√£o √© capaz de expressar algoritmos que s√£o traduzidos para linguagem de m√°quina em que computadores podem o entender. √â preciso fazer uma diferente entre Linguagem de Programa√ß√£o, Linguagem de Defini√ß√£o de Interface (IDL) e Linguagem de Apresenta√ß√£o. Existem algumas linguagens no contexto do desenvolvimento de software que n√£o viram programas, mas s√£o usadas por programas para outros prop√≥sitos, como √© o caso do HTML, CSS e algumas IDLs como gRPC. Nenhuma dessas linguagens √© transformada em c√≥digo execut√°vel e n√£o √© poss√≠vel definir um algoritmo nelas. Isso n√£o implica que elas n√£o tenham algoritmos pr√≥prios, o CSS por exemplo tem um algoritmo para aplica√ß√£o de estilo. ü§ì</p>

<p>Uma linguagem de programa√ß√£o sempre ser√° de dois tipos, ou ela √© declarativa ou imperativa. Uma Linguagem Declarativa √© usada para declarar qual a forma que um problema deve ser resolvido, essas linguagens s√£o em muitos casos funcionais (LISP, Erlang ou Haskell). SQL e HTML tamb√©m s√£o consideradas linguagens declarativas para problemas espec√≠ficos como consulta a base de dados e cria√ß√£o de telas, respectivamente.</p>

<h1 id="definindo-algoritmos">Definindo Algoritmos</h1>

<p>O <a href="https://www.oxfordlearnersdictionaries.com/definition/english/algorithm">Dicion√°rio Oxford</a> define algoritmo como:</p>

<blockquote>
  <p>Um conjunto de regras que devem ser seguidas para resolver um problema em particular.</p>
</blockquote>

<p>Qualquer programa de computador √© desenvolvido para resolver um problema. <em>Ou para criar um problema‚Ä¶ sem estresse</em> üòâ</p>

<p>Mas um programa <strong>DEVE</strong> segui uma receita, isto √©, o seu algoritmo. Isto √© onipresente em qualquer sistema computacional e nenhum programa consegue fugir do seu algoritmo. √â importante entender isso at√© para desmentir algumas p√©ssimas mat√©rias que tentam passar a ideia que estamos perto de alcan√ßar a singularidade, isto √©, o momento que computadores ser√£o superior ao seres humanos podendo inclusive se reprogramar. Algum tempo atr√°s saiu uma mat√©ria dizendo que a Meta havia desligado uma IA porque ela estava criando uma linguagem nova, isso √© uma mentira contada usando fatos. O que, provavelmente, aconteceu foi que a IA se degenerou mais rapidamente do que se imaginava e por isso o experimento foi terminado. O experimento n√£o terminou por medo de se criar uma nova <em>Skynet</em>, mas porque se decidiu n√£o investir mais tempo em tentar criar um chatbot aut√¥nomo. No fim, o chatbot estava fazendo exatamente aquilo para qual ele foi desenvolvido, ele n√£o saiu do conjunto de regras para o qual foi desenvolvido. <strong>Todo programa respeita o seu algoritmo, o que acontece √© que ou o algoritmo est√° errado ou h√° um erro na implementa√ß√£o dele</strong>.</p>

<p><img src="/assets/images/fakes/facebook-desliga-ia.PNG" alt="Noticia falsa &quot;Facebook desliga intelig√™ncia artificial que criou sua pr√≥pria linguagem&quot;" /></p>

<p>A origem do termo algoritmo √© incerta, alguns acreditam que ela descende do termo antigo <em>algorismo</em> que significa <strong>o processo de fazer aritm√©tica usando algarismos ar√°bicos</strong>. Durante a idade m√©dica, os c√°lculos eram feitos atrav√©s de √°bacos usando algoritmos. Na Renascen√ßa esse termo foi colocado em d√∫vida porque alguns linguistas consideraram ele a jun√ß√£o de <em>algiros</em> (doloroso) + <em>arithmos</em> (n√∫meros). Mas tamb√©m pode vir do nome do autor <em>Abu Abdal√° Maom√© ibne Mu√ßa ibne Alcuarismi</em> que escreveu <a href="https://pt.wikipedia.org/wiki/Livro_da_Restaura%C3%A7%C3%A3o_e_do_Balanceamento"><strong>Livro da Restaura√ß√£o e do Balanceamento</strong></a>. Essa foi a primeira obra a reunir algoritmos para resolu√ß√£o de um conjunto de problemas, e o nome algoritmo deriva da pronuncia do nome do autor <em>al-Khwarizmi</em>.</p>

<p><img src="/assets/images/books/algoritmo-livro-arabe.jpg" alt="Capa do Livro da Restaura√ß√£o e do Balanceamento" /></p>

<p>Durante o tempo, o termo √°rabe se degenerou e acabou misturado com um termo grego que tem sua raiz em aritm√©tica. Por volta de 1950 o termo algoritmo era facilmente associado ao Algoritmo de Euclides, que √© o processo matem√°tico para se encontrar o m√°ximo divisor comum de dois inteiros.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo E (Algoritmo de Euclides). Dado dois inteiros positivos m e n, encontre seu maior divisor comum, isto √©, o maior inteiro positivo que divide tanto m e n.

E1. [Encontrar resto] Divida m por n e assuma r como o resto da divis√£o. (0 ‚â§ r &lt; n)
E2. [Igual a zero?]   Se r = 0, o algoritmo termina; n √© a resposta
e3. [Reduz]           Assuma m ‚Üê n, n ‚Üê r, e volte para o passo E1.
</code></pre></div></div>

<h1 id="caracter√≠sticas-de-um-algoritmo">Caracter√≠sticas de um algoritmo</h1>

<p>Um algoritmo √© uma receita, mas receitas de bolo n√£o s√£o algoritmos. Porque? A resposta √© simples e j√° falamos dela quando descrevemos um computador. Voc√™ consegue entender uma receita de bolo, mas um computador n√£o consegue entender. Voc√™ √© infinitamente mais esperto que um computador.</p>

<p>Para que um conjunto de passos seja um algoritmo, ele deve ter as seguintes caracter√≠sticas:</p>

<ol>
  <li>Finitude</li>
  <li>Definitividade</li>
  <li>Entrada</li>
  <li>Sa√≠da</li>
  <li>Efic√°cia</li>
</ol>

<h2 id="1-finitude">1. Finitude</h2>

<p>Um algoritmo <strong>DEVE</strong> sempre terminar depois de um conjunto finito de passos.</p>

<p>Existem algoritmos que buscam indefinitivamente por um valor √≥timo. Mesmos esses algoritmos devem terminar depois de um n√∫mero finito de intera√ß√µes ou ao encontrar um <strong>valor est√°vel</strong>. Esse √© o caso do algoritmo de treinamento de redes neurais, o algoritmo n√£o est√° buscando por uma valor exato, mas por um valor aproximado baseado na entrada.</p>

<h2 id="2-definitividade">2. Definitividade</h2>

<p>Cada passo de um algoritmo <strong>DEVE</strong> ser precisamente definido.</p>

<p>Voc√™ pode fazer</p>

<p>Voc√™ pode fazer suposi√ß√µes sobre algo que l√™, mas um computador n√£o pode fazer suposi√ß√µes. Cada passo deve ser preciso.</p>

<p><a href="https://www.monkeyuser.com/2019/determinism/"><img src="/assets/images/monkeyuser/148-determinism.png" alt="Tirinha do site monkeyuser.com chamada &quot;Determinism&quot;, na descri√ß√£o o site usa &quot;As suposi√ß√µes s√£o a m√£e de todas as merdas!&quot;" /></a></p>

<p>Volte para o <strong>Algoritmo E</strong> e procure espa√ßos para duvida nos passos, se houver qualquer d√∫vida o algoritmo n√£o pode ser implementado ou mesmo executado manualmente.</p>

<h2 id="3-entrada">3. Entrada</h2>

<p>Um algoritmo tem dados de entrada, eles s√£o parte da defini√ß√£o do algoritmos. No caso do <strong>Algoritmo E</strong> s√£o os n√∫meros inteiros <code class="language-plaintext highlighter-rouge">m</code> e <code class="language-plaintext highlighter-rouge">n</code>.</p>

<h2 id="4-output">4. Output</h2>

<p>Um algoritmo tem dados de sa√≠da, eles s√£o parte da defini√ß√£o do algoritmos. No caso do <strong>Algoritmo E</strong> √© o valor do m√°ximo divisor comum de <code class="language-plaintext highlighter-rouge">m</code> e <code class="language-plaintext highlighter-rouge">n</code>.</p>

<h2 id="5-efic√°cia">5. Efic√°cia</h2>

<p>Todos os passos precisam ser efetivos, isto significa que devem ser simples o suficiente para serem executados sem nenhum outro conhecimento. Passos complexos podem ser encapsulados em algoritmos, por exemplo, se um outro algoritmo precisar encontrar o m√°ximo divisor comum de dois n√∫meros, este pode ser encapsulado atrav√©s de um passo simples <code class="language-plaintext highlighter-rouge">mdc ‚Üê E(m, n)</code>, onde <code class="language-plaintext highlighter-rouge">E(m, n)</code> significa a execu√ß√£o do <strong>Algoritmo E</strong>.</p>

<h1 id="nota√ß√£o">Nota√ß√£o</h1>

<p>Para escrever um algoritmo, precisamos:</p>

<ul>
  <li><strong>Passos numerados</strong>: Devemos poder nos referir aos passos</li>
  <li><strong>Pseudoc√≥digo</strong>: Devemos ser capazes de traduzir o algoritmo em qualquer linguagem de programa√ß√£o</li>
  <li><strong>Dados de entrada</strong></li>
  <li><strong>Dados de sa√≠da</strong></li>
  <li><strong>Atribui√ß√µes</strong>: Representa quando uma vari√°vel assume um novo valor. Normalmente usamos a nota√ß√£o <code class="language-plaintext highlighter-rouge">x ‚Üê y</code> onde significa que <code class="language-plaintext highlighter-rouge">x</code> ser√° atribu√≠do o valor de <code class="language-plaintext highlighter-rouge">y</code>.</li>
</ul>

<p>No <strong>Algoritmo E</strong> temos todas essas caracter√≠sticas.</p>

<h1 id="ordenando-um-array">Ordenando um array</h1>

<p>Como podemos ordenar um array? Existe uma s√©rie de algoritmos que s√£o bastante estudados, o mais simples dele √© o <a href="https://pt.wikipedia.org/wiki/Selection_sort"><em>Selection sort</em></a> que consiste basicamente de selecionar cada posi√ß√£o a partir do inicio do array e procurar o menor valor nas posi√ß√µes seguintes. Abaixo definimos ele como <strong>Selection Sort</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dado:
    v    ‚Üí O array de entrada contendo n√∫meros inteiros
    n    ‚Üí O tamanho de v
    x[i] ‚Üí O valor armazenada na posi√ß√£o i do array x

INICIO:
  S1: PARA CADA i EM [0, n - 2]:
  S2:   min_index ‚Üê i
  S3:   PARA CADA j EM [i + 1, n - 1]:
  S4:     SE v[j] &lt; v[min_index]?
  S5:       min_index ‚Üê j
  S6:   SE v[i] != v[min_index]?
  S7:     aux ‚Üê v[min_index]
  S8:     v[min_index] ‚Üê v[i]
  S9:     v[i] ‚Üê aux
</code></pre></div></div>

<p>Sobre este algoritmo podemos perguntar:</p>

<ol>
  <li><strong>√â finito?</strong> Sim, ele ir√° iterar sobre o array.</li>
  <li><strong>√â definitivo?</strong> Sim, cada passo pode ser feito sem qualquer suposi√ß√£o.</li>
  <li><strong>Qual √© a entrada?</strong> A matriz e seu comprimento.</li>
  <li><strong>Qual √© a sa√≠da?</strong> A mesma matriz j√° que o algoritmo altera os valores de entrada.</li>
  <li><strong>√â eficaz?</strong> Sim, classificar√° qualquer array.</li>
</ol>

<h2 id="executando-manualmente">Executando manualmente</h2>

<p>Todo algoritmo pode ser executado manualmente, n√£o √© f√°cil mas, ao executar, podemos ver como dos dados s√£o transformados por ele e compreender o seu funcionamento. Abaixo vemos a execu√ß√£o do <strong>Selection Sort</strong> para o vetor <code class="language-plaintext highlighter-rouge">[5, 100, -6, 98, -111, 0]</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DADO: 
  v = [5, 100, -6, 98, -111, 0]
  n = 6

  S1: i ‚Üê 0                                v = [5, 100, -6, 98, -111, 0]   min_index = 0   aux = 0
  S2: min_index ‚Üê 0                        v = [5, 100, -6, 98, -111, 0]   min_index = 0   aux = 0
  S3: j ‚Üê 1                                v = [5, 100, -6, 98, -111, 0]   min_index = 0   aux = 0
  S4: v[1] &lt; v[0] ? (100 &lt; 5)    NO        v = [5, 100, -6, 98, -111, 0]   min_index = 0   aux = 0
  S3: j ‚Üê 2                                v = [5, 100, -6, 98, -111, 0]   min_index = 0   aux = 0
  S4: v[2] &lt; v[0] ? (-6 &lt; 5)     YES       v = [5, 100, -6, 98, -111, 0]   min_index = 0   aux = 0
  S5: min_index ‚Üê 2                        v = [5, 100, -6, 98, -111, 0]   min_index = 2   aux = 0
  S3: j ‚Üê 3                                v = [5, 100, -6, 98, -111, 0]   min_index = 2   aux = 0
  S4: v[3] &lt; v[2] ? (98 &lt; -6)    NO        v = [5, 100, -6, 98, -111, 0]   min_index = 2   aux = 0
  S3: j ‚Üê 4                                v = [5, 100, -6, 98, -111, 0]   min_index = 2   aux = 0
  S4: v[4] &lt; v[2] ? (-111 &lt; -6)  YES       v = [5, 100, -6, 98, -111, 0]   min_index = 2   aux = 0
  S5: min_index ‚Üê 4                        v = [5, 100, -6, 98, -111, 0]   min_index = 4   aux = 0
  S3: j ‚Üê 5                                v = [5, 100, -6, 98, -111, 0]   min_index = 4   aux = 0
  S4: v[5] &lt; v[4] ? (0 &lt; -111)   NO        v = [5, 100, -6, 98, -111, 0]   min_index = 4   aux = 0
  S6: v[0] != v[4] ? (5 != -111) YES       v = [5, 100, -6, 98, -111, 0]   min_index = 4   aux = -111
  S7: aux ‚Üê -111                           v = [5, 100, -6, 98, -111, 0]   min_index = 4   aux = -111
  S8: v[4] ‚Üê 5                             v = [5, 100, -6, 98, 5, 0]      min_index = 4   aux = -111
  S9: v[0] = -111                          v = [-111, 100, -6, 98, 5, 0]   min_index = 4   aux = -111
  S1: i ‚Üê 1                                v = [-111, 100, -6, 98, 5, 0]   min_index = 4   aux = -111
  S2: min_index ‚Üê 1                        v = [-111, 100, -6, 98, 5, 0]   min_index = 1   aux = -111
  S3: j ‚Üê 2                                v = [-111, 100, -6, 98, 5, 0]   min_index = 1   aux = -111
  S4: v[2] &lt; v[1] ? (-6 &lt; 100)   YES       v = [-111, 100, -6, 98, 5, 0]   min_index = 1   aux = -111
  S5: min_index ‚Üê 2                        v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S3: j ‚Üê 3                                v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S4: v[3] &lt; v[2] ? (98 &lt; -6)    NO        v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S3: j ‚Üê 4                                v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S4: v[4] &lt; v[2] ? (5 &lt; -6)     NO        v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S3: j ‚Üê 5                                v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S4: v[5] &lt; v[2] ? (0 &lt; -6)     NO        v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S6: v[1] != v[2] ? (100 != -6) YES       v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -111
  S7: aux ‚Üê -6                             v = [-111, 100, -6, 98, 5, 0]   min_index = 2   aux = -6
  S8: v[2] ‚Üê 100                           v = [-111, 100, 100, 98, 5, 0]  min_index = 2   aux = -6
  S9: v[1] = -6                            v = [-111, -6, 100, 98, 5, 0]   min_index = 2   aux = -6
  S1: i ‚Üê 2                                v = [-111, -6, 100, 98, 5, 0]   min_index = 2   aux = -6
  S2: min_index ‚Üê 2                        v = [-111, -6, 100, 98, 5, 0]   min_index = 2   aux = -6
  S3: j ‚Üê 3                                v = [-111, -6, 100, 98, 5, 0]   min_index = 2   aux = -6
  S4: v[3] &lt; v[2] ? (98 &lt; 100)   NO        v = [-111, -6, 100, 98, 5, 0]   min_index = 2   aux = -6
  S3: j ‚Üê 4                                v = [-111, -6, 100, 98, 5, 0]   min_index = 2   aux = -6
  S4: v[4] &lt; v[2] ? (5 &lt; 100)    YES       v = [-111, -6, 100, 98, 5, 0]   min_index = 2   aux = -6
  S5: min_index ‚Üê 4                        v = [-111, -6, 100, 98, 5, 0]   min_index = 4   aux = -6
  S3: j ‚Üê 5                                v = [-111, -6, 100, 98, 5, 0]   min_index = 4   aux = -6
  S4: v[5] &lt; v[4] ? (0 &lt; 5)      YES       v = [-111, -6, 100, 98, 5, 0]   min_index = 4   aux = -6
  S5: min_index ‚Üê 5                        v = [-111, -6, 100, 98, 5, 0]   min_index = 5   aux = -6
  S6: v[2] != v[5] ? (100 != 0)  YES       v = [-111, -6, 100, 98, 5, 0]   min_index = 5   aux = -6
  S7: aux ‚Üê 0                              v = [-111, -6, 100, 98, 5, 0]   min_index = 5   aux = 0
  S8: v[5] ‚Üê 100                           v = [-111, -6, 100, 98, 5, 100] min_index = 5   aux = 0
  S9: v[2] = 0                             v = [-111, -6, 0, 98, 5, 100]   min_index = 5   aux = 0
  S1: i ‚Üê 3                                v = [-111, -6, 0, 98, 5, 100]   min_index = 2   aux = 0
  S2: min_index ‚Üê 3                        v = [-111, -6, 0, 98, 5, 100]   min_index = 3   aux = 0
  S3: j ‚Üê 4                                v = [-111, -6, 0, 98, 5, 100]   min_index = 3   aux = 0
  S4: v[4] &lt; v[3] ? (5 &lt; 98)     YES       v = [-111, -6, 0, 98, 5, 100]   min_index = 3   aux = 0
  S5: min_index ‚Üê 4                        v = [-111, -6, 0, 98, 5, 100]   min_index = 4   aux = 0
  S3: j ‚Üê 5                                v = [-111, -6, 0, 98, 5, 100]   min_index = 4   aux = 0
  S4: v[5] &lt; v[4] ? (100 &lt; 5)    NO        v = [-111, -6, 0, 98, 5, 100]   min_index = 4   aux = 0
  S6: v[3] != v[4] ? (98 != 5)   YES       v = [-111, -6, 0, 98, 5, 100]   min_index = 4   aux = 0
  S7: aux ‚Üê 5                              v = [-111, -6, 0, 98, 5, 100]   min_index = 5   aux = 5
  S8: v[4] ‚Üê 98                            v = [-111, -6, 0, 98, 98, 100]  min_index = 5   aux = 5
  S9: v[3] = 5                             v = [-111, -6, 0, 5, 98, 100]   min_index = 5   aux = 5
  S1: i ‚Üê 4                                v = [-111, -6, 0, 5, 98, 100]   min_index = 5   aux = 5
  S2: min_index ‚Üê 4                        v = [-111, -6, 0, 5, 98, 100]   min_index = 5   aux = 5
  S3: j ‚Üê 5                                v = [-111, -6, 0, 5, 98, 100]   min_index = 5   aux = 5
  S4: v[5] &lt; v[4] ? (100 &lt; 98)   NO        v = [-111, -6, 0, 5, 98, 100]   min_index = 5   aux = 5
</code></pre></div></div>

<p>Como podemos ver, dada a entrada <code class="language-plaintext highlighter-rouge">[5, 100, -6, 98, -111, 0]</code>, retorna a sa√≠da <code class="language-plaintext highlighter-rouge">[-111, -6, 0, 5, 98, 100]</code>. Portanto, na sa√≠da n√£o h√° valor <code class="language-plaintext highlighter-rouge">v[i]</code> e <code class="language-plaintext highlighter-rouge">v[j]</code> onde <code class="language-plaintext highlighter-rouge">i &lt; j</code> e <code class="language-plaintext highlighter-rouge">v[i] &gt; v[j]</code>, isso significa que o array est√° ordenado.</p>

<h1 id="conclus√£o">Conclus√£o</h1>

<p>Agora sabemos o que algoritmos s√£o similares a receitas, mas n√£o s√£o receitas. Se voc√™ ver um passo em uma receita dizendo ‚Äúadicione sal‚Äù, voc√™ vai saber o que fazer, mas um computador n√£o pode fazer nada porque ele n√£o conseguir√° definir a quantidade de sal necess√°ria. Ou se houver um passo ‚Äúdeixe no forno at√© dourar‚Äù, o computador pode n√£o entender que o forno deve estar ligado e nem quanto tempo √© necess√°rio para dourar uma carne.</p>

<p>Receitas s√£o avaliadas pelo seu resultado, se √© agrad√°vel ao paladar ou n√£o. J√° algoritmos s√£o avaliados pelo n√∫mero de passos que ele tem ou pelos pr√≥prios passos. Um algoritmo que executa menos passos at√© chegar um resultado √© mais r√°pido que outro que executa mais passos, mas um algoritmo que executa menos passo pode em determinados cen√°rios executar mais passos. Quando avaliamos a performance de um algoritmo devemos levar em conta o caso m√©dio, ou quantos passos s√£o necess√°rios para se encontrar uma resposta para um problema de tamanho <code class="language-plaintext highlighter-rouge">n</code>, temos o contexto de <em>analise de algoritmos</em>. Em An√°lise de Algoritmos, s√£o estudados como os algoritmos performam sob determinadas circunst√¢ncias afim de tentar entender a melhor forma de usar eles.</p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Algoritmo" /><category term="Ci√™ncia da Computa√ß√£o" /><summary type="html"><![CDATA[O que √© um algoritmo? O que define um algoritmo?]]></summary></entry></feed>