<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/Complexidade.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2025-10-07T11:58:40+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/Complexidade.xml</id><title type="html">vepo</title><subtitle>Um reposit√≥rio para todos os posts, palestras e tutoriais que j√° fiz. Java, Desenvolvimento de Software e reflex√µes sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">Sobre Design de C√≥digo: Refer√™ncias, Filosofias e Pr√°ticas para C√≥digo de Qualidade</title><link href="https://blog.vepo.dev/posts/sobre-design-de-codigo" rel="alternate" type="text/html" title="Sobre Design de C√≥digo: Refer√™ncias, Filosofias e Pr√°ticas para C√≥digo de Qualidade" /><published>2023-09-26T00:00:00+00:00</published><updated>2023-09-26T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/15-39-23-design-de-codigo</id><content type="html" xml:base="https://blog.vepo.dev/posts/sobre-design-de-codigo"><![CDATA[<h2 id="introdu√ß√£o">Introdu√ß√£o</h2>
<p>Design de c√≥digo √© um tema fundamental para desenvolvedores que buscam criar software sustent√°vel, leg√≠vel e eficiente. Neste post, exploramos refer√™ncias cr√≠ticas, filosofias √∫teis e pr√°ticas para evitar armadilhas comuns, baseado em uma discuss√£o aprofundada sobre o assunto. Se voc√™ j√° se perguntou por que seu c√≥digo parece complexo demais ou como melhorar sua abordagem de design, este conte√∫do √© para voc√™.</p>

<hr />
<iframe width="560" height="315" src="https://www.youtube.com/embed/Ih1SoBpAvFs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<hr />

<h2 id="refer√™ncias-o-que-ler-e-o-que-evitar">Refer√™ncias: O Que Ler (e o Que Evitar)</h2>
<p>O v√≠deo discute v√°rias refer√™ncias sobre design de c√≥digo, destacando:</p>
<ul>
  <li><strong>Clean Code</strong>: Apesar de popular, o livro √© criticado por ser ‚Äúpassional demais‚Äù e promover regras absolutas que podem limitar o pensamento cr√≠tico. O autor alerta para o perigo de tratar o livro como um dogma, j√° que ele est√° vinculado a uma empresa de consultoria.</li>
  <li><strong>A Philosophy of Software Design</strong>: Um livro menos conhecido, mas elogiado por oferecer respostas complexas e contextualizadas para problemas de design, em vez de solu√ß√µes simplistas.</li>
  <li><strong>Working Effectively with Legacy Code</strong> e <strong>Domain-Driven Design (DDD)</strong>: Ambos s√£o recomendados, mas com ressalvas‚Äîo primeiro foca em c√≥digo legado, e o segundo em design mais amplo, n√£o apenas em c√≥digo.</li>
</ul>

<p><strong>Dica:</strong> Evite seguir regras absolutas. C√≥digo ‚Äúperfeito‚Äù segundo m√©tricas como SonarQube pode ainda ser complexo e dif√≠cil de manter se n√£o houver abstra√ß√µes adequadas.</p>

<hr />

<h2 id="como-pensar-em-design-de-c√≥digo">Como Pensar em Design de C√≥digo</h2>
<h3 id="1-complexidade-origem-e-gest√£o">1. <strong>Complexidade: Origem e Gest√£o</strong></h3>
<p>C√≥digo ruim geralmente √© c√≥digo complexo. A complexidade surge de:</p>
<ul>
  <li><strong>Mudan√ßas custosas</strong>: Quando uma pequena altera√ß√£o exige modifica√ß√µes em m√∫ltiplos lugares.</li>
  <li><strong>Dificuldade cognitiva</strong>: C√≥digo dif√≠cil de entender, especialmente sem documenta√ß√£o ou coment√°rios (sim, coment√°rios s√£o v√°lidos!).</li>
  <li><strong>Desconhecidos</strong>: Suposi√ß√µes n√£o documentadas que parecem √≥bvias para o autor, mas n√£o para outros.</li>
</ul>

<h3 id="2-maturidade-do-time">2. <strong>Maturidade do Time</strong></h3>
<p>C√≥digo ruim n√£o √© uma falha moral‚Äî√© fruto de contexto. Times imaturos (por falta de experi√™ncia, n√£o de car√°ter) podem produzir c√≥digo problem√°tico. A solu√ß√£o?</p>
<ul>
  <li>Compartilhamento de conhecimento (palestras r√°pidas, mentorias).</li>
  <li>Feedbacks construtivos em code reviews.</li>
</ul>

<h3 id="3-processos-ruins-geram-c√≥digo-ruim">3. <strong>Processos Ruins Geram C√≥digo Ruim</strong></h3>
<p>Prazos irreais, decis√µes arquiteturais precipitadas ou falta de revis√£o de c√≥digo s√£o vil√µes comuns. O v√≠deo sugere:</p>
<ul>
  <li><strong>Procrastinar decis√µes</strong>: N√£o implemente solu√ß√µes ‚Äúperfeitas‚Äù antecipadamente se o problema ainda n√£o existe.</li>
  <li><strong>Equil√≠brio entre t√°tico e estrat√©gico</strong>: Desenvolvedores ‚Äút√°ticos‚Äù (focados em features r√°pidas) podem ser √∫teis em prot√≥tipos, mas projetos de longo prazo exigem pensamento estrat√©gico.</li>
</ul>

<hr />

<h2 id="filosofias-√∫teis">Filosofias √öteis</h2>
<ul>
  <li><strong>KISS (Keep It Simple, Stupid)</strong>: Priorize simplicidade.</li>
  <li><strong>YAGNI (You Aren‚Äôt Gonna Need It)</strong>: N√£o adicione funcionalidades ‚Äúpor precau√ß√£o‚Äù.</li>
  <li><strong>DRY (Don‚Äôt Repeat Yourself)</strong>: Automatize repeti√ß√µes, mas aplique a ‚Äúregra dos tr√™s‚Äù (s√≥ generalize ap√≥s tr√™s usos).</li>
  <li><strong>Filosofia Unix</strong>: Escreva programas modulares, pequenos, e que falhem de forma clara.</li>
</ul>

<hr />

<h2 id="padr√µes-de-design-como-vocabul√°rio">Padr√µes de Design como Vocabul√°rio</h2>
<p>Padr√µes (como Factory, Proxy ou Observer) n√£o s√£o solu√ß√µes m√°gicas, mas ferramentas para descrever problemas comuns. Use-os para:</p>
<ul>
  <li><strong>Criar vocabul√°rio compartilhado</strong>: Exemplo: ‚ÄúEste consumidor Kafka usa Proxy em camadas‚Äù.</li>
  <li><strong>Evitar solu√ß√µes ruins</strong>: Alguns padr√µes (como Singleton mal aplicado) geram mais problemas que benef√≠cios.</li>
</ul>

<p><strong>Dica:</strong> Estude o ‚Äúidioma‚Äù da sua linguagem. C√≥digo Python escrito como Java (ou vice-versa) soa estranho e pode ser menos eficiente.</p>

<hr />

<h2 id="conclus√£o">Conclus√£o</h2>
<p>Design de c√≥digo √© uma habilidade que se aprimora com experi√™ncia, estudo e colabora√ß√£o. N√£o existem ‚Äúher√≥is da programa√ß√£o‚Äù‚Äîapenas pessoas que tiveram oportunidades e souberam aproveit√°-las. Para evoluir:</p>
<ul>
  <li><strong>Leia c√≥digo alheio</strong> e discuta designs com seu time.</li>
  <li><strong>Estude fundamentos</strong>: Programa√ß√£o funcional, matem√°tica ou novos paradigmas podem melhorar seu racioc√≠nio.</li>
  <li><strong>Pense criticamente</strong>: Regras s√£o guias, n√£o leis.</li>
</ul>

<blockquote>
  <p>‚ÄúC√≥digo ruim √© fruto de contexto, n√£o de car√°ter.‚Äù</p>
</blockquote>

<p><strong>Palavras-chave:</strong> design de c√≥digo, clean code, complexidade, KISS YAGNI DRY, padr√µes de design, filosofia Unix, code review.</p>

<p>Gostou? Compartilhe suas d√∫vidas ou experi√™ncias nos coment√°rios! üöÄ</p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Design de C√≥digo" /><category term="Complexidade" /><summary type="html"><![CDATA[Design de c√≥digo √© um tema fundamental para desenvolvedores que buscam criar software sustent√°vel, leg√≠vel e eficiente. Neste post, exploramos refer√™ncias cr√≠ticas, filosofias √∫teis e pr√°ticas para evitar armadilhas comuns, baseado em uma discuss√£o aprofundada sobre o assunto. Se voc√™ j√° se perguntou por que seu c√≥digo parece complexo demais ou como melhorar sua abordagem de design, este conte√∫do √© para voc√™.]]></summary></entry><entry><title type="html">A Filosofia do Design de C√≥digo</title><link href="https://blog.vepo.dev/posts/a-filosofia-do-design-de-codigo" rel="alternate" type="text/html" title="A Filosofia do Design de C√≥digo" /><published>2021-07-21T00:00:00+00:00</published><updated>2021-07-21T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/12-00-00-a-filosofia-do-design-de-codigo</id><content type="html" xml:base="https://blog.vepo.dev/posts/a-filosofia-do-design-de-codigo"><![CDATA[<p>Muitos engenheiros desconhecem as ci√™ncias humanas. Acreditam que √© perca de tempo esse tipo de estudo. Porque vou estudar o modo com pensamos? Porque vamos estudar o modo como a sociedade √© organizada? Ou o modo como os fen√¥menos sociais acontecem? Ou quem sabe como a l√≠ngua evolui? Bom, cada √°rea dessa tem muito a ajudar, talvez um engenheiro n√£o saiba disso por puro desconhecimento.
Desconhecimento s√≥ se resolve com conhecimento, e por isso que levanto o seguinte questionamento: <em>como a filosofia pode ajudar no desenvolvimento de software?</em></p>

<hr />

<h1 id="o-que-√©-filosofia">O que √© filosofia?</h1>

<p>Antes de tudo, precisamos antes entender ao que a filosofia se prop√µe. Temos no nosso imagin√°rio a ideia do fil√≥sofo como algu√©m depressivo que vive pensando na vida, algu√©m solit√°rio. Esse estere√≥tipo n√£o √© verdadeiro. Para quem lembra do desenho Peanuts (ou Turma do Charlie Brown ou Snoopy), o Charlie Brown √© s√≥ um cara meio depressivo e inteligente.</p>

<p><img src="/assets/images/filosofia.avif" alt="Essa imagem √© o resumo da filosofia cl√°ssica." /></p>

<p>Mas n√≥s n√£o estamos aqui para falar de filosofia, mas da filosofia do design de c√≥digo‚Ä¶</p>

<hr />

<h1 id="o-que-√©-design-dec√≥digo">O que √© Design de¬†C√≥digo?</h1>

<p>Estamos tentando pensar o que √© Design de C√≥digo, para isso vamos iniciar com uma sugest√£o:</p>

<blockquote>
  <p><em>Design de C√≥digo s√£o T√©cnicas que diminuem a complexidade do c√≥digo.</em></p>
</blockquote>

<p>Na verdade dessa afirma√ß√£o √© verdadeira, mas ela √© vaga. Primeiro porque n√£o sabemos exatamente o que √© uma t√©cnica. Depois n√£o sabemos definir exatamente o que √© complexidade. E por fim, sabemos o real objetivo de se escrever c√≥digo?</p>

<h1 id="o-que-√©-umat√©cnica">O que √© uma¬†T√©cnica?</h1>

<p>A defini√ß√£o de T√©cnica √© bem complexa. Na realidade, √© um assunto que tenho bastante interesse e por isso, se te interessar, recomendo a leitura o livro ‚Äú<em>The Technological Society</em>‚Äù do Jacques Ellul. Eu estou relendo esse livro e fazendo os resumos da minha leitura.</p>

<p>Se eu precisar resumir o que √© T√©cnica, eu partiria da defini√ß√£o do Ellul de Opera√ß√£o T√©cnica no primeiro capitulo do seu livro.</p>

<blockquote>
  <p><em>T√©cnica pode ser definida como qualquer opera√ß√£o, ou conjunto de opera√ß√µes, executada com um determinado <strong>m√©todo</strong> com o <strong>objetivo</strong> a ser atingido.</em></p>
</blockquote>

<p>Baseado nessa defini√ß√£o podemos concluir que o Design de C√≥digo √© um m√©todo e tem um objetivo claro.</p>

<p>O m√©todo n√£o √© t√£o f√°cil de deduzir, mas quem j√° estudou engenharia √© capaz pensar em um m√©todo. Vamos propor um bem simples? Primeiro temos que ter estat√≠sticas, fazer algumas mudan√ßas e verificar o que aconteceu com essas estat√≠sticas. Isso √© o que chamamos de itera√ß√£o, a cada itera√ß√£o nosso c√≥digo deve estar mais pr√≥ximo do seu objetivo que √© <strong>n√£o ser complexo</strong>. Quem quiser pensar mais nas estat√≠sticas, recomendo o post do Alberto Souza <a href="https://www.zup.com.br/blog/design-de-codigo-seu-papel-ate-hoje">Design de c√≥digo: seu papel at√© hoje</a>.</p>

<p>O objetivo do Design de C√≥digo j√° est√° na defini√ß√£o diminuir a complexidade. Mas o que √© complexidade? Porque ela acontece? Que tipos de complexidade existem?</p>

<h1 id="porque-existe-complexidade">Porque existe complexidade?</h1>

<p>Quando falamos de complexidade de software, muitos desenvolvedores tem em mente bibliotecas e linguagens altamente complexas. Isso acontece porque muitos j√° nasceram em um mundo onde √© poss√≠vel declarar um objeto e dar ordens ao objeto. Mas isso √© muito alto n√≠vel. Na verdade isso √© extremamente abstrato, computadores n√£o sabem o que s√£o objetos e n√£o sabem o que s√£o ordens. Ent√£o vamos nos perguntar o que os computadores entendem?</p>

<p><img src="/assets/images/apollo11.png" alt="Olha o c√≥digo da igni√ß√£o da Apolo 11! üò≤" /></p>

<p>Todo computador vai compreender bits, um conjunto de instru√ß√µes b√°sicas e alguns perif√©ricos como monitor, teclado, placa de rede. Isso √© um computador, uma m√°quina burra que apenas pega a pr√≥xima instru√ß√£o da mem√≥ria e executa ela alterando valores no barramento ou registradores.</p>

<p><strong><em>- Conseguiu entender?</em></strong></p>

<p><img src="/assets/images/opcode.png" alt="Exemplo de Opcode" /></p>

<p>√â √≥bvio que n√£o! Para escrever c√≥digo era preciso muita compreens√£o, muita aten√ß√£o, al√©m de saber decorado que valores estavam nos registradores e todos os comandos que o processador aceita. Era uma atividade extremamente complexa. Quando estudei linguagem de montagens, o professor nos encorajava a construir fluxogramas detalhados sobre a execu√ß√£o do programa. Era preciso antes de colocar o primeiro <em>opcode</em> (entenda como um n√∫mero para cada opera√ß√£o e alguns par√¢metros) ter o desenho completo do que iria acontecer e onde cada informa√ß√£o seria armazenada.</p>

<p>Percebeu que eu n√£o falei vari√°vel? Sim, nem esse conceito existia. O que existia era informa√ß√£o na mem√≥ria: c√≥digo de execu√ß√£o, sistema operacional, vari√°veis, constantes, etc‚Ä¶ Quem bom que n√£o precisamos mais disso! S√≥ quem trabalha com IoT e drivers.</p>

<p>Mas porque eu fiz esse passeio hist√≥rico? <strong>Para dizer que linguagens de programa√ß√£o existem para diminuir a complexidade.</strong> Complexidade j√° existe em software porque m√°quinas s√£o complicadas e burras ao mesmo tempo. Reza a lenda que Dennis Ritchie desenvolveu a linguagem C porque queria desenvolver um jogo‚Ä¶ Bom era isso que falavam na √©poca que eu estava na faculdade.</p>

<p>A complexidade √© acidental em software. Ela sempre vai existir. Sem uma boa linguagem de programa√ß√£o, muito que temos hoje n√£o existiria. Testes de Software n√£o seriam poss√≠vel de automatizar. Bibliotecas s√£o muito complexas de serem criadas. A compreens√£o do c√≥digo √© praticamente imposs√≠vel, leia o c√≥digo da <a href="https://github.com/chrislgarry/Apollo-11">Apollo 11</a> e observe que h√° mais coment√°rios do que c√≥digo. Sem uma boa linguagem de programa√ß√£o a afirma√ß√£o do Uncle Bob dizendo que coment√°rios s√£o desnecess√°rios √© rid√≠cula.</p>

<h1 id="pr√≥ximos-passos">Pr√≥ximos passos</h1>

<p>Nesse post eu tratei de tudo aquilo que n√£o vou falar mais. O que √© filosofia. De onde vem a complexidade. O que √© t√©cnica.</p>

<p>Nos pr√≥ximos passos vou tentar definir o que √© Complexidade.</p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Complexidade" /><category term="Design de C√≥digo" /><category term="Programa√ß√£o" /><summary type="html"><![CDATA[Uma introdu√ß√£o da palestra que farei sobre Filosofia do Design de C√≥digo no TheDevConf 2021.]]></summary></entry><entry><title type="html">O que √© complexidade?</title><link href="https://blog.vepo.dev/posts/o-que-e-complexidade" rel="alternate" type="text/html" title="O que √© complexidade?" /><published>2021-03-04T00:00:00+00:00</published><updated>2021-03-04T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/12-00-00-o-que-e-complexidade</id><content type="html" xml:base="https://blog.vepo.dev/posts/o-que-e-complexidade"><![CDATA[<h2 id="motivador">Motivador</h2>

<p>Comecei a ler o livro <a href="https://www.amazon.com.br/Philosophy-Software-Design-2nd-English-ebook/dp/B09B8LFKQL?keywords=Philosophy-Software-Design-English&amp;qid=1667927943&amp;sr=8-5&amp;ufe=app_do%3Aamzn1.fos.6121c6c4-c969-43ae-92f7-cc248fc6181d&amp;linkCode=ll1&amp;tag=vepo0f-20&amp;linkId=191bf91d38700ad4d84885900b3b695a&amp;language=pt_BR&amp;ref_=as_li_ss_tl">A Philosophy of Software Design</a>, o livro surge das notas de aula de um curso de <a href="https://web.stanford.edu/~ouster/cgi-bin/cs190-winter20/index.php">Software Design na Stanforn University CS-190</a>.</p>

<p>Esse √© um curso que eu gostaria de fazer, tendo cursado uma modalidade praticamente industrial de Engenharia de Computa√ß√£o, muito do meu foco na gradua√ß√£o foi desenvolvimento C e Assembler. Ao entrar no mercado tive que aprender a abstrair, e abstra√ß√£o √© tudo no mundo de software.</p>

<p>Essas notas ser√£o livres, n√£o se prop√µes a serem um resumo do livro.</p>

<h2 id="software-e-diagramas">Software e Diagramas</h2>

<p>Voc√™ pode n√£o ter desenhado nenhum diagram do seu software ou do seu sistema como um todo. Mas esse diagrama existe, ele √© virtual, √© baseado no conjunto das intera√ß√µes de cada pe√ßa do seu sistema, de cada classe do seu software. Voc√™ vai come√ßar a racionalizar ele quando come√ßar a colocar ‚Äúno papel‚Äù esses diagramas.</p>

<p>Na Engenharia de Software existem v√°rias ferramentas e linguagens de apresenta√ß√£o que voc√™ pode usar, mas eu recomendo uma bem mais simples pra come√ßar: <a href="https://dev.to/vepo/start-a-project-by-the-readme-4c49">README.md</a>.</p>

<p><img src="/assets/images/software-design/notes.jpeg" alt="Notas em um quadro" /></p>

<p>Quando for come√ßar a escrever, pense em quem vai ler. O que √© preciso saber? Coloque suas ideias em uma sess√£o chamada <strong>Racional</strong>. Depois coloque uma sess√£o (ou um novo documento) com todas as informa√ß√µes necess√°rias para execu√ß√£o. Por fim v√° descrevendo cada conceito que seu software tem, um gloss√°rio com os termos usados.</p>

<p>Eric Evans em <a href="https://www.amazon.com.br/Domain-Driven-Design-Eric-Evans/dp/8550800651?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=1Q6E8PM9BGI79&amp;dchild=1&amp;keywords=domain+driven+design&amp;qid=1611780458&amp;sprefix=domain%2Caps%2C870&amp;sr=8-1&amp;linkCode=ll1&amp;tag=vepo0f-20&amp;linkId=35481008730f03c32f145959755e807a&amp;language=pt_BR&amp;ref_=as_li_ss_tl">Domain-Driven Design</a> afirma que cada projeto tem sua Linguagem Onipresente, est√° √© a defini√ß√£o dos termos que em comum entre o c√≥digo e o neg√≥cio. √â muito importante esses termos estarem bem definidos.</p>

<p>Se poss√≠vel, coloque as decis√µes arquiteturais tamb√©m. Crie um diret√≥rio de documenta√ß√£o e fa√ßa a lista com tudo que foi cogitado e escolhido. <em>Porque n√£o usamos tal biblioteca?</em></p>

<blockquote>
  <p><em>A grande limita√ß√£o ao se escrever software, √© entender o sistemas que estamos criando.</em></p>
</blockquote>

<p>Software √© complexo, e podemos reduzir essa complexidade documentando as ideias e conceitos que estamos usando. Um simples desenho vai ajudar muito que pode te ajudar a desenvolver.</p>

<h2 id="de-onde-vem-a-complexidade">De onde vem a complexidade?</h2>

<p>A complexidade vem da dificuldade de compreens√£o. Qualquer dificuldade de compreens√£o no desenvolvimento/manuten√ß√£o do software causar√° dificuldade.</p>

<p>Segundo John Ousterhout, os sintomas da complexidade s√£o:</p>

<ul>
  <li>
    <p><strong>Mudan√ßa amplificada</strong>: se para fazer uma altera√ß√£o simples, for necess√°ria altera√ß√µes em v√°rios locais, seu software √© complexo.</p>
  </li>
  <li>
    <p><strong>Carga Cognitica</strong>: o quanto √© necess√°rio para um desenvolvedor saber quando for fazer altera√ß√µes em seu c√≥digo? A Carga Cognitiva pode ser atacada pela modulariza√ß√£o. Se criarmos bons m√≥dulos ou componentes, podemos isolar conceitos deixando-os encapsulado. Imagine uma Arquitetura Orientada a Eventos, cada microsservi√ßos ter√° que implementar seu produtor e consumidor de eventos, cada microsservi√ßos ter√° que implementar seus m√≥dulos de serializa√ß√£o. Mas no fundo isso ser√° um padr√£o no sistema, e se isso fosse uma biblioteca/framework?</p>
  </li>
  <li>
    <p><strong>Desconhecidos Desconhecidos</strong>: A informa√ß√£o tem que ser evidente. Exemplos de desconhecidos desconhecidos? Uma procedure SQL que altera valores na base e n√£o est√£o configurada na base de c√≥digo.</p>
  </li>
</ul>

<blockquote>
  <p><em>Um dos mais importantes objetivos de um bom Desgin √© para um sistema ser √≥bvio.</em></p>
</blockquote>

<p>A complexidade vem principalmente de depend√™ncias e obscuridade. Depend√™ncia significa quando uma parte depende de outra, quanto menos depend√™ncias entre as partes, menos complexidade seu software ter√°. E obscuridade significa aquilo que n√£o √© obvio, seu software tem comportamentos m√°gicos ou paranormais? Se for escolher entre fazer algo que pare√ßa m√°gica, fa√ßa uma boa escolha e documente o processo.</p>

<p>Por fim, a complexidade √© incremental. Nenhum software √© descart√°vel, todos podem ser salvos. Se voc√™ encontra muita dificuldade, uma pergunta que se tem que fazer: <em>quanto custaria pra reescrever tudo?</em> Nunca parta para op√ß√£o de reescrever sem antes ter uma estat√≠stica e provavelmente ser√° a op√ß√£o mais cara.</p>

<p>Caso n√£o queira reescrever, um dica √© o livro <a href="https://www.amazon.com.br/Trabalho-Eficaz-com-C%C3%B3digo-Legado/dp/8582600321?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;dchild=1&amp;keywords=trabalhando+legado&amp;qid=1611783106&amp;sr=8-1&amp;linkCode=ll1&amp;tag=vepo0f-20&amp;linkId=ca23ee34596853e70ef5ace4fa0ed96f&amp;language=pt_BR&amp;ref_=as_li_ss_tl">Trabalho Eficaz com C√≥digo Legado</a>. Nele o autor vai trabalhar v√°rias abordagens de como trabalhar com seu c√≥digo. Uma que j√° validei em uma empresa que trabalhei foi fazer uma fachada em alguns m√≥dulos. Criar uma interface e ir reescrevendo os m√≥dulos aos poucos. Outra √© voc√™ ir fazendo mudan√ßas pequenas, melhorando o design.</p>

<h2 id="conclus√£o">Conclus√£o</h2>

<p>Todo design de software evolui. Se hoje pode estar bom, em poucos meses pode estar ruim. Vale pensar em como as funcionalidades devem ser colocadas.</p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Design de Software" /><category term="Arquitetura de Software" /><category term="Complexidade" /><summary type="html"><![CDATA[O que tr√°s complexidade a um projeto de software?]]></summary></entry></feed>