<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/Quarkus.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2026-02-21T19:42:20+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/Quarkus.xml</id><title type="html">vepo</title><subtitle>Um repositório para todos os posts, palestras e tutoriais que já fiz. Java, Desenvolvimento de Software e reflexões sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">A Evolução do Java no Backend: Jakarta EE, Spring e Quarkus</title><link href="https://blog.vepo.dev/posts/java-no-backend" rel="alternate" type="text/html" title="A Evolução do Java no Backend: Jakarta EE, Spring e Quarkus" /><published>2023-10-16T00:00:00+00:00</published><updated>2023-10-16T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/11-15-52-java-no-backend</id><content type="html" xml:base="https://blog.vepo.dev/posts/java-no-backend"><![CDATA[<p>O ecossistema Java para desenvolvimento backend passou por diversas transformações ao longo dos anos, desde os primórdios da orientação a objetos até as modernas soluções como microsserviços e contêineres. Neste post, exploramos essa jornada, destacando as tecnologias que moldaram o Java no backend e como elas se relacionam hoje.</p>

<hr />
<iframe width="560" height="315" src="https://www.youtube.com/embed/uTHZet430rs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<hr />

<h2 id="1-as-fases-do-java-no-backend"><strong>1. As Fases do Java no Backend</strong></h2>

<h3 id="orientação-a-objetos-e-servidores-de-aplicação"><strong>Orientação a Objetos e Servidores de Aplicação</strong></h3>
<ul>
  <li><strong>Anos 90</strong>: Java surgiu em 1995 incorporando conceitos como CORBA e servlets (1996).</li>
  <li><strong>J2EE (1999)</strong>: Trouxe soluções como EJB (Enterprise JavaBeans) para objetos distribuídos e JDBC para conexão com bancos de dados.</li>
  <li><strong>Servidores de Aplicação (2001)</strong>: Como JBoss e WebLogic, permitiam deploy de aplicações em um único processo Java, facilitando a gestão de recursos.</li>
</ul>

<h3 id="a-revolução-do-docker-2013"><strong>A Revolução do Docker (2013)</strong></h3>
<ul>
  <li>A conteinerização mudou a forma como aplicações eram deployadas, eliminando a necessidade de servidores de aplicação monolíticos.</li>
  <li>Java 8 (2014) e Spring Boot surgiram como respostas ágeis a essa nova era.</li>
</ul>

<hr />

<h2 id="2-jakarta-ee-o-modelo-baseado-em-especificações"><strong>2. Jakarta EE: O Modelo Baseado em Especificações</strong></h2>
<p>Jakarta EE (antigo Java EE) é um <strong>modelo de programação baseado em specs</strong>, garantindo compatibilidade e flexibilidade.</p>

<h3 id="principais-especificações"><strong>Principais Especificações</strong></h3>
<ul>
  <li><strong>JPA</strong>: Persistência de dados.</li>
  <li><strong>JAX-RS</strong>: Desenvolvimento de APIs REST.</li>
  <li><strong>Bean Validation</strong>: Validação de dados com anotações.</li>
  <li><strong>CDI</strong>: Injeção de dependências.</li>
</ul>

<h3 id="vantagens"><strong>Vantagens</strong></h3>
<ul>
  <li><strong>Estabilidade</strong>: Código escrito há 20 anos ainda roda em servidores modernos.</li>
  <li><strong>Portabilidade</strong>: Depende de interfaces, não de implementações específicas.</li>
</ul>

<h3 id="microprofile-jakarta-ee-para-microsserviços"><strong>MicroProfile: Jakarta EE para Microsserviços</strong></h3>
<ul>
  <li>Extensão do Jakarta EE com foco em:
    <ul>
      <li>Observabilidade (OpenTelemetry).</li>
      <li>Tolerância a falhas.</li>
      <li>Autenticação via JWT.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="3-spring-acelerando-o-desenvolvimento"><strong>3. Spring: Acelerando o Desenvolvimento</strong></h2>
<ul>
  <li><strong>Contexto</strong>: Surgiu para simplificar o desenvolvimento Java EE, que era lento e burocrático.</li>
  <li><strong>Spring Boot (2014)</strong>: Revolucionou com:
    <ul>
      <li>Executáveis independentes (sem servidor de aplicação).</li>
      <li>Configuração simplificada (menos XML, mais anotações).</li>
    </ul>
  </li>
</ul>

<h3 id="comparação-com-jakarta-ee"><strong>Comparação com Jakarta EE</strong></h3>
<p>| <strong>Spring</strong>          | <strong>Jakarta EE</strong>       |
|———————-|———————-|
| <code class="language-plaintext highlighter-rouge">@GetMapping</code>       | <code class="language-plaintext highlighter-rouge">@Path</code> (JAX-RS)    |
| <code class="language-plaintext highlighter-rouge">@RestController</code>   | <code class="language-plaintext highlighter-rouge">@ApplicationScoped</code> (CDI) |
| Foco em produtividade | Foco em padrões empresariais |</p>

<hr />

<h2 id="4-quarkus-java-para-a-era-kubernetes"><strong>4. Quarkus: Java para a Era Kubernetes</strong></h2>
<ul>
  <li><strong>Origem</strong>: Evolução do JBoss/WildFly, focada em:
    <ul>
      <li><strong>Tempo de inicialização rápido</strong> (crucial para microsserviços).</li>
      <li><strong>Experiência do desenvolvedor</strong> (live coding, integração com Kubernetes).</li>
    </ul>
  </li>
  <li><strong>Relacionamento com Jakarta EE</strong>: Implementa specs como JAX-RS e CDI, mas com abordagem moderna.</li>
</ul>

<hr />

<h2 id="conclusão-qual-escolher"><strong>Conclusão: Qual Escolher?</strong></h2>
<ul>
  <li><strong>Jakarta EE</strong>: Ideal para aplicações empresariais robustas e de longa vida.</li>
  <li><strong>Spring</strong>: Melhor para produtividade e adoção rápida.</li>
  <li><strong>Quarkus</strong>: Focado em microsserviços e cloud-native.</li>
</ul>

<h3 id="dicas-para-aprofundar"><strong>Dicas para Aprofundar</strong></h3>
<ol>
  <li>Explore specs como <strong>JAX-RS</strong> e <strong>Bean Validation</strong>.</li>
  <li>Experimente starters em <a href="https://start.jakarta.ee">start.jakarta.ee</a> e <a href="https://code.quarkus.io">code.quarkus.io</a>.</li>
  <li>Para Spring, use <a href="https://start.spring.io">start.spring.io</a>.</li>
</ol>

<p>O Java no backend continua evoluindo, e entender essas tecnologias é essencial para escolher a melhor ferramenta para seu projeto.</p>

<p><strong>#Java #JakartaEE #Spring #Quarkus #Backend</strong></p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Java" /><category term="Backend" /><category term="Quarkus" /><category term="Spring" /><category term="Jakarta EE" /><summary type="html"><![CDATA[O ecossistema Java para desenvolvimento backend passou por diversas transformações ao longo dos anos, desde os primórdios da orientação a objetos até as modernas soluções como microsserviços e contêineres. Neste post, exploramos essa jornada, destacando as tecnologias que moldaram o Java no backend e como elas se relacionam hoje.]]></summary></entry></feed>