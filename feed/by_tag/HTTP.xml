<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/HTTP.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2026-02-21T19:42:20+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/HTTP.xml</id><title type="html">vepo</title><subtitle>Um repositório para todos os posts, palestras e tutoriais que já fiz. Java, Desenvolvimento de Software e reflexões sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">Habilitando HTTPS com Let’s Encrypt!</title><link href="https://blog.vepo.dev/posts/usando-https-com-lets-encrypt" rel="alternate" type="text/html" title="Habilitando HTTPS com Let’s Encrypt!" /><published>2026-01-07T00:00:00+00:00</published><updated>2026-01-07T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/09-04-00-usando-https-com-lets-encrypt</id><content type="html" xml:base="https://blog.vepo.dev/posts/usando-https-com-lets-encrypt"><![CDATA[<div class="paragraph">
<p>Se você tem uma aplicação web rodando em qualquer framework — como Quarkus, Spring Boot ou outro — e quer proteger sua comunicação usando HTTPS, este tutorial é para você.</p>
</div>
<div class="paragraph">
<p>Aqui, vamos configurar o NGINX como um <strong>servidor proxy reverso</strong>, responsável por gerenciar as conexões seguras (TLS/SSL) com os certificados gratuitos da <strong>Let&#8217;s Encrypt</strong>. Sua aplicação continuará rodando normalmente, enquanto o NGINX cuida da criptografia, liberando você para focar no código.</p>
</div>
<div class="paragraph">
<p>A ideia é simples: configuramos um domínio apontando para o nosso servidor, obtemos um certificado digital que valida a propriedade desse domínio e, por fim, ajustamos o NGINX para redirecionar o tráfego criptografado para a sua aplicação, independentemente da tecnologia que você usa.</p>
</div>
<div class="paragraph">
<p>Vamos começar?</p>
</div>
<div class="sect1">
<h2 id="_porque-usar-https">Porque usar HTTPS?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O HTTPS nada mais é que o protocolo HTTP protegido por uma camada de TLS.</p>
</div>
<div class="paragraph">
<p>É importante destacar que não se trata de um protocolo completamente novo — do ponto de vista do servidor da aplicação, a comunicação continua sendo HTTP.</p>
</div>
<div class="paragraph">
<p>A diferença está na conexão entre cliente e servidor, que agora passa por uma etapa adicional de segurança antes de transmitir os dados, conforme ilustrado no diagrama abaixo.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/images/http/https-osi.png" alt="https osi">
</div>
<div class="title">Figura 1. HTTP, HTTPS e o Modelo OSI como comparação</div>
</div>
<div class="paragraph">
<p>Nosso servidor web continua funcionando exatamente como antes. A diferença é que, com o HTTPS, ele pode ser acessado por meio de um <strong>gateway</strong> HTTP — como o NGINX — que fica entre o cliente e a aplicação.</p>
</div>
<div class="paragraph">
<p>O fluxo funciona assim:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O cliente se conecta na porta 443 (HTTPS padrão).</p>
</li>
<li>
<p>O gateway recebe a requisição criptografada, descriptografa-a e a converte em uma requisição HTTP comum.</p>
</li>
<li>
<p>Em seguida, ele a encaminha ao servidor da aplicação, que responde como de costume.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Além disso, esse mesmo gateway pode ser configurado para redirecionar automaticamente qualquer tentativa de acesso pela porta 80 (HTTP) para a porta 443 (HTTPS), garantindo que toda a comunicação aconteça de forma segura.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/images/http/arquitetura-http-https.png" alt="arquitetura http https">
</div>
<div class="title">Figura 2. Arquitetura de uma comunicação Cliente-Servidor que tenta primeiro acessar a porta 80 mas é redirecionado para 443.</div>
</div>
<div class="paragraph">
<p>A imagem acima ilustra exatamente como nossa arquitetura pode ser implementada usando apenas uma máquina e o Docker, unindo todos os componentes que acabamos de descrever.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_porque-lets-encrypt">Porque Let&#8217;s Encrypt?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Talvez você esteja se perguntando: por que precisamos de algo além do nosso servidor HTTP para usar HTTPS?</p>
</div>
<div class="paragraph">
<p>A resposta está no <strong>TLS</strong> — a camada de segurança que torna o HTTP seguro. Vamos entender como essa comunicação funciona e como ela protege seus dados.</p>
</div>
<div class="paragraph">
<p>O TLS protege a comunicação entre cliente e servidor com dois objetivos principais:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Autenticar o servidor, garantindo que você está se conectando ao destino verdadeiro — por exemplo, ao acessar blog.vepo.dev, ter certeza de que é realmente o meu blog, e não um site impostor.</p>
</li>
<li>
<p>Criptografar os dados trocados, assegurando que apenas você e o servidor possam ler o conteúdo da comunicação.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Para isso, o TLS usa <strong>criptografia assimétrica</strong> durante a fase inicial da conexão, permitindo que cliente e servidor estabeleçam uma chave secreta de forma segura — mesmo em um canal potencialmente inseguro como a internet.</p>
</div>
<div class="paragraph">
<p>A criptografia assimétrica usa um par de chaves: a <strong>chave privada</strong> (que é secreta) e a <strong>chave pública</strong> (que pode ser distribuída).
Uma mensagem criptografada com a chave privada só pode ser descriptografada usando a chave pública correspondente. Como apenas o dono da chave privada poderia ter criado essa mensagem, ela funciona como uma assinatura digital, provando a identidade de quem a enviou.</p>
</div>
<div class="paragraph">
<p>Na prática, quando seu navegador se conecta a um servidor HTTPS, ele verifica o certificado digital apresentado — que contém a chave pública do site e é assinado por uma autoridade confiável. Isso permite confirmar que você está realmente se comunicando com o domínio correto, e não com um impostor.</p>
</div>
<div class="paragraph">
<p>No entanto, para serviços simples, sem muito riscos, alguns optam por usar certificados autoassinados. Eles ainda criptografam o tráfego, impedindo que ferramentas como o <a href="https://www.wireshark.org">Wireshark</a> leiam os dados da comunicação, mas não fornecem autenticação confiável para o público geral, já que não são validados por uma autoridade externa.</p>
</div>
<div class="paragraph">
<p>É aí que entra o <strong>Let&#8217;s Encrypt</strong>!</p>
</div>
<div class="paragraph">
<p>Esse serviço automatiza a criação e a validação de certificados TLS. Ele gera o par de chaves pública e privada para você e, para confirmar que você realmente controla o domínio, realiza uma verificação simples — normalmente via DNS ou por meio de um arquivo temporário no seu servidor.</p>
</div>
<div class="paragraph">
<p>Uma vez aprovado, o Let&#8217;s Encrypt assina seu certificado digital, permitindo que qualquer navegador reconheça seu site como seguro — tudo de forma gratuita e automatizada.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1-configurando-o-ambiente">1. Configurando o ambiente</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Antes de começar, vamos preparar o ambiente:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Uma máquina com IP fixo
Você pode provisioná-la em qualquer provedor de nuvem (Magalu Cloud, AWS, DigitalOcean, Google Cloud, etc.) ou usar um servidor próprio.</p>
</li>
<li>
<p>Linux com Docker instalado
É o único requisito de software — garantindo que possamos rodar os contêineres de forma isolada e reproduzível.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2-criando-o-serviço-nginx">2. Criando o serviço NGINX</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Com isso pronto, criaremos um arquivo chamado <code>docker-compose.yml</code>. Ele define toda a configuração dos nossos serviços em código, tornando a implantação consistente e fácil de gerenciar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="yaml"><span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.29-alpine</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">443:443"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data/nginx:/etc/nginx/conf.d</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
<span class="na">networks</span><span class="pi">:</span>
  <span class="na">app-network</span><span class="pi">:</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Com o <code>docker-compose.yml</code> acima configurado, o NGINX já estará escutando nas portas 80 (HTTP) e 443 (HTTPS) da sua máquina. Isso significa que você pode apontar seu domínio no DNS para o IP fixo do servidor.</p>
</div>
<div class="paragraph">
<p>Agora, precisamos definir o conteúdo do arquivo <code>./data/nginx/app.conf</code>. É nele que configuramos o comportamento do servidor — como redirecionamentos, regras de proxy e a associação do certificado SSL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nginx"><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">example.org</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$request_uri</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">example.org</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://example.org</span><span class="p">;</span> <span class="c1">#for demo purposes</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Neste arquivo, configuramos dois servidores virtuais no NGINX:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Um servidor HTTP comum, que escuta na porta 80.</p>
</li>
<li>
<p>Um servidor HTTPS, que escuta na porta 443 e usa SSL/TLS.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>No entanto, o servidor HTTPS ainda não funcionará, pois falta configurar corretamente os certificados SSL — etapa que faremos em seguida com a ajuda do Let&#8217;s Encrypt.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3-configurando-o-certbot-lets-encrypt">3. Configurando o CertBot Let&#8217;s Encrypt</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O <strong>Let&#8217;s Encrypt</strong> valida o domínio por meio de um desafio HTTP: ele tenta acessar uma URL específica no seu domínio e espera uma resposta conhecida. Se o servidor responder corretamente, fica provado que você controla o domínio — um mecanismo parecido com o usado pelo Google Search Console para verificar a propriedade de um site.</p>
</div>
<div class="paragraph">
<p>Para gerar e responder a esse desafio, usamos o Certbot. Por isso, precisamos configurar o contêiner do NGINX para servir os arquivos temporários que o Certbot cria durante o processo de validação.</p>
</div>
<div class="paragraph">
<p>Primeiro, vamos ajustar o ambiente para incluir o Certbot. Para isso, precisamos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Declarar o serviço do Certbot no nosso <code>docker-compose.yml</code>.</p>
</li>
<li>
<p>Criar um volume compartilhado entre os containers do NGINX e do Certbot, permitindo que eles troquem os arquivos necessários para a validação do domínio.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>O arquivo <code>docker-compose.yml</code> atualizado é mostrado a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="yaml"><span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.29-alpine</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">443:443"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data/nginx:/etc/nginx/conf.d</span>
      <span class="pi">-</span> <span class="s">./data/certbot/conf:/etc/letsencrypt</span>    <span class="c1">## Configurações geradas pelo CertBot</span>
      <span class="pi">-</span> <span class="s">./data/certbot/www:/var/www/certbot</span>     <span class="c1">## Chaves geradas pelo CertBot</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
  <span class="na">certbot</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">certbot/certbot</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data/certbot/conf:/etc/letsencrypt</span>
      <span class="pi">-</span> <span class="s">./data/certbot/www:/var/www/certbot</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
<span class="na">networks</span><span class="pi">:</span>
  <span class="na">app-network</span><span class="pi">:</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, precisamos configurar o servidor NGINX para responder ao desafio HTTP do <strong>Let&#8217;s Encrypt</strong>.</p>
</div>
<div class="paragraph">
<p>Ele espera que uma URL específica — <code>/.well-known/acme-challenge/</code> — esteja acessível via porta 80 (HTTP). Portanto, vamos direcionar todas as requisições para esse caminho a um local onde o Certbot possa fornecer a resposta correta.</p>
</div>
<div class="paragraph">
<p>Após o desafio ser resolvido com sucesso, o Certbot gerará automaticamente os certificados e chaves necessários para o TLS.</p>
</div>
<div class="paragraph">
<p>Eles serão armazenados nos seguintes caminhos dentro do container:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Certificado público (fullchain):
<code>/etc/letsencrypt/live/example.org/fullchain.pem</code></p>
</li>
<li>
<p>Chave privada (privkey):
<code>/etc/letsencrypt/live/example.org/privkey.pem</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esses arquivos são essenciais para que o NGINX configure a conexão HTTPS corretamente. O CertBot também gera alguns arquivos de configuração que podem ser visto abaixo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nginx"><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">example.org</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$request_uri</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>  <span class="c1">## Define o desafio</span>
        <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">example.org</span><span class="p">;</span>

    <span class="kn">ssl_certificate</span> <span class="n">/etc/letsencrypt/live/example.org/fullchain.pem</span><span class="p">;</span>    <span class="c1">## Define a chave pública</span>
    <span class="kn">ssl_certificate_key</span> <span class="n">/etc/letsencrypt/live/example.org/privkey.pem</span><span class="p">;</span>  <span class="c1">## Define a chave privada</span>

    <span class="kn">include</span> <span class="n">/etc/letsencrypt/options-ssl-nginx.conf</span><span class="p">;</span>   <span class="c1">## Configurações geradas pelo CertBot</span>
    <span class="kn">ssl_dhparam</span> <span class="n">/etc/letsencrypt/ssl-dhparams.pem</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://example.org</span><span class="p">;</span> <span class="c1">#for demo purposes</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4-inicializando-o-certbot">4. Inicializando o CertBot</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Se você tentar subir o ambiente agora com <code>docker-compose up</code>, ele ainda não funcionará completamente. Isso porque os certificados SSL precisam ser solicitados e configurados pela primeira vez.</p>
</div>
<div class="paragraph">
<p>Para facilitar esse processo inicial, criamos um script de inicialização que automatiza todos os passos. Você só precisa executá-lo após atualizar o seu e-mail na linha onde está definido <code>email=""</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># Baixa o script de inicialização oficial do repositório nginx-certbot</span>
curl <span class="nt">-L</span> https://raw.githubusercontent.com/wmnnd/nginx-certbot/master/init-letsencrypt.sh <span class="o">&gt;</span> init-letsencrypt.sh

<span class="c"># Abre o script no editor vi para personalização</span>
<span class="c"># IMPORTANTE: Atualize o e-mail na linha que contém 'email=""'</span>
vi init-letsencrypt.sh

<span class="c"># Torna o script executável (adiciona permissão de execução)</span>
<span class="nb">chmod</span> +x init-letsencrypt.sh

<span class="c"># Executa o script com privilégios de superusuário</span>
<span class="c"># O script irá configurar automaticamente os certificados SSL/TLS</span>
<span class="nb">sudo</span> ./init-letsencrypt.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após executar o script, todos os arquivos de certificado e configuração necessários serão criados.</p>
</div>
<div class="paragraph">
<p>O próximo passo é reconfigurar o sistema para renovação automática: os certificados da Let&#8217;s Encrypt têm validade limitada, então precisamos garantir que sejam renovados automaticamente antes de expirar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="yaml"><span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.29-alpine</span>
    <span class="c1">## Força o NGINX atualizar a cada 6hs</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/bin/sh</span><span class="nv"> </span><span class="s">-c</span><span class="nv"> </span><span class="s">'while</span><span class="nv"> </span><span class="s">:;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">6h</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">wait</span><span class="nv"> </span><span class="s">$${!};</span><span class="nv"> </span><span class="s">nginx</span><span class="nv"> </span><span class="s">-s</span><span class="nv"> </span><span class="s">reload;</span><span class="nv"> </span><span class="s">done</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">nginx</span><span class="nv"> </span><span class="s">-g</span><span class="nv"> </span><span class="se">\"</span><span class="s">daemon</span><span class="nv"> </span><span class="s">off;</span><span class="se">\"</span><span class="s">'"</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">443:443"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data/nginx:/etc/nginx/conf.d</span>
      <span class="pi">-</span> <span class="s">./data/certbot/conf:/etc/letsencrypt</span>    <span class="c1">## Configurações geradas pelo CertBot</span>
      <span class="pi">-</span> <span class="s">./data/certbot/www:/var/www/certbot</span>     <span class="c1">## Chaves geradas pelo CertBot</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
  <span class="na">certbot</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">certbot/certbot</span>
    <span class="c1">## Força o CertBot atualizar a cada 6hs</span>
    <span class="na">entrypoint</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/bin/sh</span><span class="nv"> </span><span class="s">-c</span><span class="nv"> </span><span class="s">'trap</span><span class="nv"> </span><span class="s">exit</span><span class="nv"> </span><span class="s">TERM;</span><span class="nv"> </span><span class="s">while</span><span class="nv"> </span><span class="s">:;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">certbot</span><span class="nv"> </span><span class="s">renew;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">12h</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">wait</span><span class="nv"> </span><span class="s">$${!};</span><span class="nv"> </span><span class="s">done;'"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data/certbot/conf:/etc/letsencrypt</span>
      <span class="pi">-</span> <span class="s">./data/certbot/www:/var/www/certbot</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
<span class="na">networks</span><span class="pi">:</span>
  <span class="na">app-network</span><span class="pi">:</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5-configurando-o-banco-e-aplicação">5. Configurando o Banco e Aplicação</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para finalizar, vamos configurar o banco de dados e a aplicação. Como esses passos podem variar conforme o framework ou tecnologia utilizada, apresentaremos uma configuração genérica abaixo, que você poderá adaptar conforme sua necessidade.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="yaml"><span class="na">services</span><span class="pi">:</span>
  <span class="na">postgres</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres:18-alpine</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">app-postgres</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">POSTGRES_DB</span><span class="pi">:</span> <span class="s">app_db</span>
      <span class="na">POSTGRES_USER</span><span class="pi">:</span> <span class="s">app_user</span>
      <span class="na">POSTGRES_PASSWORD</span><span class="pi">:</span> <span class="s">${POSTGRES_PASSWORD:-AppPassword1234}</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/mnt/data/postgres:/var/lib/postgresql/18/docker</span>    <span class="c1">## Salva os dados em um Volume persistente</span>
      <span class="pi">-</span> <span class="s">./init.sql:/docker-entrypoint-initdb.d/init.sql</span>     <span class="c1">## Inicializa o banco</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5432:5432"</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
    <span class="na">healthcheck</span><span class="pi">:</span>
      <span class="na">test</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">CMD-SHELL"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">pg_isready</span><span class="nv"> </span><span class="s">-U</span><span class="nv"> </span><span class="s">app_user</span><span class="nv"> </span><span class="s">-d</span><span class="nv"> </span><span class="s">app_db"</span><span class="pi">]</span>
      <span class="na">interval</span><span class="pi">:</span> <span class="s">10s</span>
      <span class="na">timeout</span><span class="pi">:</span> <span class="s">5s</span>
      <span class="na">retries</span><span class="pi">:</span> <span class="m">5</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">&gt;</span>
      <span class="s">postgres</span>
      <span class="s">-c log_statement=all</span>
      <span class="s">-c log_destination=stderr</span>
  <span class="na">app</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">my-user/my-app:main</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">app</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="na">postgres</span><span class="pi">:</span>
        <span class="na">condition</span><span class="pi">:</span> <span class="s">service_healthy</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">QUARKUS_PROFILE</span><span class="pi">:</span> <span class="s">prod</span>
      <span class="na">QUARKUS_DATASOURCE_USERNAME</span><span class="pi">:</span> <span class="s">app_user</span>
      <span class="na">QUARKUS_DATASOURCE_PASSWORD</span><span class="pi">:</span> <span class="s">${POSTGRES_PASSWORD:-AppPassword1234}</span>
      <span class="na">QUARKUS_DATASOURCE_JDBC_URL</span><span class="pi">:</span> <span class="s">jdbc:postgresql://postgres:5432/app_db</span>
      <span class="na">QUARKUS_HIBERNATE_ORM_DATABASE_GENERATION</span><span class="pi">:</span> <span class="s">update</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8080:8080"</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
    <span class="na">healthcheck</span><span class="pi">:</span>
      <span class="na">test</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">CMD"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">curl"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">-f"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">http://localhost:8080/q/health"</span><span class="pi">]</span>
      <span class="na">interval</span><span class="pi">:</span> <span class="s">30s</span>
      <span class="na">timeout</span><span class="pi">:</span> <span class="s">10s</span>
      <span class="na">retries</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.29-alpine</span>
    <span class="c1">## Força o NGINX atualizar a cada 6hs</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/bin/sh</span><span class="nv"> </span><span class="s">-c</span><span class="nv"> </span><span class="s">'while</span><span class="nv"> </span><span class="s">:;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">6h</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">wait</span><span class="nv"> </span><span class="s">$${!};</span><span class="nv"> </span><span class="s">nginx</span><span class="nv"> </span><span class="s">-s</span><span class="nv"> </span><span class="s">reload;</span><span class="nv"> </span><span class="s">done</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">nginx</span><span class="nv"> </span><span class="s">-g</span><span class="nv"> </span><span class="se">\"</span><span class="s">daemon</span><span class="nv"> </span><span class="s">off;</span><span class="se">\"</span><span class="s">'"</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">443:443"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data/nginx:/etc/nginx/conf.d</span>
      <span class="pi">-</span> <span class="s">./data/certbot/conf:/etc/letsencrypt</span>    <span class="c1">## Configurações geradas pelo CertBot</span>
      <span class="pi">-</span> <span class="s">./data/certbot/www:/var/www/certbot</span>     <span class="c1">## Chaves geradas pelo CertBot</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
  <span class="na">certbot</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">certbot/certbot</span>
    <span class="c1">## Força o CertBot atualizar a cada 6hs</span>
    <span class="na">entrypoint</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/bin/sh</span><span class="nv"> </span><span class="s">-c</span><span class="nv"> </span><span class="s">'trap</span><span class="nv"> </span><span class="s">exit</span><span class="nv"> </span><span class="s">TERM;</span><span class="nv"> </span><span class="s">while</span><span class="nv"> </span><span class="s">:;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">certbot</span><span class="nv"> </span><span class="s">renew;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">12h</span><span class="nv"> </span><span class="s">&amp;</span><span class="nv"> </span><span class="s">wait</span><span class="nv"> </span><span class="s">$${!};</span><span class="nv"> </span><span class="s">done;'"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./data/certbot/conf:/etc/letsencrypt</span>
      <span class="pi">-</span> <span class="s">./data/certbot/www:/var/www/certbot</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app-network</span>
<span class="na">networks</span><span class="pi">:</span>
  <span class="na">app-network</span><span class="pi">:</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Por fim, precisamos informar ao NGINX onde nossa aplicação está disponível.
Ela está rodando na porta 8080 e, dentro da rede Docker, pode ser acessada pelo nome do serviço: "app".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="nginx"><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">example.org</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$request_uri</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kn">location</span> <span class="n">/.well-known/acme-challenge/</span> <span class="p">{</span>  <span class="c1">## Define o desafio</span>
        <span class="kn">root</span> <span class="n">/var/www/certbot</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">example.org</span><span class="p">;</span>

    <span class="kn">ssl_certificate</span> <span class="n">/etc/letsencrypt/live/example.org/fullchain.pem</span><span class="p">;</span>    <span class="c1">## Define a chave pública</span>
    <span class="kn">ssl_certificate_key</span> <span class="n">/etc/letsencrypt/live/example.org/privkey.pem</span><span class="p">;</span>  <span class="c1">## Define a chave privada</span>

    <span class="kn">include</span> <span class="n">/etc/letsencrypt/options-ssl-nginx.conf</span><span class="p">;</span>   <span class="c1">## Configurações geradas pelo CertBot</span>
    <span class="kn">ssl_dhparam</span> <span class="n">/etc/letsencrypt/ssl-dhparams.pem</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://app:8080</span><span class="p">;</span>    <span class="c1">## Aqui finalmente acessamos a aplicação</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusão">Conclusão</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Com essa configuração, sua aplicação — independentemente do framework utilizado — agora está acessível via HTTPS, com certificados válidos e renovação automática gerenciada pela Let&#8217;s Encrypt.</p>
</div>
<div class="paragraph">
<p>O NGINX atua como um gateway seguro, descriptografando o tráfego externo e redirecionando-o para sua app interna, enquanto o Docker mantém os serviços isolados e fáceis de atualizar.</p>
</div>
<div class="paragraph">
<p>Se tiver dúvidas ou sugestões, entra em contato comigo pelas redes sociais!</p>
</div>
</div>
</div>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="HTTPS" /><category term="HTTP" /><category term="Docker" /><category term="NGINX" /><category term="Let's Encrypt" /><category term="DevOps" /><summary type="html"><![CDATA[Nesse post vamos configurar HTTPS com certificados Let's Encrypt para qualquer aplicação web, usando NGINX como proxy reverso e Docker para um ambiente isolado e reproduzível.]]></summary></entry><entry><title type="html">Como avaliar uma API</title><link href="https://blog.vepo.dev/posts/como-avaliar-uma-api" rel="alternate" type="text/html" title="Como avaliar uma API" /><published>2022-01-16T00:00:00+00:00</published><updated>2022-01-16T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/22-14-00-como-avaliar-uma-api</id><content type="html" xml:base="https://blog.vepo.dev/posts/como-avaliar-uma-api"><![CDATA[<blockquote>
  <p>Esse post era para ter sido um capítulo do meu livro <a href="https://www.casadocodigo.com.br/products/livro-roadmap-backend">“<em>Roadmap back-end: Conhecendo o protocolo HTTP e arquiteturas REST</em>”</a> mas acabou sendo descartado na edição final. Por isso decidi publica ele no blog sem revisão, ou seja, pode existir erros de ortografia.</p>
</blockquote>

<p>Nos capítulos anteriores vimos as especificações do que é o protocolo HTTP e do que são APIs REST. Agora vamos caminhar tentando trazer mais elementos a nossas APIs. Para tentar responder a pergunta <em>como podemos avaliar uma API</em> podemos levantar algumas possíbilidades, desde a identificação de padrões e antipadroes, análise da complexidade, até por fim chegarmos a maturidade. Então nosso primeiro desafio será responder à seguinte pergunta: <em>existe alguma definição de padrões de projetos para APIs REST?</em></p>

<p>Antes de responder a essa pergunta precisamos definir o que é um padrão de projeto, o que é um antipadrão e como eles podem nos ajudar.</p>

<h2 id="padrões-e-antipadrões-de-projetos">Padrões e antipadrões de projetos</h2>

<p>A primeira pergunta que vamos responder é: <em>de onde vem o conceito de padrões de projeto</em>?</p>

<p>Padrões não surgiram na computação, é um conceito importado da arquitetutra. Quando se começa a pensar em uma casa, é preciso fazer inúmeras escolhas sobre pequenas coisas para resolver problemas triviais. Essas escolhas já envolvem alguns padrões que são universais como “porta”, “chão”, “mesa” e outros móveis. Para catalogar outros padrões, Christopher Alexander escreveu o livro <em>House generated by patterns</em> em 1969 em que ele descreve várias estruturas arquitetônicas e urbanísticas usando uma estrutura descritiva bem simples mostrando o contexto, a solução e uma análise dos problemas que a solução pode trazer. Esse livro deu origem a outros projetos, incluindo o livro <em>A Pattern Language: Towns, Buildings, Construction</em> de 1977, em que Alexander cria uma linguagem usando padrões e o conceito de Linguagem de Padrões. Descrição de projetos são simplificadas usando uma linguagem de padrões, pois ao invés de descrever detalhadamente o projeto é possível referenciar os padrões já descritos, cada padrão vai apresentar a melhor solução até o momento para um determinado problema.</p>

<p><img src="/assets/images/http/christopher-alexanderc.png" alt="Padrão Gradiente de Intimidade descrito no livro &quot;House generated by patterns&quot;" /></p>

<p>Em 1987, Kent Beck e Ward Cunningham escreveram o artigo <a href="http://c2.com/doc/oopsla87.html"><em>Using Pattern Languages for Object-Oriented Programs</em></a> aplicando o conceito de Linguagem de Padrões para interfaces gráficas de programas Smalltalk. No artigo apenas um padrão é descrito textualmente, o “Collect Low-level Protocol”, mas os autores relatam que estavam descrevendo uma linguagem com mais de 150 padrões.</p>

<p>Em 1994, Doug Lea publicou um artigo na revista Software Engineering Notes chamado <a href="https://dl.acm.org/doi/pdf/10.1145/181610.181617"><em>Christopher Alexander: an introduction for object-oriented designers</em></a>, onde havia a adaptação dos modelos de padrões urbanisticos de Christopher Alexander para o mundo do software. Nesse artigo vemos pela primeira vez a proposição de um formato para descrição de padrões. Um padrão deveria ter um nome, um exemplo e uma descrição do modelo onde deveria ser usado. Na verdade, no artigo estão presentes outras propriedades que em muitos casos não são facilmente aplicadas, como encapsulamento, generatividade, equilibrio, abstração, abertura e composibilidade.</p>

<p>Com o artigo de Doug Lea, ainda em 1994, Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides se juntam para escrever o livro mais conhecido sobre padrões <em>Padrões de Projetos: Soluções Reutilizáveis de Software Orientados a Objetos</em>. Nesse livro podemos encontrar a definição de vários padrões encontrados em projetos de software orientado a objetos. Por ter sido escrito por quatro autores, é popularmente conhecido como <em>Gang of Four</em> (gangue de quatro em tradução livre), ou pela sigla GoF. Os padrões do GoF são apresentados seguindo um modelo mais simples do que o proposto por Lea, cada padrão tem intenção, motivação, aplicabilidade, estrutura, participantes, colaborações, consequências, implementação, exemplo de código, usos conhecidos e padrões relacionados. Os padrões por sua vez são divididos entre padrões de criação, estruturais e comportamentais.</p>

<p><em>— E como esses padrões surgem?</em></p>

<p>Ao contrário do que se imagina, os padrões não são propostos, eles são identificados. Padrões já existem em projetos como soluções para problemas recorrentes, o que ocorre é que eles são identificados, especificados e analisados. Existem até conferências para apresentações de padrões, como é o caso da <em>Pattern Language of Programs</em>, em que padrões são lidos e discutidos em grupos.</p>

<p><em>— E para que servem esses tais padrões? Nunca precisei de um!</em></p>

<p>Conhecer padrões serve para aumentar o nosso vocabulário como desenvolvedores. Padrões, quando descritos, já vêm acompanhados de uma prévia discussão, mas depois que são propostos eles estão sujeitos a crítica. Alguns padrões recebem tanta crítica que são catalogados como antipadrões. Mas padrões e antipadrões não significam que são de uso imperativo ou não. Eles apenas servem para avaliarmos se uma solução é boa ou não. Um padrão tem sempre um contexto, um problema e uma solução, mas também possui as análises de vantagens e desvantagens que sua aplicação traz.</p>

<p>Quando tempos um bom repertório de padrões, começamos a responder mais rapidamente ao desafio de escrever e revisar código. Podemos identificar estruturas para podermos resolver os problemas de código do dia a dia. E também podemos identificar vantangens e desvantagens de estruturas propostas.</p>

<h2 id="quem-anda-escrevendo-sobre-padrões-rest">Quem anda escrevendo sobre padrões REST</h2>

<p>Antes de escrever sobre padrões REST, precisamos fazer uma busca para identificar e reconhecer quem já escreve sobre o assunto, para identificar algumas publicações interessantes. Nossa discussão vai se limitar aos três artigos a seguir, que podem trazer padrões e ideias interessantes sobre como avaliar uma API REST, embora todos em inglês.</p>

<ul>
  <li>2014 - <a href="https://link.springer.com/chapter/10.1007/978-3-662-45391-9_16">Detection of REST Patterns and Antipatterns: A Heuristics-Based Approach</a>: Francis Palma, Johann Dubois, Naouel Moha, and Yann-Gaël Guéhéneuc</li>
  <li>2017 - <a href="https://ieeexplore.ieee.org/abstract/document/7930199">A Framework for the Structural Analysis of REST APIs</a>: Florian Haupt, Frank Leymann, Anton Scherer, Karolina Vukojevic-Haupt</li>
  <li>2020 - <a href="https://link.springer.com/chapter/10.1007/978-3-030-59155-7_32">Defining Design Patterns for IoT APIs</a>: Rasmus Svensson, Adell Tatrous, Francis Palma</li>
</ul>

<p>O primeiro artigo propõe uma heurística para determinação de padrões e antipadrões em APIs REST. Como ele foi escrito antes da proposição do <a href="https://spec.openapis.org/oas/latest.html">OpenAPI</a>, em 2015, sua análise não se baseia em documentações, mas em implementações. Sua análise propõe alguns padrões e antipadrões que mostraremos a seguir, assim como um algoritmo para identificar o padrão dentro do projeto de código.</p>

<p>No segundo artigo Haupt propõe uma análise estrutural baseada na documentação da API usando OpenAPI. As documentações de APIs abertas foram analisadas por uma ferramenta para se extrair o modelo da API. Segundo Haupt, cada API constiria de uma série de recursos possuem métodos e relacionamentos. Ele por sua vez se baseia no <em>Atomic Resource Model</em> e no <em>URI Model</em>. O primeiro descreve uma API através de seus elementos básicos como recursos, verbos e representações. Já o segundo modelo estende o primeiro, dando a oportunidade ao cliente da API de navegar nos recursos baseados em hyperlinks providos pela propria API. Com essa análise é possivel conhecer a complexidade da API, descrevendo quantos recursos ela possui, quantos desses são <em>ReadOnly</em> e quais as relações entre eles através de links.</p>

<p><img src="/assets/images/http/rest-haupt.png" alt="Metamodelo de uma API" /></p>

<p>E por fim, no terceiro artigo, Svensson faz uma análise de algumas APIs de mercado para IoT e propões 8 padrões de projetos, baseado no modelo no GoF. APIs de IoT são altamente voltada a recursos, pois cada dispositivo é um recurso. Segundo Svensson, os padrões presentes na literatura são mais voltados para garantir a qualidade RESTful das APIs e não para o desenho dos endpoints, por isso todos esses padrões se concentram na URI.</p>

<h2 id="revisando-a-anatomia-de-uma-requisição">Revisando a anatomia de uma requisição</h2>

<p>Para detalhar as padrões de API REST, precisamos revisar como podemos subdividir uma URI. Segundo a IETF <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>, temos os seguintes componentes: <code class="language-plaintext highlighter-rouge">Scheme://Authority/Path?Query#Fragment</code>. Cada componente de uma URI tem sua especificidade e significância que devem ser levadas em conta na construção de uma API, nós vimos no capítulo 3 como cada elemento é descrito, agora vamos expandir essas definições.</p>

<p>O caminho (Path) pode ser subdividdo em base (Base) e principal (Main) <code class="language-plaintext highlighter-rouge">Scheme://Authority/Base/Main?Query</code>. A base é identificada quando existe caminhos comuns em uma API, ela pode ter uma função primordial quando precisamos definir qual API e/ou qual versão da API deve ser acesada. Ao se identificar a base, o principal é o ponto crucial da requisição.</p>

<p>Ainda no caminho, cada token pode ser considerado um nó, assim podemos assumir funções para cada nó de uma requisição. Na tabela a seguir temos as várias funções que um nó pode assumir.</p>

<table>
  <thead>
    <tr>
      <th>Nome</th>
      <th>Descrição</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Nó de acesso</td>
      <td>Um nó que é usado apenas para direcionar as seguintes partes do URI para uma determinada seção da API, ou seja, não é um recurso ou dados que podem ser buscados.</td>
    </tr>
    <tr>
      <td>Nó pai</td>
      <td>Um nó que geralmente representa uma categoria, um recurso que inclui recursos ou um objeto. Na API e no URI, esse nó existe em uma hierarquia. Aqui, tendemos a mencionar apenas o fim da hierarquia.</td>
    </tr>
    <tr>
      <td>Nó indicativo</td>
      <td>Um nó que representa uma ordem, consulta ou ação a ser realizada em um determinado recurso para aplicar esta ação ou conhecer uma informação específica sobre esse recurso, por exemplo, filtrar os resultados de uma solicitação feita em um determinado recurso. Podemos pensar nisso como um ponto final que dispara uma função. Geralmente é uma palavra convencional, como info, <code class="language-plaintext highlighter-rouge">create</code> (<code class="language-plaintext highlighter-rouge">criar</code>), <code class="language-plaintext highlighter-rouge">first</code> (<code class="language-plaintext highlighter-rouge">primeiro</code>), <code class="language-plaintext highlighter-rouge">last</code> (<code class="language-plaintext highlighter-rouge">ultimo</code>), <code class="language-plaintext highlighter-rouge">status</code> etc. Nós indicativos podem ser divididos em três categorias: nós de ação, nós de filtro e nós informacionais</td>
    </tr>
    <tr>
      <td>Nós de ação</td>
      <td>Um nó usado para acionar uma função específica ou aplicar funcionalidades clássicas de CRUD em um recurso, usando qualquer método de solicitação HTTP. Na maioria dos casos, esses nós assumem a forma de um pedido para realizar uma ação, por exemplo, <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">clone</code>, <code class="language-plaintext highlighter-rouge">upload</code> ou <code class="language-plaintext highlighter-rouge">consume</code></td>
    </tr>
    <tr>
      <td>Nós de filtro</td>
      <td>Um nó usado para direcionar um grupo específico ou estado dos recursos solicitados.</td>
    </tr>
    <tr>
      <td>Nós informacionais</td>
      <td>Um nó usado para obter informações sobre metadados para um ou vários recursos. Esses metadados não podem ser modificados diretamente nem acessíveis por meio do recurso</td>
    </tr>
  </tbody>
</table>

<p>A classificação da autoridade também pode ser estendida, por exemplo, Svensson a classifica como dinâmica e estática.</p>

<ul>
  <li><strong>Dinâmica</strong>: o mesmo valor é usado para todos os recursos controlado pela API.</li>
  <li><strong>Estática</strong>: valores são gerados para controlar grupo de recursos.</li>
</ul>

<blockquote>
  <p><strong>CRUD</strong></p>

  <p>Todo recurso aceita um conjunto de operações. Quando usamos o termo CRUD estamos nos referindo ao conjunto mais comum de operações <strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate e <strong>D</strong>elete (criar, ler, apagar e remover). Essa sigla é muito associada a interfaces gráficas, mas ela também pode ser aplicada a uma API. Apesar de existirem essas quatro operações básicas, um recurso pode ter outras operações como habilitar/desabilitar, associar/desassociar etc. Operações dependem da lógica de negócios, por isso cada aplicação deve definir o conjunto de operações que seu recurso aceita.</p>
</blockquote>

<h2 id="encontrando-os-padrões">Encontrando os padrões</h2>

<p>Na literatura citada anteriormente, vamos listar alguns padrões. Eles serão detalhados usando um modelo mais simples que o proposto pelo GoF, cada padrão o seu nome, propositor, forças, vantagens e desvantagens. Cada padrão terá uma breve descrição com marcações em negrito, elas se referem a termos chaves da descrição. Estes são os padrões que vamos apresentar:</p>

<ul>
  <li><strong>Vinculação de entidades</strong></li>
  <li><strong>Cache de resposta</strong></li>
  <li><strong>Negociação de Conteúdo</strong></li>
  <li><strong>Redirecionamento de end-point</strong></li>
  <li><strong>End-point da Entidade</strong></li>
  <li><strong>URI direcionado antecipadamente</strong></li>
  <li><strong>Requisição Expressa</strong></li>
  <li><strong>‘me’ Recurso Acessível</strong></li>
  <li><strong>Acessibilidade dos Metadados</strong></li>
  <li><strong>Filtragem Proativa</strong></li>
  <li><strong>API versionada</strong></li>
  <li><strong>Recursos versionados</strong></li>
</ul>

<p>Cada padrão será descrito usando o exemplo da API para bibliotecas que criamos no capítulo passado.</p>

<h3 id="vinculação-de-entidades">Vinculação de entidades</h3>

<p>Esse padrão permite a <strong>comunicação em tempo de execução</strong> através de <strong>links</strong> providos pelo servidor no corpo da resposta ou via <strong>Location:</strong>, no cabeçalho da resposta. Usando hyperlinks, a dependência entre cliente e servidor é reduzida permitindo ao cliente <strong>automaticamente encontrar</strong> as <strong>entidades relacionadas</strong> em <strong>tempo de execução</strong>.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>A URI de recursos recém-criados devem ser conhecida pelo cliente</li>
  <li>Recursos precisam ser relacionados entre si</li>
  <li>A API deve prover relações, não apenas dados</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Detection of REST Patterns and Antipatterns: A Heuristics-Based Approach” por Francis Palma, Johann Dubois, Naouel Moha, e Yann-Gaël Guéhéneuc.</p>

<p><strong>Problema</strong></p>

<p>As ações a que uma entidade pode ser submetida devem ser independentes do cliente. A API deve fornecer informações suficientes para que o cliente consiga compreender as ações que pode realizar com uma entidade.</p>

<p>As entidades relacionadas a uma determinada entidade também devem ser independentes do cliente. Se as relações entre entidades não forem fornecidas pela API, cada cliente deve implementar as relações, acarretando em código duplicado, acoplamento de versões e propagação de bugs.</p>

<p><strong>Solução</strong></p>

<p>Ao acessar ou criar uma entidade, o servidor pode enviar o URL da mesma, de todas entidades relacionadas e possíveis ações dentro do corpo da resposta ou através dos cabeçalhos <code class="language-plaintext highlighter-rouge">Location</code> ou <code class="language-plaintext highlighter-rouge">Link</code>. A <a href="https://tools.ietf.org/html/rfc5988">RFC 5988 - Web Linking</a> trata do caso de se usar o cabeçalho <code class="language-plaintext highlighter-rouge">Link</code>, no caso há um proposição de formato que pode ser usado também no cabeçalho <code class="language-plaintext highlighter-rouge">Location</code>.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST /tiquete HTTP 1.1
Host: tiquetes.com.br
Content-Type: application/json

{
    "titulo": "Erro ao criar Tíquete",
    "descricao": "A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada.",
    "projeto": "PRJ-001",
    "epico": "CRIAR-TIQUETE",
    "tags": ["Java", "REST", "CRUD"]
}

201 Created
Location: tiquetes.com.br/tiquete/6942
Link: &lt;Autor&gt;;rel="/tiquete/autor/215";title="Victor Osório",&lt;Projeto&gt;;rel="/projeto/proj-001";title="Tíquetes.COM.BR",&lt;TAG&gt;;rel="/tag/java";title="Java",&lt;TAG&gt;;rel="/tag/rest";title="REST",&lt;TAG&gt;;rel=/tag/crud;title="CRUD";&lt;EPICO&gt;;rel=/epico/criar-tiquete;title="Criar Tíquete"
</span></code></pre></div></div>

<p>Uma outra possível apresentação para esse padrão é inseri-lo dentro do corpo da mensagem. Esse padrão é proposto pelo <em>HATEOAS</em> (que significa <em>Hypermedia as the Engine of Application State</em>) e pode ser aplicado inserindo o campo link ao objeto retornado.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">6942</span><span class="p">,</span><span class="w">
    </span><span class="nl">"titulo"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Erro ao criar Tíquete"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"descricao"</span><span class="p">:</span><span class="w"> </span><span class="s2">"A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"projeto"</span><span class="p">:</span><span class="w"> </span><span class="s2">"PRJ-001"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"epico"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CRIAR-TIQUETE"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"tags"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"Java"</span><span class="p">,</span><span class="w"> </span><span class="s2">"REST"</span><span class="p">,</span><span class="w"> </span><span class="s2">"CRUD"</span><span class="p">],</span><span class="w">
    </span><span class="nl">"links"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"href"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/tiquete/6942"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"rel"</span><span class="p">:</span><span class="w"> </span><span class="s2">"self"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"GET"</span><span class="w">
        </span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"href"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/tiquete/6942/responsavel"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"rel"</span><span class="p">:</span><span class="w"> </span><span class="s2">"responsavel_associar"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"POST"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="cache-de-resposta">Cache de resposta</h3>

<p>O cacheamento da resposta é uma boa prática para <strong>evitar enviar requisições duplicadas</strong> e <strong>respostas</strong> através do cacheamento de todas as mensagens no <strong>local</strong> da máquina do cliente. São usados os cabeçalhos <strong>Cache-Control</strong> e <strong>ETag</strong>, assim como o <strong>código HTTP 304</strong>.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>O servidor precisa de meios para evitar processamento desnecessário</li>
  <li>O cliente pode armazenar informação localmente</li>
  <li>O cliente deve prover uma ferramenta para validar se o dado que possui é o mais recente</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Detection of REST Patterns and Antipatterns: A Heuristics-Based Approach” por Francis Palma, Johann Dubois, Naouel Moha, e Yann-Gaël Guéhéneuc.</p>

<p><strong>Problema</strong></p>

<p>APIs com elevada demanda de requisições devem encontrar meios de reduzir a quantidade de processamento e memória utilizada. Dessa forma recursos podem ser acessados por vários clientes ao mesmo tempo, sem que seja necessário o processamento completo da requisição no servidor, mas cada cliente deve ter sempre a versão mais atualizada do recurso desejado.</p>

<p><strong>Solução</strong></p>

<p>Essa solução já foi demonstrada no capítulo <strong>Discutindo o protocolo</strong>, onde vimos que o correto uso do cache pode evitar tanto uma sobrecarga do servidor quanto erros de concorrência ao se alterar um recurso. Em ambos os casos se usa o cabeçalho <code class="language-plaintext highlighter-rouge">ETag</code>.</p>

<p>Para evitar a sobrecarga do servidor, toda entidade passível de cache deve vir com um valor de <code class="language-plaintext highlighter-rouge">ETag</code>. Este valor pode ser um número sequencial ou o hash do conteúdo da entidade. Assim quando for necessário acessar o conteúdo novamente o servidor saberá que o cliente já tem o conteúdo dessa requisição e se este está atualizado ou não.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /tiquete/6942 HTTP 1.1
ETag: "8199bab3962576d495a6d2a4ac48abfa"


304 Not Modified
</span></code></pre></div></div>

<p>Para evitar problemas de concorrência, uma operação pode ser feita usando o cabeçalho <code class="language-plaintext highlighter-rouge">If-Match</code>, assim a operação só poderá ser realizada se não houve nenhuma alteração no estado da entidade.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PATCH /tiquete/6942 HTTP 1.1
If-Match: "8199bab3962576d495a6d2a4ac48abfa"
Content-Type: application/json

{
    "projeto": "PRJ-002"
}

</span><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">412</span> <span class="ne">Precondition Failed</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Sat, 27 Feb 2021 16:12:02 GMT</span>
</code></pre></div></div>

<h3 id="negociação-de-conteúdo">Negociação de Conteúdo</h3>

<p>Esse padrão suporta <strong>representações alternativas para recursos</strong> (por exemplo, em <strong>json</strong>, <strong>xml</strong>, <strong>pdf</strong> etc.) assim. o serviço consumidor se torna mais flexível com alta reutilização. Servidores podem prover recursos em <strong>qualquer formato padrão</strong> requerido pelos clientes. Esse padrão é aplicado através dp <strong>HTTP Media Types</strong> e permite aos usuários da API terem mais liberdade de implementação.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Uma mesma API pode prover recursos para vários clientes</li>
  <li>Uma mesma API pode prover recursos através de vários formatos</li>
  <li>O formato pode ser usado para exportar recursos em formatos específicos como planilhas e documentos PDF</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Detection of REST Patterns and Antipatterns: A Heuristics-Based Approach” por Francis Palma, Johann Dubois, Naouel Moha, e Yann-Gaël Guéhéneuc.</p>

<p><strong>Problema</strong></p>

<p>Alguns clientes têm limitações de biblioteca de serialização. Em certos clientes há somente a opção de <code class="language-plaintext highlighter-rouge">JSON</code> e em outros somente <code class="language-plaintext highlighter-rouge">XML</code>, em outro caso, o cliente vai requerer a exportação de certas entidades em vários formatos <code class="language-plaintext highlighter-rouge">PDF</code>, <code class="language-plaintext highlighter-rouge">XLS</code> ou qualquer outro formado.</p>

<p><strong>Solução</strong></p>

<p>Essa solução já foi demonstrada no capítulo <strong>Discutindo o protocolo</strong>. Ao cliente é possível escolher qual o formato de mídia que este deseja receber, basta usar o cabeçalho <code class="language-plaintext highlighter-rouge">Content</code>. Essa solução pode ser feita tanto para troca de mensagens como para o download de recursos. No primeiro caso se aplica quando o cliente tem alguma limitação de serialização e o segundo é quando o cliente deseja um formato especifico. No caso a seguir vamos mostrar como fazer o download em formato EPUB, o formato poderia ser escolhido pelo cliente.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /tiquete/6942 HTTP 1.1
Content: application/pdf

200 OK
[Conteúdo em format PDF]
</span></code></pre></div></div>

<h3 id="redirecionamento-de-end-point">Redirecionamento de end-point</h3>

<p>A funcionalidade de redirecionamento através da web é suportado por este padrão, que também desempenha um papel importante como meio de <strong>composição de serviços</strong>. Para redirecionar clientes, o servidor envia uma nova localidade para acompanhar um dos códigos HTTP entre 301, 302, 307 ou 308. O principal benefício desse padrão é que um serviço alternativo continua ativo mesmo que o endpoint requerido não responda.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Uma API pode mudar sua topologia e o cliente deve identificar essa mudança</li>
  <li>Identificadores de recursos podem ser alterados e a API deve informar essa mudança</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Detection of REST Patterns and Antipatterns: A Heuristics-Based Approach” por Francis Palma, Johann Dubois, Naouel Moha, e Yann-Gaël Guéhéneuc.</p>

<p><strong>Problema</strong></p>

<p>Nem sempre identificadores são imutáveis, em alguns casos eles podem ser alterados. Entidades podem ser localizada a partir de campos alteráveis, ou seja, sempre que um identificador for alterado o identificador antigo deve redirecionar para o novo. Em outros casos a API pode mudar a sua topologia, criando novos formatos de URI, mas mesmo assim ele pode responder a requisições usando a topologia antiga.</p>

<p><strong>Solução</strong></p>

<p>A solução é usar o código de estato 301 associado ao cabeçalho <code class="language-plaintext highlighter-rouge">Location</code>, conforme definido no protocolo HTTP. Para exemplificar, vamos mostrar o caso mais comum, quando um recurso muda de identificador.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /epico/criar-tiquete HTTP 1.1

301 Moved Permanently
Location: /epico/crud-tiquete
</code></pre></div></div>

<h3 id="end-point-da-entidade">End-point da Entidade</h3>

<p>Serviços com um único <strong>endpoint</strong> são pouco granulares. Usualmente, um cliente requer ao menos <strong>dois identificadores</strong>: um <strong>global</strong> para o <strong>serviço</strong> em si e um <strong>local</strong> para o <strong>recurso ou entidade</strong> gerenciada pelo serviço. Aplicando esse padrão, isto é, usando <strong>multiplos endpoints</strong>, cada entidade (ou recurso) de um serviço incorporado pode ter seu <strong>identicador único</strong> e <strong>endereço global</strong>.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Cada recurso deve ter seu end-point específico</li>
  <li>Entidades devem ser encontradas diretamente</li>
  <li>Entidades devem ser cacheadas através do seu end-point</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Detection of REST Patterns and Antipatterns: A Heuristics-Based Approach” por Francis Palma, Johann Dubois, Naouel Moha, e Yann-Gaël Guéhéneuc.</p>

<p><strong>Problema</strong></p>

<p>Recursos que compartilham end-point tornam o cache impraticável, além de inserir complexidade desnecessária a uma API. Cada recurso deve ter seu end-point único, assim ele pode ser acessado diretamente.</p>

<p><strong>Solução</strong></p>

<p>Cada entidade deverá ter um end-point associado para retornar as informações pode identificador. Assim <code class="language-plaintext highlighter-rouge">/tiquete/:id:</code> vai retornar as informações do tíquete conforme seu identificador, a mesma regra deve valer para sprint (<code class="language-plaintext highlighter-rouge">/sprint/:id:</code>), épico (<code class="language-plaintext highlighter-rouge">/epico/:id:</code>) e assim por diante.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /tiquete/6942 HTTP 1.1

{
    "id": 6942,
    "titulo": "Erro ao criar Tíquete",
    "descricao": "A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada.",
    "projeto": "PRJ-001",
    "epico": "CRIAR-TIQUETE",
    "tags": ["Java", "REST", "CRUD"]
}
</span></code></pre></div></div>

<h3 id="uri-direcionado-antecipadamente">URI direcionado antecipadamente</h3>

<p>Para direcionar a requisição da URI para um <strong>grupo específico</strong> e único dentro da API. Pode ser um ID de organização, código de área ou nome de servidor. Normalmente é usado um <strong>nome variável no começo da Autoridade</strong>.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>APIs podem fazer o balanceamento de carga de requisições usando a autoridade</li>
  <li>APIs devem poder agrupar seus recursos através de identificadores lógicos</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Defining Design Patterns for IoT APIs” por Rasmus Svensson, Adell Tatrous e Francis Palma.</p>

<p><strong>Problema</strong></p>

<p>Algumas APIs requerem agrupamentos lógicos que vão impactar não somente a distribuição dos recursos, mas toda a lógica da API. Requisições direcionadas a esses agrupamentos lógicos vão acarretar em estatisticas separadas, assim como limitações de quotas ou controle de acesso. Existe uma entidade raiz onde todas as outras entidades que serão cadastradas pertencem a essa entidade raiz não podendo ser compartilhadas com as outras entidades raiz.</p>

<p><strong>Solução</strong></p>

<p>Para cada entidade raiz, deve ser criada uma nova autoridade. Vamos supor que podemos cadastrar um produto nova. Cada produto terá seu identificador que deve ser usado na URL para acessar a API referente a ele.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST /produto HTTP 1.1
Host: tiquetes.com.br
Content-Type: application/json

{
    "id": "biblioteca",
    "nome": "Gestão de emprestimo de livros",
    "descrição": "API para gestão de emprestimo de livros. Deverá ser usado por várias bibliotecas"
}

201 Created
Location: https://biblioteca.tiquetes.com.br
</span></code></pre></div></div>

<h3 id="requisição-expressa">Requisição Expressa</h3>

<p>Para executar as funcionalidades clássicas do CRUD ou executar uma <strong>função específica</strong> em um recurso, ao mesmo tempo em que declara claramente a finalidade do URI e não apenas se baseia no método usado através de um <strong>Nó de Ação</strong> na seção <em>Main</em>.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Operações em alguns recursos devem ser explícitas</li>
  <li>Os verbos do protocolo HTTP são limitados a operações de CRUD</li>
  <li>Alguns recursos possuem operações que são específicas do modelo de negócios da aplicação</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Defining Design Patterns for IoT APIs” por Rasmus Svensson, Adell Tatrous e Francis Palma.</p>

<p><strong>Problema</strong></p>

<p>A URI deve declarar expressamente qual operação está sendo realizada. Operações de remoção devem ser ter informações associadas a operação. Certas entidades são passíveis de vários tipos de ações: <code class="language-plaintext highlighter-rouge">checkout</code>, <code class="language-plaintext highlighter-rouge">reserva</code>, <code class="language-plaintext highlighter-rouge">compra</code>, <code class="language-plaintext highlighter-rouge">venda</code> etc.</p>

<p><strong>Solução</strong></p>

<p>Para expressar qual operação está sendo feita, cada operação deve ter um identificador e este deve ser usado como um nó de ação do final do end-point da entidade.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PUT /tiquete/6942/assumir HTTP 1.1

{
    "usuario": 732
}

200 OK
</span></code></pre></div></div>

<h3 id="me-recurso-acessível">‘me’ Recurso Acessível</h3>

<p>Para apontar para o usuário autenticado no momento ao solicitar recursos ou executar ações às quais este usuário tem acesso, use um nó <code class="language-plaintext highlighter-rouge">me</code> no início da seção <em>Main</em>.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>A API deve fornecer as informações do usuário autenticado</li>
  <li>Recursos especiais devem ser encontrados através de endpoints especificos</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Defining Design Patterns for IoT APIs” por Rasmus Svensson, Adell Tatrous e Francis Palma.</p>

<p><strong>Problema</strong></p>

<p>Certas regras de negócios podem requerer end-points personalizados. Esses end-points vão retornar recursos especificos e o end-point pode encapsular regras de negócios complexas como consultas.</p>

<p><strong>Solução</strong></p>

<p>O caso mais comum desse padrão é o end-point <code class="language-plaintext highlighter-rouge">/me</code> que retorna os dados do usuário autenticado. Para nosso sistema, podemos criar o end-point <code class="language-plaintext highlighter-rouge">/tiquete/meus</code> que retorna todos os tíquetes com que o usuário logado está relacionado. Esse end-point pode ainda ter um filtro <code class="language-plaintext highlighter-rouge">/tiquete/meus/ativos</code> que retorna apenas os tiquetes ativos da consulta anterior.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /me HTTP 1.1

{
    "id": 319,
    "nome": "Victor Osório",
    "usuario": "vepo"
}
</span></code></pre></div></div>

<h3 id="acessibilidade-dos-metadados">Acessibilidade dos Metadados</h3>

<p>Para ler informações, principalmente usando o método GET, sobre metadados para um único ou vários recursos, como: <code class="language-plaintext highlighter-rouge">count</code>, <code class="language-plaintext highlighter-rouge">state</code>, <code class="language-plaintext highlighter-rouge">status</code> ou outros dados que <strong>não podem ser modificados</strong> diretamente nem acessíveis por meio de um recurso, o URI pode ter um nó informativo significativo no final da seção <em>Main</em> como uma indicação para as informações solicitadas.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Recursos possuem metadados que podem apenas ser consultados</li>
  <li>Metadados dependem de recursos</li>
  <li>Metadados não fazem parte das informações do recurso</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Defining Design Patterns for IoT APIs” por Rasmus Svensson, Adell Tatrous e Francis Palma.</p>

<p><strong>Problema</strong></p>

<p>Metadados são entidades que são controladas pela API, o cliente pode apenas consultar os metadados. A maioria das necessidades de negócio não dependem de metadados, logo eles não devem ser retornados juntamente ao recurso.</p>

<p><strong>Solução</strong></p>

<p>Os metadados são expostos por um end-point adicionando um nó informacional ao end-point do recurso. Assim as estatísticas de um projeto podem ser lidos através de <code class="language-plaintext highlighter-rouge">/projeto/:id:/estatisticas</code>.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /projeto/proj-001/estatisticas HTTP 1.1

{
    "colaboradores": 12,
    "horasTrabalhadas": 612,
    "mediaTimeToMarketEmDias": 12
}
</span></code></pre></div></div>

<h3 id="filtragem-proativa">Filtragem Proativa</h3>

<p>Para direcionar um <strong>grupo específico</strong> ou <strong>estado do recurso</strong> solicitado sem depender de um parâmetro de consulta dedicado, use um nó de filtro na seção <em>Main</em>.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Consultas comuns devem ser facilitadas</li>
  <li>Consutlas comuns devem ter sua lógica implementada pela API</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Defining Design Patterns for IoT APIs” por Rasmus Svensson, Adell Tatrous e Francis Palma.</p>

<p><strong>Problema</strong></p>

<p>Todo sistema possui um conjunto de consultas que são executadas diversas vezes, mas cuja lógica é complicada. Para esses casos, devem existir filtros padrões na API, as regras de negócios devem ser encapsuladas pela API, sendo acessados diretamente.</p>

<p><strong>Solução</strong></p>

<p>Esses filtros podem ser expressos como nós informacionais adicionados a end-point de recursos. Por exemplo, para se requerer todos os tíquetes pendentes para o sprint que o usuário logado está participando <code class="language-plaintext highlighter-rouge">/sprint/atual/pendentes</code>, esse mesmo padrão pode ser usado para qualquer sprint <code class="language-plaintext highlighter-rouge">/sprint/:id:/pendentes</code>.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /sprint/atual/pendentes HTTP 1.1


[{
    "id": 6942,
    "titulo": "Erro ao criar Tíquete",
    "descricao": "A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada.",
    "projeto": "PRJ-001",
    "epico": "CRIAR-TIQUETE",
    "tags": ["Java", "REST", "CRUD"]
}, {
    "id": 6948,
    "titulo": "Associar Tíquete a Sprint",
    "descricao": "Criar endpoint para associar tíquete a um sprint especifico",
    "projeto": "PRJ-001",
    "epico": "SPRINT",
    "tags": ["Java", "REST"]
}, {
    "id": 6953,
    "titulo": "Tela de consulta de Tíquetes",
    "descricao": "Criar tela de consulta de tíquetes, deve ser possível consultar tiquete por todos os campos",
    "projeto": "PRJ-001",
    "epico": "FRONTEND",
    "tags": ["Javascript", "Frontend"]
}]
</span></code></pre></div></div>

<h3 id="api-versionada">API versionada</h3>

<p>A diferenciação de versão da API é feita na request. Esta pode ser feita com base em um nó no <em>Base</em>, que representa a versão. Essa diferenciação também pode ser feita por um parâmetro na Query.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Clientes legados ainda usam versões antigas da API</li>
  <li>A evolução da API gera a necessidade de uma refatoração dos recursos da API</li>
  <li>API complexa precisa ser reestruturada</li>
</ul>

<p><strong>Proposta</strong></p>

<p>Foi proposta em “Defining Design Patterns for IoT APIs” por Rasmus Svensson, Adell Tatrous e Francis Palma.</p>

<p><strong>Problema</strong></p>

<p>A API possui uma grande base de clientes legados que não vão se adaptar a uma refatoração, logo o time de desenvolvimento deve menter diversas versão da mesma API em produção.</p>

<p><strong>Solução</strong></p>

<p>Para se manter diversas versões ativas, existem várias abordagens possíveis. A abordagem mais simples é colocar a versão (ou data) como parâmetro da Query, essa opção é válida somente se a refatoração foi na lógica de negócios ou no corpo da requisição. Essa abordagem não vai funcionar para casos em que a topologia dos end-points foi modificada.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /tiquete/6942?versao=2 HTTP 1.1

{
    "id": 6942,
    "titulo": "Erro ao criar Tíquete",
    "descricao": "A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada.",
    "projeto": "PRJ-001",
    "epico": "CRIAR-TIQUETE",
    "tags": ["Java", "REST", "CRUD"],
    "subtasks": [{
        "id": 6982,
        "title": "Adicionar validação de tags no frontend"
    }, {
        "id": 6983,
        "title": "Adicionar validação de tags no backend"
    }]
}
</span></code></pre></div></div>

<p>A outra possibilidade é colocar a versão como um nó do caminho <em>Base</em>. Esse nó pode ser construído iniciando com o caractere <code class="language-plaintext highlighter-rouge">v</code> seguido do número da versão para se diferenciar de um identificador. Esse número pode ser um inteiro sequencial ou seguir o formato <a href="https://semver.org/lang/pt-BR/"><em>Semantic Versioning</em></a>.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /v2/tiquete/6942 HTTP 1.1

{
    "id": 6942,
    "titulo": "Erro ao criar Tíquete",
    "descricao": "A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada.",
    "projeto": "PRJ-001",
    "epico": "CRIAR-TIQUETE",
    "tags": ["Java", "REST", "CRUD"]
}
</span></code></pre></div></div>

<h3 id="recursos-versionados">Recursos versionados</h3>

<p>Nesse padrão, os recursos podem ter versões. Quando um recurso é alterado, as versões antigas dele podem ser acessadas.</p>

<p><strong>Forças</strong></p>

<ul>
  <li>Cada recurso deve fornecer a possibilidade de versionamento</li>
  <li>Dados não podem ser excluídos e alterações devem ser rastreadas</li>
</ul>

<p><strong>Problema</strong></p>

<p>Todas as informações de um recursos são importantes, nenhuma alteração deve apagar informações e versões antigas do mesmo recurso devem estar disponíveis através da API.</p>

<p><strong>Solução</strong></p>

<p>Para resolver esse problema, cada end-point de entidade pode aceitar alguns nós informativos. O primeiro deles listará todas as versões disponíveis, e o segundo deles acessará o conteúdo da versão. Assim <code class="language-plaintext highlighter-rouge">/tiquete/6942/versoes</code> vai listar as verões e <code class="language-plaintext highlighter-rouge">/tiquete/6942/versoes/4</code> vai acessar o conteúdo da versão 4 desse tíquete.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /v2/tiquete/6942/versoes/4 HTTP 1.1

{
    "id": 6942,
    "titulo": "Erro ao criar Tíquete",
    "descricao": "A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada.",
    "projeto": "PRJ-001",
    "epico": "CRIAR-TIQUETE",
    "tags": ["Java", "REST", "CRUD"]
}
</span></code></pre></div></div>

<p>Em extensão a esse padrão, o end-point da entidade pode retornar a versão atual do recurso usando um cabeçalho. Não há nenhum cabeçalho definido pelo protocolo HTTP para definir a versão da entidade; alguns usam o cabeçalho <code class="language-plaintext highlighter-rouge">ETag</code>, mas ele não tem esse proposito. Como a versão é específica da lógica da aplicação, poderíamos definir um cabeçalho usando o prefixo <code class="language-plaintext highlighter-rouge">X-</code>, mas essa prática foi definida como antipadrão pela RFC-6648. Logo é necessário que esse cabeçalho seja definido pela aplicação como um cabeçalho comum, talvez <code class="language-plaintext highlighter-rouge">Entity-Version</code>, usando um número sequencial.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET /v2/tiquete/6942 HTTP 1.1

Entity-Version: 6

{
    "id": 6942,
    "titulo": "Erro ao criar Tíquete",
    "descricao": "A API de criação de tíquetes retorna erro 500 quando nenhuma tag é associada.",
    "causaRaiz": "Tíquetes sem nenhuma tag associada geram um excessão não tratada na API.",
    "solucaoProposta": "1. Adicionar validação backend\n2.Adicionar validação frontend"
    "projeto": "PRJ-001",
    "epico": "CRIAR-TIQUETE",
    "tags": ["Java", "REST", "CRUD"]
}
</span></code></pre></div></div>

<h2 id="encontrando-antipadrões">Encontrando antipadrões</h2>

<p>Agora podemos inverter a pergunta: <em>dados os padrões existente na literatura, quais devemos evitar?</em> Isso é o que chamamos de antipadrões. São soluções comuns para problemas rotineiros, mas que não apresentam um resultado ótimo.</p>

<p>Muitos desenvolvedores têm preconceito com o termo “antipadrão”. Mas eles se tratam de críticas construitivas. Em muitos casos devem ser interpretados como um aviso de cuidado, não como uma proibição categórica. Antipadrões não existem porque alguém não gostou, existem porque foram levantados vários argumentos de que eles não devem ser utilizados em determinados contextos. Por isso, ao apresentar um antipadrão vamos sempre descrever quais são as desvantagens que eles trazem ao serem usados, cabendo ao desenvolvedor ou à desenvolvedora decidir se deve usar ou não.</p>

<p>Fizemos um levantamentos de antipadrões dentro da literatura analisada, os termos em negrito são destaques da própria literatura. Para apresentar, não vamos seguir o modelo dos padrões, vamos apenas apresentar uma lista de desvantagens para cada antipadrão e, em alguns casos, exemplos pessoais que já implementei. Esta é a lista de antipadrões que vamos apresentar:</p>

<ul>
  <li><strong>Quebrando a autodescrição</strong></li>
  <li><strong>Esquecendo a Hipermídia</strong></li>
  <li><strong>Ignorando o cache</strong></li>
  <li><strong>Ignorando os MIME Types</strong></li>
  <li><strong>Ignorando o Status Code</strong></li>
  <li><strong>Túnel através de GET</strong></li>
  <li><strong>Túnel através de POST</strong></li>
  <li><strong>Autenticação como Consulta</strong></li>
</ul>

<h3 id="quebrando-a-autodescrição">Quebrando a autodescrição</h3>

<p>Desenvolvedores de APIs REST tendem a ignorar os <strong>cabeçalhos padrão</strong>, <strong>formatos</strong> e <strong>protocolos</strong> e criam customizações proprias. Esta prática quebra o caráter autodescritivo e a mensagem contida no cabeçalho. A ausência do caráter autodescritivo limita a <strong>reutilização</strong> e a <strong>adaptabilidade</strong> do recurso REST.</p>

<p>Esse erro é muito comum, não podemos discutir as ocorrências deles porque isso seria fruto de uma enorme pesquisa em bases de códigos que pela própria natureza do antipadrão seria impraticável. Mas podemos discutir o motivo que ele acontece.</p>

<p>O gatilho desse antipadrão é composto por dois fatores muito importantes: pouco tempo e pouco conhecimento. Quando um time sem experiência em REST tem pouco tempo para implementar uma funcionalidade, há a tentação de não se fazer um design prévio e um consulta a documentações ou especificações.</p>

<p>Por volta de 2008 trabalhei em um projeto em que era preciso implementar um controle de concorrência e o arquiteto do time propôs que cada recurso deveria ter um campo <code class="language-plaintext highlighter-rouge">lastUpdate</code>. Esse campo deveria ser enviado para o formulário de edição e usado durante a operação de atualização. Se o <code class="language-plaintext highlighter-rouge">lastUpdate</code> enviado pela requisição fosse diferente do salvo na base de dados, deveria ser exibido um erro para o usuário. Perceba que essa é exatamente a função do cabeçalho <code class="language-plaintext highlighter-rouge">ETag</code>, mas na época o framework utilizado não permitia a criação de requisições REST, logo uma aplicação simulava aplicações desktop.</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>Desenvolvedores que usam a API não compreenderão as especifidades</li>
  <li>Bibliotecas e frameworks apresentarão dificuldades para serem integrados, e se essas funcionalidades já forem integradas por padrão será preciso reimplementar</li>
</ul>

<h3 id="esquecendo-a-hipermídia">Esquecendo a Hipermídia</h3>

<p>A falta de hipermídia, ou seja, a não vinculação de recursos, dificulta a transição de estado para aplicativos REST. Uma possível indicação deste antipadrão é a ausência de links de URL na representação de origem, o que normalmente restringe os clientes a seguirem os links, ou seja, limita a comunicação dinâmica entre clientes e servidores.</p>

<p>Uma das grandes dificuldades em se usar APIs é a dificuldade cognitiva para entendê-la. Como Florian Haupt analisa, algumas APIs podem ter inúmeras entidades e, quanto maior for a variedade da estrutura, mais difícil será para um cliente conseguir resolver essas entidades. Assim, esse antipadrão se apresenta para APIs públicas como um grande entrave. Um desenvolvedor deve conhecer a API a fundo e programaticamente gerar todas os end-points de entidade. O fornecimento da hipermídia facilita a navegação, assim como pode permitir que novas entidades sejam facilmente introduzidas na API.</p>

<p>Todas as APIs que eu implementei possuíam esse antipadrão, algumas delas eram públicas o que podem ter causado problemas de atualização para versões futuras.</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>A lógica de associação entre recursos deve ser implementada tanto na API quanto nos clientes</li>
  <li>A ausência da hipermidia gera uma dependência de versões entre clientes e APIs</li>
</ul>

<h3 id="ignorando-o-cache">Ignorando o cache</h3>

<p>Clientes REST e desenvolvedores back-end tendem a <strong>evitar</strong> o cache devido à sua complexidade de implementação. Ao ignorar recursos de cache não usando <code class="language-plaintext highlighter-rouge">_Cache-Control: no-cache_</code> ou <code class="language-plaintext highlighter-rouge">_no-store_</code> e não provendo um <code class="language-plaintext highlighter-rouge">ETag</code> no cabeçalho da resposta, evita-se qualquer redução no número de requisições direcionadas para o servidor.</p>

<p>Esse antipadrão é bastante comum, o controle de cache não está no conceito de pronto de muitos projetos ou em muitas projetos de design, até porque em 99% dos projetos de software <strong>o cache não é importante</strong>. O cache será importante quando o seu projeto de software for usado por muitos clientes. Vale a pena relembrar a frase do Donald E. Knuth <em>“A otimização prematura é a raiz de todos os males (ou pelo menos da maior parte deles) na programação”</em>.</p>

<p>A necessidade de cache deve ser validada em cada projeto. Ao nos depararmos com essa questão devemos fazer duas perguntas:</p>

<ul>
  <li>Essa entidade será acessada por muitos clientes?</li>
  <li>É o momento certo para implementar o controle de cache?</li>
</ul>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>Não haverá nenhuma otimização usando cache</li>
  <li>APIs com alta demanda de requisições vão usar recursos de infraestrutura desnecessários</li>
</ul>

<h3 id="ignorando-os-mime-types">Ignorando os MIME Types</h3>

<p>O servidor deve representar um mesmo <strong>recurso</strong> em vários formatos, por exemplo, <strong>XML</strong>, <strong>JSON</strong>, PDF etc. Isso permite que clientes, desenvolvidos em qualquer linguagem consumam a API, independente do formato.</p>

<p>Esse antipadrão acontece quando os desenvolvedores back-end geralmente tem uma <strong>única representação</strong> de recursos ou dependem de seus próprios formatos, o que limita a <strong>acessibilidade</strong> e a <strong>reutilização</strong> da API.</p>

<p>Para esse antipadrão, devemos pontuar duas ocorrências. Uma é esquecer completamente de declarar o MIME Type, a outra é somente declarar um MIME Type. No primeiro caso, é um erro que pode acarretar na necessidade da escrita de mais código para quem consome a API, pois a maioria das bibliotecas de clientes HTTP já esperam o MIME Type. Muitos dos frameworks back-end já têm um MIME Type padrão, mas por boa prática é sempre bom declarar todos os formatos aceitos por um end-point.</p>

<p>Quando temos apenas um tipo de MIME Type, a primeira pergunta que devemos fazer é: <em>quantos clientes nossa API vai ter?</em> Se a resposta for contável e estiver todos dentro do controle da equipe de desenvolvimento, tudo bem seguir somente com um formato fora do padrão. Mas se pudermos ter clientes que não conheçemos, vale a pena adicionar diversos formatos, incluindo todos aqueles que já são padrões para APIs.</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>Frameworks front-end podem não reconhecer o tipo de mensagem retornada</li>
  <li>O navegador pode não reconhecer o tipo de mensagem retornada</li>
  <li>O desenvolvedor terá trabalho adicional para implementar corretamente o uso da API</li>
</ul>

<h3 id="ignorando-o-status-code">Ignorando o Status Code</h3>

<p>Apesar de um rico conjunto de códigos de status definidos para vários contextos, os desenvolvedores REST tendem a evitá-los. Em muitos casos não se preocupam com eles, ou, quando muito, apenas usam os mais comuns, a saber 200, 404 e 500. Ou em um caso ainda pior, usam o código de status errado para um determinado tipo de resposta. O uso correto dos códigos de status é muito importante, assim como conhecer os tipos 2xx, 3xx, 4xx e 5xx que adicionam semântica ao protocolo HTTP.</p>

<p>Esse antipadrão é o que mais impacta qualquer consumidor de APIs. O uso do Status Code indica o tipo de resposta que temos, esquecer ele vai implicar em sempre retornar 200, isso pode mascarar erros na requisição ou mesmo erros no servidor. É imperativa a declaração de todos os possíveis erros na documentação, assim como o tratamento deles em código. Se um código não trata todos os erros, é bem provavél que um problema deixe vazar informações do servidor como hostname, endereço de IP ou mesmo uma informação da pilha de execução (stackstrace). Exceções também podem trazer comportamentos adversos, como estouro de pilha ou vazamento de memórias, que podem causar instabilidade no servidor.</p>

<p>Um código de uma API deve ser feito usando programação defensiva, isso significa que quem desenvolve deve ter cuidado ao prever o máximo de exceções possível. Como não conhecemos o consumidor da API, é bem provavél que haja mau uso dela. Não estou me referindo ao mau uso intencional, mas se deixarmos de validar todos os parâmetros, podemos trazer instabilidade indesejada a nossa API.</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>Erros podem se identificados como requisições executadas corretamente deixando de serem validados</li>
</ul>

<h3 id="mau-uso-de-cookies">Mau uso de Cookies</h3>

<p>Stateless é uma propriedade do REST a ser seguida. Manter o estado da sessão no lado do servidor é uma má prática e não deve ser feito. Cookies descaracterizam sua API, assim ela não poderá ser chamada de RESTful. O envio de chaves ou tokens no campo de cabeçalho <code class="language-plaintext highlighter-rouge">Set-Cookie</code> ou <code class="language-plaintext highlighter-rouge">Cookie</code> para a sessão do lado do servidor é um exemplo de uso indevido de cookies, que diz respeito à segurança e privacidade.</p>

<p>Não há muito o que discutir nesse padrão. Se uma requisição REST precisa de uma informação em memória no servidor, algo está errado. A boa prática é que, ou a informação esteja armazenada no banco e seja independente da sessão, ou ela esteja dentro do Token JWT e seja parte do cadastro do usuário. Caso não esteja nessas duas condições temos um sério problema de design. Um desses problemas de design é a tentação de armazenar informações inerente ao front-end no back-end, isso é relativamente fácil de se identificar.</p>

<p>Para sabermos se essa informação é referente ao front-end devemos perguntar se ela se refere à lógica da entidade ou à lógica da interface. Se for a lógica da interface, logo ela pode variar entre os vários clientes disponíveis. Outro sinal de que temos um problema de design é o nível de complexidade. Se o nível de complexidade está aumentando, é hora de pararmos e repensar o design da API.</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>O uso de cookies implica na impossiblidade de escalabilidade</li>
  <li>Caso seja preciso escalar, é necessário o uso de um mecanismo de cache para armazenar informações da sessão</li>
</ul>

<h3 id="túnel-através-de-get">Túnel através de GET</h3>

<p>Sendo o método HTTP mais fundamental em REST, o método GET recupera um recurso identificado por um URI. No entanto, muitas vezes os desenvolvedores usam apenas este método para realizar qualquer tipo de ação ou operação, incluindo a criação, exclusão ou até mesmo para atualizar um recurso. No entanto, HTTP GET é um método impróprio para qualquer ação diferente de acessar um recurso e não corresponde ao seu propósito semântico, se usado indevidamente.</p>

<p>Em APIs REST a semântica dos verbos HTTP deve ser respeitada, não somente pela semântica, mas característica de cada métodos. O método <code class="language-plaintext highlighter-rouge">GET</code> não aceita corpo da mensagem, logo se formos usá-lo para alterar recursos, teremos um sério problema de design que dificultará o desenvolvimento. Qualquer alteração requer parâmetros, e eles deverão ser enviados ou por Query ou pelo próprio Path, isso dificultará tanto o desenvolvimento quanto o uso da API.</p>

<p>Como regra última, use: <code class="language-plaintext highlighter-rouge">GET</code> deve ser somente usado para acessar informação, nunca para alterar.</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>Dificuldade para serializar parâmetros</li>
  <li>Cache de operações indevidas</li>
  <li>Problema semântico</li>
</ul>

<h3 id="túnel-através-de-post">Túnel através de POST</h3>

<p>Esse antipadrão é muito semelhante ao anterior, exceto que, além do URI, o corpo da solicitação HTTP POST pode incorporar operações e parâmetros a serem aplicados ao recurso. Os desenvolvedores tendem a depender apenas do método HTTP POST para enviar qualquer tipo de solicitação ao servidor, incluindo acesso, atualização ou exclusão de um recurso. Em geral, o uso adequado de HTTP POST é criar um recurso do lado do servidor. Qualquer paramêtro que altere uma requisição de informação deve ser enviado como Query Parameter.</p>

<p>Muito provavelmente vamos ver esse antipadrão sendo aplicado para parâmetros de buscas. Alguns desenvolvedores usam o corpo da mensagem para definir esses parâmetros. Mas podemos ver dois problemas nessa abordagem. O primeiro dos problemas é a dificuldade de se resolver o cache. O método POST não é passível de cache, porque ele já prevê que serão feitas alterações. Usando os parâmetros na Query, todos os componentes de cache conseguirão identificar que uma resposta prévia pode ser usada para resolver a requisisão sem acessar o servidor. O segundo problema é semântico, como já foi discutido previamente. O verbo <code class="language-plaintext highlighter-rouge">POST</code> e <code class="language-plaintext highlighter-rouge">PUT</code> devem ser usados para alterar informação, caso tenhamos um requisito de negócio que seja necessário usar, prefira usar o padrão <strong>Requisição Expressa</strong>.</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>Não uso do cache</li>
  <li>Problema semântico</li>
</ul>

<h3 id="autenticação-como-consulta">Autenticação como consulta</h3>

<p>Esse antipadrão é muito recorrente. Em muitas API, os parâmetros de autenticação são enviados através de query string. O protocolo HTTP já prevê vários formatos de autenticação e todos eles se baseiam no uso do header <code class="language-plaintext highlighter-rouge">Authorization</code>. Ao usar uma query string estamos expondo no log da aplicação qual é o token de cada usuário, pois muitos frameworks expõem a URI sendo acessada no log de execução. Ou estamos desperdiçando implementações padrões para autenticação (tanto para front-end quanto para back-end), tendo que criar código desnecessário para esse formato específico de autenticação;</p>

<p><strong>Desvantagens</strong></p>

<ul>
  <li>Código desnecessário</li>
  <li>Falhas de segurança</li>
</ul>

<h2 id="a-complexidade-de-uma-api">A complexidade de uma API</h2>

<p>Discutimos muitos sobre padrões e antipadrões, mas continuando na nossa avaliação de uma API, existe algum método para avaliarmos a complexidade de uma API? Na nossa lista de artigos tem um pouco discutido na sessão anterior, nele Haupt analisa a estrutura de uma API considerando os seus recursos e a sua complexidade. Segundo Haupt, a complexidade de uma API depende diretamente do número recursos que ela define, quantos deles são <em>readOnly</em>, a quantidade de recursos raiz e da profundidade dessa API. Com isso podemos levantar alguns parâmetros novos para analisarmos uma API.</p>

<p>O primeiro parâmetro é a quantidade de recursos, APIs complexas tendem a ter mais recursos. Nesse pontos precisamos nos perguntar se a quantidade de recursos usados na nossa API é ótima. No nosso exemplo temos poucos recursos, basicamente tíquetes e usuários. Mas um usuário pode assumir dois papéis diferentes em relação aos tíquetes sendo <code class="language-plaintext highlighter-rouge">autor</code> ou <code class="language-plaintext highlighter-rouge">responsavel</code>. Ao fazer a escolha por apenas usar a raiz das requisições por <code class="language-plaintext highlighter-rouge">usuario</code>, reduzimos o número de recursos da nossa API, evitando complexidade. Essa complexidade desnecessária pode ser compensada usando o padrão <strong>Vinculação de entidades</strong>, poucas entidades raiz que provê acesso a muitos recursos usando os valores retornados pela própria API.</p>

<p>Quando falamos do número de recursos <em>readOnly</em>, devemos sempre nos perguntar quem gera esses recursos. Se são dados gerados pelo usuário da API, temos um problema de design. Recursos <em>readOnly</em> devem ser metadados da nossa API seguindo o padrão <strong>Acessibilidade dos Metadados</strong>. Mas esses metadados não podem ser criados sem um padrão, os nós informativos devem ser normalizados, reduzindo o número de recursos da nossa API. Uma atividade que pode ser feita para se reduzir o número de metadados é a catalogação deles. Quais são os metadados que nossa aplicação gera? Há algum padrão? Se houver um padrão, eles podem ser reduzidos.</p>

<p>Já a profundidade da API deve ser reduzida usando o padrão HATEOAS. Esse padrão não foi detalhado neste capitulo, mas podemos entendê-lo como uma derivação do <strong>Vinculação de entidades</strong>. Segundo Fielding, o HATEOAS é a implementação definitiva do REST, mas isso não significa que uma API REST deve seguir esse padrão. Na verdade não há nenhuma especificação definindo o HATEOAS deve ser implementado detalhadamente. As definições são genéricas e nenhum dos frameworks de mercado provem um padrão simples de se implementrar. Logo nossa definição também será generica, o HATEOAS permite a navegação entre recursos afim de reduzir a complexidade de uma API.</p>

<h2 id="a-maturidade-de-uma-api">A maturidade de uma API</h2>

<p>Nosso último parâmetro para avaliar uma API é questionar se existe algum modelo de maturidade para API. Modelos de maturidades são bons para avaliarmos onde estamos e como podemos melhorar. Eles normalmente são compostos por níveis e requisitos, ao se cumprir todos os requisitos de um nível, podemos afirmar que atingimos aquele nível. Todo modelo de maturidade começa com um nível zero sem nenhuma exigência, em alguns casos esse nível é chamado de caos.</p>

<p>Quando usamos um modelo de maturidade temos uma análise estruturada do que estamos trabalhado, deixamos de ser subjetivos e passamos ser objetivos. Para APIs REST, temos o <a href="https://www.martinfowler.com/articles/richardsonMaturityModel.html"><em>Richardson Maturity Model</em></a>. Ele define quatro nívels para uma API REST, mas o prório Fielding deixou claro que <a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven"><strong>o nível 3 é um pre-requisito para chamar uma API de RESTful</strong></a>. Isso não significa que sua API não é REST se não chegou a esse nível, precisamos ser flexíveis pois todo software evolui. Se ela expõe recursos e usa os verbos HTTP, de certa forma ela é um tipo de REST.</p>

<p><img src="/assets/images/http/richardson-maturity-model.png" alt="Modelo de maturidade de Richardson" /></p>

<p>No nível zero, podemos qualificar qualquer comunicação HTTP. Existem muitos projetos legados que se encaixam nesse nível, me recordo que pelo ano de 2008, quando comecei a trabalhar com projetos web, era comum encontrar endpoints como <code class="language-plaintext highlighter-rouge">/listarUsuarios.do</code> em que os parâmetros da busca eram passados pelo corpo da mensagem.</p>

<p>No nível um, podemos classificar as APIs que tem alguma lógica na identificação das entidades. Assim qualquer esforço para catalogar as entidades podem fazer com que sua API seja mais fácil de se utilizar. Nesse caso, os end-points serão derivações da entidade, por exemplo, a busca de usuários podem ser <code class="language-plaintext highlighter-rouge">/usuario/buscar</code> ou somente <code class="language-plaintext highlighter-rouge">/usuario</code>.</p>

<p>No nível dois, podemos classificar as APIs que usam os verbos considerando a sua semântica. Nesse nível não vamos ver os seguintes antipadrões <strong>Túnel através de GET</strong> e <strong>Túnel através de POST</strong>.</p>

<p>Por fim, no nível três, temos o controle de hípermidia. Uma requisição vai retornar não somente a informação, mas as entidades e ações correlatas e seus respectivos end-points. Nesse nível temos o que conhecemos como HATEOAS (<em>Hypertext As The Engine Of Application State</em> ou Hipertexto como o Motor do Estado do Aplicativo). O back-end ganha um importância meio na aplicação, e o front-end se torna menos acoplado ao back-end. Será possível adicionar novas funcionalidades ao front-end sem nenhuma alteração no mesmo.</p>

<p>Para alcançar o nível 3, é necessário um esforço grande de design que deve ser alinhado tanto com todos os consumidores da API. A implicação de criar esse nível de API significa que o consumidor vai navegar no resultado, não somente usar a API.7</p>

<h2 id="conclusão">Conclusão</h2>

<p>Neste capítulo, tentamos definir como podemos avaliar uma API. O primeiro elemento para classificação são padrões e antipadrões de projetos. Com eles podemos aumentar o nosso repertório para classificar e descrever APIs. Será que nossa API segue padrões de mercado? Será quem um dos padrões pode ser aplicado para resolver um problema que temos?</p>

<p>Depois avaliamos como se classifica a complexidade de uma API. APIs devem ser de fácil compreensão, quando elas se tornam muito complexas, ou elas não deveriam ser uma API REST, ou elas precisam ser retrabalhadas. Existe algum recurso desnecessário? Podemos extrair um recurso novp? Podemos aplicar algum padrão? APIs complexas podem dificultar a implementação de cliente ou de servidores, e isso pode ser resolvido com uma refatoração da API.</p>

<p>Por fim, podemos analizar a maturidade de uma API. Existem um método para isso? Vimos que sim, podemos qualificar qualquer API em níveis. Isso não significa que nossa API precisa ter o nível máximo, mas que com ela podemos ver como podemos adicionar mais funcionalidades a nossa API.</p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="HTTP" /><category term="REST" /><summary type="html"><![CDATA[Esse é um capítulo descartado do livro que escrevi para Casa do Código. Aqui apresento alguns padrões para melhorar sua API. Não repara na bagunça, ele deu muito trabalho até resolvermos descartar ele.]]></summary></entry><entry><title type="html">REST &amp;amp; HTTP</title><link href="https://blog.vepo.dev/posts/rest-e-http" rel="alternate" type="text/html" title="REST &amp;amp; HTTP" /><published>2021-09-09T00:00:00+00:00</published><updated>2021-09-09T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/15-40-00-rest-e-http</id><content type="html" xml:base="https://blog.vepo.dev/posts/rest-e-http"><![CDATA[<p>Ano passado eu me dediquei a escrever sobre HTTP e REST. Estava com alguns objetivos claro em mente, queria mostrar quando usar e como usar o HTTP. Depois me fiz algumas perguntas e fui pesquisar se existem padrões de projeto em REST. Dessa peqquisa saiu dois POST enormes. O primeiro eu decidi tornar um livreto, mas sem muita revisão e sem muita experiência.</p>

<p>Com esse “livreto” eu acabei conseguindo ser aceito como escritor na <a href="https://www.casadocodigo.com.br/">Casa do Código</a>, a ideia é escrever um livro sobre desenvolvimento backend, mas focado nos protocolos e não nos frameworks. A parte HTTP já está pronta, e o tal “livreto” é só um capitulo, tem muito mais.</p>

<p>Esse tal livreto está disponível na Amazon, de graça pra quem gosta de sustentar o Jeff Benzos.</p>

<p><a href="https://www.amazon.com.br/Anatomia-Protocolo-HTTP-protocolos-frameworks-ebook/dp/B08PSDT35Y/?_encoding=UTF8&amp;pd_rd_w=uCTIy&amp;pf_rd_p=4b9652c9-ac45-4535-ac4d-eec51129bb6c&amp;pf_rd_r=15TFWDDHRR59X7MWSBNM&amp;pd_rd_r=57f799bb-5689-4dd4-8b73-f7ba4703b773&amp;pd_rd_wg=1Ar7d&amp;ref_=pd_gw_ci_mcx_mr_hp_d"><img src="/assets/images/Anatomia-do-Protocolo-HTTP-medium.png" alt="Anatomia do Protocolo HTTP" /></a></p>

<p>Se você quiser pegar no Leanpub, também está lá: <a href="https://leanpub.com/anatomiahttp/">leanpub.com/anatomiahttp</a></p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="REST" /><category term="HTTP" /><category term="Backend" /><category term="Livros" /><summary type="html"><![CDATA[Mais conteúdo sobre REST e HTTP... Agora um pouco melhor!]]></summary></entry></feed>