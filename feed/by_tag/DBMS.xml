<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/DBMS.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2026-02-21T19:42:20+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/DBMS.xml</id><title type="html">vepo</title><subtitle>Um repositório para todos os posts, palestras e tutoriais que já fiz. Java, Desenvolvimento de Software e reflexões sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">Arquitetura de um Banco de Dados Relacional</title><link href="https://blog.vepo.dev/posts/arquitetura-dbms" rel="alternate" type="text/html" title="Arquitetura de um Banco de Dados Relacional" /><published>2025-12-22T00:00:00+00:00</published><updated>2025-12-22T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/12-17-00-arquitetura-dbms</id><content type="html" xml:base="https://blog.vepo.dev/posts/arquitetura-dbms"><![CDATA[<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
Esse post é baseado em um capítulo do livro <a href="https://amzn.to/44Iatr3"><strong>Database Internals</strong> de Alex Petrov</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Agora que entendemos o que é uma base de dados relacional e como podemos interagir com ela usando SQL, vamos ver como uma base de dados relacional é construída internamente. Entender como umas base de dados funciona internamente pode nos ajudar a compreender melhor seu comportamento e com isso podemos tomar decisões mais informadas sobre o uso ou a escolha de uma base de dados.</p>
</div>
<div class="paragraph">
<p>Todas as implementações de bancos de dados são diferentes, mas a maioria delas compartilha de funcionalidades e arquiteturas semelhantes. No diagrama abaixo, temos uma visão geral de uma possível arquitetura de um sistema de gerenciamento de banco de dados relacional (DBMS - <strong>Database Management System</strong>), mas é importante lembrar que cada implementação pode variar em detalhes específicos.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/images/databases/dmbs-arquitecture.png" alt="dmbs arquitecture">
</div>
<div class="title">Figura 1. Arquitetura de um Sistema de Gerenciamento de Banco de Dados Relacional (DBMS)</div>
</div>
<div class="paragraph">
<p>Para descrever essa arquitetura, vamos usar uma abordagem de cima para baixo, começando pelo módulo de transporte.</p>
</div>
<div class="sect1">
<h2 id="_módulo-de-transporte-transport">Módulo de Transporte (<em>Transport</em>)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A grande maioria das bases de dados modernas são implementadas usando uma arquitetura cliente-servidor. Isso significa que a aplicação que utiliza o banco de dados atua como cliente, enquanto o processo do banco de dados atua como servidor.  Para isso o módulo de transporte é responsável por gerenciar a comunicação entre a aplicação cliente e, em caso de bancos distribuídos, entre as diferentes instâncias do banco de dados.</p>
</div>
<div class="paragraph">
<p>As <em>queries</em> SQL são então processadas pelo módulo <strong>Client Communication</strong>, que interpreta as requisições vindas do cliente e as encaminha para o próximo módulo, o <strong>Query Processor</strong>.</p>
</div>
<div class="paragraph">
<p>Quando a comunicação é feita entre diferentes instâncias do banco de dados, ela não envolve o processamento de consultas SQL e por isso é tratada diretamente pela <strong>Execution Engine</strong>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo-de-processamento-de-consultas-query-processor">Módulo de Processamento de Consultas (<em>Query Processor</em>)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O módulo de processamento de consultar é responsável por interpretar, validar e otimizar as consultas SQL recebidas do módulo de transporte. Ele é composto por dois submódulos principais: o <strong>Query Parser</strong> e o <strong>Query Optimizer</strong>. O submódulo <strong>Query Optimizer</strong> é responsável por analisar a consulta SQL e determinar a forma mais eficiente de executá-la, levando em consideração fatores como índices disponíveis, estatísticas de dados e custos de execução.</p>
</div>
<div class="paragraph">
<p>Um plano de execução é gerado baseado na <em>query</em> SQL recebida e é passado para o próximo módulo, a <strong>Execution Engine</strong>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo-motor-de-execução-execution-engine">Módulo Motor de Execução (<em>Execution Engine</em>)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para que o plano de execução gerado pelo módulo de processamento de consultas seja executado, ele pode ser executado localmente ou remotamente, se o banco de dados for distribuído. O módulo de execução é responsável por interpretar o plano de execução e coordenar as operações necessárias para recuperar ou modificar os dados conforme especificado na consulta SQL.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo-motor-de-armazenamento-storage-engine">Módulo Motor de Armazenamento (<em>Storage Engine</em>)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O módulo motor de armazenamento é responsável por gerenciar a forma como os dados são armazenados fisicamente no disco. Ele é dividido em cinco submódulos principais: o <strong>Transaction Manager</strong>, o <strong>Lock Manager</strong>, o <strong>Access Methods</strong>, o <strong>Buffer Manager</strong> e o <strong>Recovery Manager</strong>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/assets/images/databases/storage-types.png" alt="storage types">
</div>
<div class="title">Figura 2. Tipos de armazenamentos possíveis para bases de dados</div>
</div>
<div class="paragraph">
<p>Um dos grandes desafios enfrentados pelas bases de dados é melhorar o desempenho do acesso ao disco. Todas as informações em um banco de dados são armazenadas em algum tipo de mídia não-volátil, mesmo que esteja em algum sistema de armazenamento em nuvem, e qualquer acesso a esses dados envolve operações de leitura e escrita que são muito mais lentas que as operações realizadas na memória volátil (RAM).</p>
</div>
<div class="paragraph">
<p>Outro desafio é que a leitura e escrita de dados no disco é feita em blocos de tamanho fixo, o que significa que mesmo que apenas um pequeno pedaço de informação seja necessário, o sistema precisa ler ou escrever o bloco inteiro. Esse comportamento é diferente do acesso à memória volátil, onde é possível acessar qualquer byte individualmente.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Tabela 1. Tempos médios de acesso para diferentes tipos de memória e armazenamento</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Tempo de Acesso</th>
<th class="tableblock halign-left valign-top">Tipo de Memória</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">~1ns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L1 Cache Ref</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">~4ns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L2 Cache Ref</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">~100ns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DRAM</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">~16.000ns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSD</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">~2.000.000ns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HDD</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">~50.000.000ns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rede</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">~1.000.000.000ns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fita</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Todos os dados de um banco de dados, em última instância, são armazenados em arquivos no sistema de arquivos. Esses arquivos podem ser organizados de diferentes maneiras, dependendo da implementação do banco de dados, mas geralmente são divididos em páginas ou blocos de tamanho fixo (por exemplo, 4KB ou 8KB). Cada página pode ser organizada por tuplas (linhas), log estruturado ou orientado a índices.</p>
</div>
<div class="sect2">
<h3 id="_gerenciador-de-transações-transaction-manager">Gerenciador de Transações (<em>Transaction Manager</em>)</h3>
<div class="paragraph">
<p>O gerenciador de transações é responsável por organizar a execução das transações garantindo que a base de dados esteja sempre em um estado consistente.</p>
</div>
</div>
<div class="sect2">
<h3 id="_gerenciador-de-bloqueios-lock-manager">Gerenciador de Bloqueios (<em>Lock Manager</em>)</h3>
<div class="paragraph">
<p>O gerenciador de bloqueios é responsável por controlar o acesso concorrente aos dados envolvidos em transações concorrentes, garantindo o isolamento entre elas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_métodos-de-acesso-access-methods">Métodos de Acesso (<em>Access Methods</em>)</h3>
<div class="paragraph">
<p>Os métodos de acesso são responsáveis por definir como os dados são organizados e acessados no armazenamento físico. Eles utilizam estruturas de dados como árvores B, árvores LSM e arquivos heap.</p>
</div>
</div>
<div class="sect2">
<h3 id="_gerenciador-de-buffer-buffer-manager">Gerenciador de Buffer (<em>Buffer Manager</em>)</h3>
<div class="paragraph">
<p>O gerenciador de buffer é responsável por gerenciar a memória volátil (RAM) utilizada para armazenar temporariamente os dados que estão sendo lidos ou escritos no disco. Ele otimiza o desempenho do banco de dados reduzindo o número de acessos ao disco.</p>
</div>
</div>
<div class="sect2">
<h3 id="_gerenciador-de-recuperação-recovery-manager">Gerenciador de Recuperação (<em>Recovery Manager</em>)</h3>
<div class="paragraph">
<p>O gerenciador de recuperação é responsável por garantir a integridade dos dados em caso de falhas, como quedas de energia ou erros de software. Ele utiliza técnicas como logs de transações e pontos de verificação para restaurar o banco de dados a um estado consistente após uma falha.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusão">Conclusão</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bancos de Dados são sistemas com diversas implementações diferentes, mas a maioria deles compartilha de funcionalidades e arquiteturas semelhantes. Entender como uma base de dados relacional é construída internamente pode nos ajudar a compreender melhor seu comportamento e com isso podemos tomar decisões mais informadas sobre o uso ou a escolha de uma base de dados.</p>
</div>
</div>
</div>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Ciência da Computação" /><category term="Bases de Dados" /><category term="DBMS" /><category term="Banco de Dados" /><summary type="html"><![CDATA[Entenda a arquitetura interna de um sistema de gerenciamento de banco de dados relacional (DBMS) e como seus principais componentes funcionam juntos para armazenar, gerenciar e recuperar dados de forma eficiente.]]></summary></entry></feed>