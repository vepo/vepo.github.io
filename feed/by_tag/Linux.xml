<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/Linux.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2025-10-07T11:58:40+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/Linux.xml</id><title type="html">vepo</title><subtitle>Um reposit√≥rio para todos os posts, palestras e tutoriais que j√° fiz. Java, Desenvolvimento de Software e reflex√µes sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">Criando um servi√ßo Linux</title><link href="https://blog.vepo.dev/posts/criando-um-servico-linux" rel="alternate" type="text/html" title="Criando um servi√ßo Linux" /><published>2021-08-17T00:00:00+00:00</published><updated>2021-08-17T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/16-54-00-criando-servico-linux</id><content type="html" xml:base="https://blog.vepo.dev/posts/criando-um-servico-linux"><![CDATA[<p>Antes de criar um servi√ßo, precisamos preparar o ambiente. Vamos instalar todas as depend√™ncias. No caso que estou trabalhando √© um bot simples em Java, por isso preciso instalar o git, Java 11 e Maven. Farei a build na pr√≥pria m√°quina, esse ambiente √© para valida√ß√£o de um conceito, uma PoC que provavelmente vai virar ambiente de produ√ß√£o. MAS‚Ä¶ como √© um bot, posso transformar ele em uma imagem docker.</p>

<p>Ent√£o o primeiro passo √© deixar o ambiente redondo para a execu√ß√£o. Instalei o GIT, Java 11, Maven. Coloquei todas as vari√°veis de ambiente necess√°rias configuradas pelo <code class="language-plaintext highlighter-rouge">/etc/bashrc</code>.</p>

<p>Ent√£o eu descubro que a vers√£o do Quarkus.io do bot estava completamente desatualizada! üò≥</p>

<p>Mas consegui criar execut√°vel Java para meu bot, sua tarefa √© executar a cada 10s uma opera√ß√£o de atualiza√ß√£o. Para isso usei Quakus.</p>

<h2 id="servi√ßos-linux">Servi√ßos Linux</h2>

<p>Atrav√©s do comando <code class="language-plaintext highlighter-rouge">systemctl</code> o Linux exp√µe uma s√©rie de servi√ßos. Para criar um, basta criar um arquivo texto, mas antes vamos explorar um pouco o pr√≥prio comando.</p>

<p>Vamos listar todos os servi√ßos disponiveis?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>systemctl list-unit-files
UNIT FILE                                     STATE
proc-sys-fs-binfmt_misc.automount             static
acpid.service                                 enabled
arp-ethers.service                            disable
grub-boot-indeterminate.service               static
grub2-systemd-integration.service             static
sshd-keygen.service                           static
sshd.service                                  enabled
sshd@.service                                 static
network.target                                static
nfs-client.target                             enabled
</code></pre></div></div>

<p>Ora vemos alguns servi√ßos interessantes como o <code class="language-plaintext highlighter-rouge">sshd</code>, <code class="language-plaintext highlighter-rouge">network</code> e o <code class="language-plaintext highlighter-rouge">nfs-client</code>. <code class="language-plaintext highlighter-rouge">sshd</code> √© o daemon do servidor SSH, pelo qual estou conectado. Se eu quiser saber o status do <code class="language-plaintext highlighter-rouge">sshd</code>?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>systemctl status sshd
‚óè sshd.service - OpenSSH server daemon
   Loaded: loaded <span class="o">(</span>/usr/lib/systemd/system/sshd.service<span class="p">;</span> enabled<span class="p">;</span> vendor preset: enabled<span class="o">)</span>
   Active: active <span class="o">(</span>running<span class="o">)</span> since Tue 2021-08-17 19:32:20 UTC<span class="p">;</span> 3h 27min ago
     Docs: man:sshd<span class="o">(</span>8<span class="o">)</span>
           man:sshd_config<span class="o">(</span>5<span class="o">)</span>
 Main PID: 3152 <span class="o">(</span>sshd<span class="o">)</span>
   CGroup: /system.slice/sshd.service
           ‚îî‚îÄ3152 /usr/sbin/sshd <span class="nt">-D</span>

Aug 17 22:46:33 ip-172-31-44-73.us-east-2.compute.internal sshd[9447]: Received disconnect from 134.122.63.163 port 34174:11: Normal Shutdown, Thank you <span class="k">for </span>playing <span class="o">[</span>preauth]
Aug 17 22:46:33 ip-172-31-44-73.us-east-2.compute.internal sshd[9447]: Disconnected from 134.122.63.163 port 34174 <span class="o">[</span>preauth]
Aug 17 22:47:45 ip-172-31-44-73.us-east-2.compute.internal sshd[9475]: Invalid user user from 134.122.63.163 port 42936
Aug 17 22:47:45 ip-172-31-44-73.us-east-2.compute.internal sshd[9475]: input_userauth_request: invalid user user <span class="o">[</span>preauth]
Aug 17 22:47:45 ip-172-31-44-73.us-east-2.compute.internal sshd[9475]: Received disconnect from 134.122.63.163 port 42936:11: Normal Shutdown, Thank you <span class="k">for </span>playing <span class="o">[</span>preauth]
Aug 17 22:47:45 ip-172-31-44-73.us-east-2.compute.internal sshd[9475]: Disconnected from 134.122.63.163 port 42936 <span class="o">[</span>preauth]
Aug 17 22:48:55 ip-172-31-44-73.us-east-2.compute.internal sshd[9547]: Invalid user user from 134.122.63.163 port 51822
Aug 17 22:48:55 ip-172-31-44-73.us-east-2.compute.internal sshd[9547]: input_userauth_request: invalid user user <span class="o">[</span>preauth]
Aug 17 22:48:55 ip-172-31-44-73.us-east-2.compute.internal sshd[9547]: Received disconnect from 134.122.63.163 port 51822:11: Normal Shutdown, Thank you <span class="k">for </span>playing <span class="o">[</span>preauth]
Aug 17 22:48:55 ip-172-31-44-73.us-east-2.compute.internal sshd[9547]: Disconnected from 134.122.63.163 port 51822 <span class="o">[</span>preauth]
</code></pre></div></div>

<p>Eu poderia at√© reiniciar o sshd com o comando abaixo. MAS n√£o seria uma boa ideia‚Ä¶</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl status sshd
</code></pre></div></div>

<p>Para controlar um servi√ßo, podemos usar os seguintes comandos <code class="language-plaintext highlighter-rouge">status</code>, <code class="language-plaintext highlighter-rouge">start</code>, <code class="language-plaintext highlighter-rouge">stop</code>, <code class="language-plaintext highlighter-rouge">reload</code>, <code class="language-plaintext highlighter-rouge">restart</code>, <code class="language-plaintext highlighter-rouge">try-restart</code> e <code class="language-plaintext highlighter-rouge">kill</code>. Caso queria saber mais sobre essas funcionalidades, execute:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nt">--help</span>
</code></pre></div></div>

<h2 id="criando-um-servi√ßo-para-um-processo-java">Criando um servi√ßo para um processo Java</h2>

<p>Para criar um servi√ßo tempos que escrever um arquivo Unit. Uma documenta√ß√£o detalhada pode ser encontrada em <em><a href="https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux">How to create systemd service unit in Linux</a></em>.</p>

<p>Para nosso arquivo vamos colocar todos os bin√°rios compilados pelo quarkus em <code class="language-plaintext highlighter-rouge">/opt/meu-bot</code>, para que eu nunca erre na atualiza√ß√£o, criei um script bem simples.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash -e</span>
mvn clean package

<span class="nb">mkdir</span> <span class="nt">-p</span> /opt/meu-bot
<span class="nb">sudo rm</span> <span class="nt">-R</span> /opt/meu-bot/<span class="k">*</span>

<span class="nb">sudo cp</span> <span class="nt">-R</span> target/quarkus-app/<span class="k">*</span> /opt/meu-bot/
<span class="nb">sudo cp </span>tools/meu-bot.service /etc/systemd/system/
<span class="nb">sudo chown</span> <span class="nt">-R</span> ec2-user:ec2-user /opt/meu-bot/

<span class="nb">sudo </span>systemctl daemon-reload
<span class="nb">sudo </span>systemctl restart meu-bot
</code></pre></div></div>

<p>Quem define o servi√ßo √© o arquivo <code class="language-plaintext highlighter-rouge">meu-bot.service</code> que deve ficar na pasta <code class="language-plaintext highlighter-rouge">/etc/systemd/system</code>. Depois de atualizado o arquivo, precisamos rodar o comando <code class="language-plaintext highlighter-rouge">systemctl daemon-reload</code> e ent√£o √© s√≥ iniciar o servi√ßo <code class="language-plaintext highlighter-rouge">systemctl restart meu-bot</code>.</p>

<p>Assim o conte√∫do do servi√ßo ser√°:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Unit]
Description=Meu Bot Service
Requires=network.target
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
User=ec2-user
ExecStart=/usr/lib/jvm/java-11-openjdk-11.0.11.0.9-1.amzn2.0.1.x86_64/bin/java -jar /opt/meu-bot/quarkus-run.jar
WorkingDirectory=/opt/meu-bot/

[Install]
WantedBy=multi-user.target
</code></pre></div></div>

<p>Observe que preciso definir alguns par√¢metros obrigat√≥rios como <code class="language-plaintext highlighter-rouge">User</code>, <code class="language-plaintext highlighter-rouge">ExecStart</code> e <code class="language-plaintext highlighter-rouge">Requires</code>. Outros s√£o opcionais como <code class="language-plaintext highlighter-rouge">WorkingDirectory</code>. Para os outros, eu n√£o validei a necessidade, mas √© bom sempre usar. Um detalhe importante nesse arquivo √© que todos os execut√°veis devem ser refer√™nciados pelo caminho absolutor, por isso n√£o usei apenas <code class="language-plaintext highlighter-rouge">java</code>. Foi necess√°rio buscar o caminho real do execut√°vel Java no sistema, nada que usando <code class="language-plaintext highlighter-rouge">whereis java</code> n√£o resolva.</p>

<p>Agora √© s√≥ verificar se o servi√ßo est√° de p√©:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>systemctl status meu-bot
‚óè meu-bot.service - Meu Bot Service
   Loaded: loaded <span class="o">(</span>/etc/systemd/system/meu-bot.service<span class="p">;</span> enabled<span class="p">;</span> vendor preset: disabled<span class="o">)</span>
   Active: active <span class="o">(</span>running<span class="o">)</span> since Tue 2021-08-17 22:49:26 UTC<span class="p">;</span> 22min ago
 Main PID: 9565 <span class="o">(</span>java<span class="o">)</span>
   CGroup: /system.slice/meu-bot.service
           ‚îî‚îÄ9565 /usr/lib/jvm/java-11-openjdk-11.0.11.0.9-1.amzn2.0.1.x86_64/bin/java <span class="nt">-jar</span> /opt/meu-bot/quarkus-run.jar
</code></pre></div></div>

<h2 id="acessando-o-log-do-servi√ßo">Acessando o log do servi√ßo</h2>

<p>Observe que n√£o falamos de log!</p>

<p>Quando fazemos um servi√ßo, existe v√°rias formas de log. Voc√™ pode direcionar o log para um arquivo, ou pode deixar que o sistema operacional cuide dele. Caso deixe para o sistema, pode acessar usando</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>journalctl -f -u meu-bot.service
</code></pre></div></div>

<h2 id="conclus√£o">Conclus√£o</h2>

<p>Criar um servi√ßo √© f√°cil usando Linux. Precisa s√≥ de um arquivo texto e seu programa compilado. √â a melhor abordagem se voc√™ precisa de um programa sempre em execu√ß√£o. Caso seu programa termine a execu√ß√£o ao encontrar qualquer erro, voc√™ ter√° o pr√≥prio sistema reinicializando ele.</p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Linux" /><category term="Java" /><category term="Servi√ßos" /><summary type="html"><![CDATA[Linux tem um excelente suporte a servi√ßo. Vamos tentar demonstrar rapidamente como criar um servi√ßo.]]></summary></entry><entry><title type="html">Tudo √© um Arquivo</title><link href="https://blog.vepo.dev/posts/linux-tudo-e-um-arquivo" rel="alternate" type="text/html" title="Tudo √© um Arquivo" /><published>2021-03-03T00:00:00+00:00</published><updated>2021-03-03T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/13-00-00-linux-tudo-e-um-arquivo</id><content type="html" xml:base="https://blog.vepo.dev/posts/linux-tudo-e-um-arquivo"><![CDATA[<h2 id="primeira-li√ß√£o">Primeira Li√ß√£o</h2>

<p>Para aprender sobre o Kernel do Linux, a primeira li√ß√£o √© saber que tudo √© um arquivo. Por exemplo, se voc√™ quiser ver quais s√£o os processos rodando, ao inv√©s de abrir o Gerenciador de Processos, voc√™ pode simplesmente abrir a pasta <code class="language-plaintext highlighter-rouge">/proc</code>. Voc√™ pode controlar tudo que est√° rodando apenas lendo e escrevendo em arquivos.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls /proc/
1    145  151  1589  1615  191   2110  222   2640  472  7    cgroups  cpuinfo      interrupts  meminfo  net   stat  tty     version
144  146  153  1600  184   1932  217   2596  2664  6    bus  cmdline  filesystems  loadavg     mounts   self  sys   uptime  version_signature
</code></pre></div></div>

<p>Por exemplo:</p>

<table>
  <thead>
    <tr>
      <th>Diret√≥rio</th>
      <th>Conte√∫do</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/proc</code></td>
      <td>Todas as informa√ß√µes dos processos em execu√ß√£o</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/dev</code></td>
      <td>Todos os dispositivos dispon√≠veis</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/sys</code></td>
      <td>O sysfs √© usado por programas como o udev para acessar informa√ß√µes do dispositivo e do driver do dispositivo.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/var</code></td>
      <td>A pasta padr√£o onde o sistema escreve dados durante o curso de sua opera√ß√£o.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/usr</code></td>
      <td>Este √© um dos diret√≥rios mais importantes do sistema, pois cont√©m todos os bin√°rios do usu√°rio, sua documenta√ß√£o, bibliotecas, arquivos de cabe√ßalho, etc‚Ä¶</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/bin</code></td>
      <td>Esta pasta cont√©m comandos ou scripts ou execut√°veis que podem ser executados para realizar uma tarefa.</td>
    </tr>
  </tbody>
</table>

<p>Um bom ponto de inicio √© explocar a pasta <code class="language-plaintext highlighter-rouge">/proc</code>. Esta pasta cont√©m todas as informa√ß√µes de todos os processos em execu√ß√£o. Cada processo tem um identificador √∫nico chamado <strong>PID</strong>, que significa <strong>Process IDentification</strong>. Vamos supor que temos um processo com PID <code class="language-plaintext highlighter-rouge">472</code>, podemos saber dele:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span>  /proc/472
attr  auxv  cgroup  cmdline  <span class="nb">comm  </span>cwd  environ  exe  fd  gid_map  limits  maps  mountinfo  mounts  mountstats  net  ns  oom_adj  oom_score_adj  root  schedstat  setgroups  smaps  <span class="nb">stat  </span>statm  status  task  uid_map
<span class="nv">$ </span><span class="nb">cat</span>  /proc/472/cmdline 
java-classpath/home/vepo/.vscode-server/extensions/adamvoss.vscode-languagetool-3.8.0/lib/languagetool-languageserver/build/install/languagetool-languageserver/lib/<span class="k">*</span>:/home/vepo/.vscode-server/extensions/adamvoss.vscode-languagetool-pt-3.8.0/lib/<span class="k">*</span>App54469
<span class="nb">ls</span> <span class="nt">-l</span> /proc/472/cwd
lrwxrwxrwx 1 vepo vepo 0 Mar  1 08:20 /proc/184/cwd -&gt; <span class="s1">'/mnt/c/Users/victoro/AppData/Local/Programs/Microsoft VS Code'</span>
</code></pre></div></div>

<hr />

<p><img src="/assets/images/pexels-dick-hoskins-6969512.jpg" alt="Pinguins" />
Foto de Dick Hoskins no Pexels</p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Linux" /><summary type="html"><![CDATA[No Linux, tudo √© um arquivo. Esse √© o primeiro ensinamento para voc√™ entender o funcionamento do Linux]]></summary></entry><entry><title type="html">Docker 101 - Tecnologias e Conceitos</title><link href="https://blog.vepo.dev/posts/docker-101-tecnologias-e-conceitos" rel="alternate" type="text/html" title="Docker 101 - Tecnologias e Conceitos" /><published>2020-10-20T00:00:00+00:00</published><updated>2023-09-25T20:01:00+00:00</updated><id>https://blog.vepo.dev/posts/00-00-00-docker-101</id><content type="html" xml:base="https://blog.vepo.dev/posts/docker-101-tecnologias-e-conceitos"><![CDATA[<p><em>Este material era para ser um curso de Docker. Mas eu n√£o tenho skills para grava√ß√£o/edi√ß√£o de v√≠deo. Minha inten√ß√£o aqui √© apresentar alguns conceitos b√°sicos de Docker.</em></p>

<h1 id="o-que-√©-docker">O que √© Docker?</h1>

<h2 id="introdu√ß√£o">Introdu√ß√£o</h2>

<p>Antes de iniciar qualquer curso sobre Docker, precisamos primeiro entender o que √© Docker? Essa pergunta pode n√£o ter uma resposta muito simples, visto que voc√™ pode ouvir esse termo em v√°rios contextos diferentes.</p>

<p>Para responder vamos levantar as seguintes perguntas?</p>
<ol>
  <li>Seria Docker uma empresa?</li>
  <li>Seria Docker um software?</li>
  <li>Seria Docker uma plataforma?</li>
  <li>Seria Docker uma tecnologia?</li>
</ol>

<h3 id="seria-docker-uma-empresa">Seria Docker uma empresa?</h3>

<p>SIM!</p>

<p>Sim Docker √© a empresa que criou o Docker. A <strong>Docker, Inc.</strong> prov√™ solu√ß√µes Enterprise e o Docker Hub.</p>

<h3 id="seria-docker-um-software">Seria Docker um Software?</h3>

<p>SIM!</p>

<p>Sim, voc√™ pode executar um <code class="language-plaintext highlighter-rouge">docker --version</code> em qualquer m√°quina com Docker instalado. Ele √© desenvolvido pela <strong>Docker, Inc.</strong> e pode ser instalado em qualquer dos mais comuns SOs do mercado.</p>

<h3 id="seria-docker-uma-plataforma">Seria Docker uma Plataforma?</h3>

<p>Podemos dizer que SIM!</p>

<p>N√£o sou t√£o assertivo nessa resposta porque o termo plataforma √© gen√©rico. Mas h√° uma s√©rie de componentes no Docker que nos permite chamar ele de plataforma. Voc√™ usa docker para criar imagens, que pode ser armazenadas em um Docker Registry, que ser√£o carregadas por um Gerenciador de Containers. H√° in√∫meros n√≥s nessa teia.</p>

<h3 id="seria-docker-uma-tecnologia">Seria Docker uma Tecnologia?</h3>

<p>Com certeza SIM!</p>

<p>O que a <strong>Docker, Inc.</strong> criou foi muito al√©m de um software. Ela utilizou v√°rios recursos j√° existente para criar um conceito a <em>containeriza√ß√£o</em>. Com isso se gerou uma Explos√£o Cambriana na industria. Novos conceitos e padr√µes surgir√£o depois dele.</p>

<p>Assim podemos dizer que a maneira de se gerenciar uma infra-estrutura em 2019 √© completamente diferente da maneira que se gerenciava em 2005. <strong>COMPLETAMENTE DIFERENTE!</strong></p>

<p>Depois do advento do Docker, a <strong>Docker, Inc.</strong> cedeu sua <em>core engine</em> para <a href="https://www.cncf.io/">Cloud Native Computing Foundation</a> sob o nome de <a href="https://github.com/containerd/containerd">containerd</a>. Voc√™ pode ver pela <a href="https://landscape.cncf.io/">CNCF Landscape</a> que o containerd √© uma caixinha em Container Runtime. A evolu√ß√£o da tecnologia n√£o √© mais controlada pela <strong>Docker, Inc.</strong>, mas por essa organiza√ß√£o que faz parte da Linux Foundation.</p>

<h2 id="a-tecnologia-docker">A tecnologia Docker</h2>

<p><em>‚ÄúNa natureza nada se cria, nada se perde, tudo se transforma‚Äù</em> Antoine-Laurent de Lavoisier</p>

<p>Essa frase de Lavoisier se adequa perfeitamente a projetos Open Source! Na verdade Docker n√£o criou nada novo e nem utilizou nenhuma tecnologia nova, mas a partir do que existia uma nova tecnologia foi criada.</p>

<h3 id="tecnologias-bases">Tecnologias Bases</h3>

<p>Docker se baseia em algumas tecnologias j√° existentes no Linux.</p>
<ul>
  <li><a href="https://pt.wikipedia.org/wiki/C%C3%B3pia_em_grava%C3%A7%C3%A3o">COW - Copy On Write</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a></li>
  <li><a href="https://pt.wikipedia.org/wiki/Iptables">iptables</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Linux_namespaces">Linux Namespaces</a></li>
</ul>

<h4 id="cow">COW</h4>

<p><em>Copy On Write</em> √© uma t√©cnica que permite a cria√ß√£o de uma estrutura de arquivos por camada. Cada camada altera a anterior e camadas podem ser compartilhadas com processos diferentes.</p>

<h4 id="cgroups">cgroups</h4>

<p><em>cgroups</em> √© uma feature do Linux que permite controlar o tanto de recurso (CPU, Mem√≥ria, I/O) que um processo pode utilizar.</p>

<h4 id="iptables">iptables</h4>

<p><em>iptables</em> √© um programa Linux que permite criar regras de redirecionamento de portas dentro do Linux.</p>

<h4 id="linux-namespaces">Linux Namespaces</h4>

<p><em>Linux Namespaces</em> permite o compartilhamento, e o isolamento, de recursos do SO dentro do Linux. Similar ao <em>cgroups</em>, mas se refere a outros tipos de recursos. Por exemplos: PIDs, nomes de arquivos, hostnames, etc‚Ä¶</p>

<h2 id="infraestrutura-imut√°vel">Infraestrutura Imut√°vel</h2>

<p>O termo <strong>Immutable Infrastructure</strong> vem em contraste ao que tinhamos antes do Docker, que √© a <strong>Mutable Infraestructure</strong>.</p>

<p>Em uma Infraestrutura mut√°vel, para fazer qualquer altera√ß√£o em ambientes, deve-se alterar as configura√ß√µes existente. Cada atualiza√ß√£o h√° um risco muito grande que deve ser minimizado por t√©cnicas como rollback, dry-run e backups. Cada update √© um risco, pois o novo deploy vem alterar o antigo.</p>

<p>Com a infraestrutura imut√°vel, o novo deploy vem em paralelo ao antigo. √â criado uma nova estrutura e o mesmo substitui o antigo. Assim, caso o novo apresente falhas, o antigo pode ser reutilizado.</p>

<h3 id="antes-do-docker">Antes do Docker</h3>

<p>Antes do Docker existir, para fazer a configura√ß√£o de um servi√ßo era preciso alguns passos:</p>

<ol>
  <li>Configurar um Servidor (Instalar Linux, Unix ou Windows)</li>
  <li>Instalar depend√™ncias (Apacha httpd, Java, Python, etc‚Ä¶)</li>
  <li>Configurar o Servidor de Aplica√ß√£o (JBoss, IIS)</li>
  <li>Fazer deploy da Aplica√ß√£o</li>
  <li>Monitorar o estado da Aplica√ß√£o (<a href="https://mmonit.com/monit/">monit</a>)</li>
</ol>

<p>Configurar um servidor era a tarefa mais f√°cil, o dif√≠cil era fazer atualiza√ß√µes ou gerenciar projetos legados. Muitas vezes duas aplica√ß√µes precisam de diferentes depend√™ncias para rodar. Ou tinha problema com o compartilhamento de recursos, duas aplica√ß√µes tentando escutar na mesma porta TCP.</p>

<p>Atualizar um servidor de produ√ß√£o, envolvia criar scripts para fazer diversas altera√ß√µes que nem sempre funcionavam na produ√ß√£o. Quando um erro acontecia na implementa√ß√£o‚Ä¶. ROLLBACK! O que tamb√©m era uma atividade complexa!</p>

<h3 id="poss√≠vel-solu√ß√£o">Poss√≠vel solu√ß√£o</h3>

<p>Uma boa e poss√≠vel solu√ß√£o era a cria√ß√£o de <strong>fotos</strong> (ou <em>snapshots</em>) do servidor. E se pud√©ssemos a partir de uma foto rodar um servidor? Ou voltar para uma vers√£o anterior a partir de uma foto? E se esse servidor fosse totalmente isolado? Posso executar duas vers√µes dele em paralelo?</p>

<h3 id="depois-do-docker">Depois do Docker</h3>

<p>Para executar um servidor:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull my-application:1.0.1
docker stop my-app
docker <span class="nb">rm </span>my-app
docker run <span class="nt">-name</span> my-app <span class="nt">-p</span> 8080:80 my-application:1.0.1
</code></pre></div></div>

<p>Com as 4 linhas acima, podemos atualizar uma aplica√ß√£o chamada <code class="language-plaintext highlighter-rouge">my-application</code> para vers√£o 1.0.1. Deu erro?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker stop my-app
docker <span class="nb">rm </span>my-app
docker run <span class="nt">-name</span> my-app <span class="nt">-p</span> 8080:80 my-application:1.0.0
</code></pre></div></div>

<p>Mais 3 linhas para fazer o rollback seguro!</p>

<h2 id="conceitos-b√°sicos">Conceitos B√°sicos</h2>

<p>Um pouco antes do Docker, uma das tecnologias da moda era a virtualiza√ß√£o. Mas em que consistia a virtualiza√ß√£o e porque a necessidade de containeriza√ß√£o</p>

<h3 id="virtualiza√ß√£o">Virtualiza√ß√£o</h3>

<p>Talvez voc√™ j√° tenha criado uma M√°quina Virtual. Se n√£o criou, gaste algum tempo baixando o VirtualBox e rodando algumas vers√µes de SOs diferentes dentro da sua m√°quina.</p>

<p>Quando falamos de virtualiza√ß√£o, estamos dividindo os recursos f√≠sicos da m√°quina com outras m√°quinas, que s√£o chamadas m√°quinas virtuais. Assim, podemos alocar 1 CPU, 2GB de mem√≥ria, etc‚Ä¶ Nessa m√°quina rodar√° um Sistema Operacional completo que n√£o compartilhar√° nenhum recurso com nenhum outro. Se esse SO n√£o utilizar todo o recurso alocado, este n√£o poder√° ser compartilhado.</p>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/q40xfw2qlei05qihud6m.png" alt="Virtual Machine" /></p>

<h3 id="containeriza√ß√£o">Containeriza√ß√£o</h3>

<p>Com containers todas as aplica√ß√µes compartilham o mesmo SO. O SO rodar√° a aplica√ß√£o isoladamente, criando e alocando qualquer recurso que o container necessitar.</p>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/fj02eotpgiggs4mqfrgo.png" alt="Containers" /></p>

<h4 id="vantagens">Vantagens</h4>

<p>Como a containeriza√ß√£o acontece no n√≠vel do Sistema Operacional, h√° uma s√©rie de vantagens:</p>
<ol>
  <li>Inicializa√ß√£o imediata. N√£o √© necess√°rio se inicializar o Sistema Operacional</li>
  <li>Compartilhamento de Recursos. Caso o container n√£o utilize Memoria ou CPU, esta fica dispon√≠vel para outro.</li>
  <li>√â poss√≠vel criar mais uma inst√¢ncia do mesmo container imediatamente.</li>
</ol>

<h2 id="docker-building-blocks">Docker Building Blocks</h2>

<p>Gosto do conceito de Building Blocks, quando me refiro a ele estou definindo elementos b√°sicos para algo. Assim em Docker podemos definir alguns building blocks.</p>

<p>Para o desenvolvimento de qualquer aplica√ß√£o Docker, √© necess√°rio entender o que s√£o cada um desses elementos.</p>

<ul>
  <li>Imagem
    <ul>
      <li>TAGs</li>
    </ul>
  </li>
  <li>Container
    <ul>
      <li>Volume</li>
      <li>Network</li>
    </ul>
  </li>
  <li>Registry</li>
  <li>Dockerfile</li>
</ul>

<h3 id="imagem">Imagem</h3>

<p>Uma Imagem √© uma foto do Container em seu momento inicial. Se formos comparar com os conceitos de m√°quinas virtuais, a Imagem seria um SNAPSHOT.</p>

<p>Uma Imagem √© usada para gerar um Container. Uma Imagem pode ser gerada a partir de um Container. Uma Imagem tem algumas propriedades que estendem o conceito de Snapshot, podemos definir qual comando a Imagem ir√° executar assim que ela iniciar.</p>

<p>Uma Imagem √© preferencialmente construida a partir de um Dockerfile.</p>

<h3 id="tags">TAGs</h3>

<p>Uma Imagem pode ter uma ou mais TAG associada. Cada imagem possui um nome, este nome pode estar associado a v√°rias TAGs.</p>

<p>Por exemplo, se formos criar um container do MariaDB, sabemos que o nome dele √© <code class="language-plaintext highlighter-rouge">mariadb</code>. Mas se referenciarmos apenas esse nome, ser√° baixada a image <code class="language-plaintext highlighter-rouge">mariadb:latest</code>, o que n√£o √© t√£o bom, visto que n√£o sabemos exatamente qual vers√£o ser√° executada. No caso do MariaDB, temos as seguintes TAGs:</p>
<ul>
  <li>10.4.10-bionic, 10.4-bionic, 10-bionic, bionic, 10.4.10, 10.4, 10, latest</li>
  <li>10.3.20-bionic, 10.3-bionic, 10.3.20, 10.3</li>
  <li>10.2.29-bionic, 10.2-bionic, 10.2.29, 10.2</li>
  <li>10.1.43-bionic, 10.1-bionic, 10.1.43, 10.1</li>
</ul>

<p>Uma boa op√ß√£o, seria utilizar <code class="language-plaintext highlighter-rouge">mariadb:10.4</code> para escolher a vers√£o <strong>10.4.10</strong> ou qualquer vers√£o futura com bug fixes.</p>

<h3 id="container">Container</h3>

<p>Um Container √© uma inst√¢ncia de uma aplica√ß√£o. Pode haver v√°rios Containers rodando com a partir da mesma Imagem. Ao se executar um Container √© preciso uma Imagem e um conjunto de informa√ß√µes:</p>
<ul>
  <li>Volumes</li>
  <li>Vari√°veis de Ambiente</li>
  <li>Portas</li>
  <li>etc‚Ä¶</li>
</ul>

<h3 id="volume">Volume</h3>

<p>O Sistema de Arquivo de um Container √© descart√°vel. Assim, ao se remover o container, todos os arquivos dele s√£o removidos. Um Volume √© um mapeamento entre um diret√≥rio da m√°quina hospedeira para o container. Usando COW, o diret√≥rio, ou arquivo, dentro container √© sobrescrito.</p>

<h3 id="network">Network</h3>

<p>Quando um container √© executado, pode pertencer a uma ou v√°rias Networks. Por padr√£o, ele pertence a Network Default. Para cada Network associada, ele ter√° um IP NAT associado.</p>

<p>Uma Network serve para criar uma VPC. Dois containers s√≥ podem se comunicar se pertencerem a mesma Network. Uma Network cont√©m DNS que resolve o IP atrav√©s do nome do container. Assim, se um container tentar acessar <code class="language-plaintext highlighter-rouge">container-1:8080</code> estar√° tentando acessar a porta <strong>8080</strong> do container com nome <strong>container-1</strong>.</p>

<h3 id="registry">Registry</h3>

<p>Um Registry √© um servidor web para armazenar uma Imagem. No ciclo de vida de uma Imagem, ela pode ser gerada ou baixada de um Registry.</p>

<p>O padr√£o √© o <a href="https://hub.docker.com/">Docker Hub</a>, sempre que poss√≠vel procure imagens l√°. No Docker Hub h√° imagens verificadas e n√£o verificadas. Procure usar as imagens verificadas, caso contr√°rio voc√™ pode estar correndo o risco de expor seus dados.</p>

<h3 id="dockerfile">Dockerfile</h3>

<p>Dockerfile √© o script de cria√ß√£o de uma Imagem. Uma Imagem deve ser construida atrav√©s de um script, e pode ser reconstruida em qualquer m√°quina.</p>

<h1 id="conclus√£o">Conclus√£o</h1>

<p>Docker pode parecer uma m√°gica, mas √© s√≥ o uso inteligente de tecnologias h√° muito tempo j√° existiam no Sistema Operacional Linux. Com o uso dessas tecnologias, podemos agora criar deploys completamente independentes dentro de um mesmo sistema operacional, usando a mesma infraestrutura.</p>

<p>Com Docker n√£o h√° o desperd√≠cio de recursos que existia com a Virtualiza√ß√£o. Agora os recursos podem ser alocados de forma mais inteligente.</p>

<hr />

<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/vpwhp0r7ampxf1jywqv8.jpg" alt="Navio carregado de Containers" /></p>

<p><a href="https://www.pexels.com/pt-br/foto/panorama-vista-paisagem-agua-3057963/">Foto de <em>Tom Fisk</em> no <em>Pexels</em>.</a></p>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Docker," /><category term="Containers," /><category term="DevOps," /><category term="Linux" /><summary type="html"><![CDATA[Quais s√£o os conceitos por tr√°s do Docker? Como o Docker consegue cria a m√°gica dos container no Linux?]]></summary></entry></feed>