<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://blog.vepo.dev/feed/by_tag/Profiling.xml" rel="self" type="application/atom+xml" /><link href="https://blog.vepo.dev/" rel="alternate" type="text/html" /><updated>2025-10-07T11:58:40+00:00</updated><id>https://blog.vepo.dev/feed/by_tag/Profiling.xml</id><title type="html">vepo</title><subtitle>Um repositório para todos os posts, palestras e tutoriais que já fiz. Java, Desenvolvimento de Software e reflexões sobre filosofia</subtitle><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><entry><title type="html">Como gerar flamegraph em aplicações Java</title><link href="https://blog.vepo.dev/posts/como-gerar-flamegraph-na-jvm" rel="alternate" type="text/html" title="Como gerar flamegraph em aplicações Java" /><published>2025-02-24T00:00:00+00:00</published><updated>2025-02-24T00:00:00+00:00</updated><id>https://blog.vepo.dev/posts/07-59-00-como-gerar-flamegraph-em-java</id><content type="html" xml:base="https://blog.vepo.dev/posts/como-gerar-flamegraph-na-jvm"><![CDATA[<div class="paragraph">
<p>Profiling tem sido uma das minhas principais atividades nos últimos meses. Como a aplicação que eu trabalho chegou a um bom grau de
maturidade onde há poucas funcionalidades a sere feitas e os bugs de produção são raros, hoje o principal esforço é melhorar o desempenho
e reduzir o uso de recursos. Por isso muito se pede para investigar o uso de CPU ou reduzir o tempo de processamento, o que me levou a
estudar com se dá o uso da CPU em produção e como funciona internamente o Kafka Stream.</p>
</div>
<div class="paragraph">
<p>É nesse contexto que resolvi finalmente investir um tempo para tentar gerar um diagrama muito interessante chamado Flamegraph. Caso você
ainda não o conheça, vamos primeiro falar sobre ele e depois mostrar como você pode gerar ele na sua aplicação Java facilmente!</p>
</div>
<div class="sect1">
<h2 id="_o-flamegraph">O Flamegraph</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O Flamegraph é um diagrama de monitoramento do uso da CPU <a href="https://www.brendangregg.com/flamegraphs.html">criado por Brendan Gregg</a> enquanto trabalhava
investigando problemas de performance no MySQL. Caso você queira ler a descrição do próprio criador, recomendo um post no site pessoal dele
<a href="https://www.brendangregg.com/flamegraphs.html">Flame Graphs</a> e um artigo na Communications da ACM chamado
<a href="https://cacm.acm.org/practice/the-flame-graph/">The Flame Graph</a>.</p>
</div>
<div id="cpu-mysql-updated" class="imageblock text-center text-center">
<div class="content">
<img src="/assets/images/cpu-mysql-updated.svg" alt="cpu mysql updated">
</div>
<div class="title">Figura 1. Flamegraph do uso de CPU do MySQL</div>
</div>
<div class="paragraph">
<p>A informação provida pelo flamegraph pode não parecer nova, ela já era provida por diversas ferramentas de profiling, mas a forma de interação
com o dado é mais interessante e dos dá mais informações sobre o que realmente acontece em tempo de execução. O VisualVM já provê informação semelhante,
mas a forma que ela é exibida, apesar de mais acurada, torna difícil visualizar o real uso da CPU. As ferramentas tradicionais agrupavam o uso de CPUs por
<em>threads</em>, como é visto na imagem abaixo. Conseguimos ver o uso de cada thread, o que de certa forma está parcialmente certo, mas dificulta a visualização
pois não vemos o dado real por CPU.</p>
</div>
<div id="visualvm-cpu-profiling" class="imageblock text-center text-center">
<div class="content">
<img src="/assets/images/java/visualvm-cpu-profiling.png" alt="visualvm cpu profiling">
</div>
<div class="title">Figura 2. Profiling da CPU pelo VisualVM.</div>
</div>
<div class="paragraph">
<p>Pode parecer estranho o que vou afirmar aqui, mas <em>threads</em> não existem! <em>Threads</em> são uma abstração do Sistema Operacional que facilitam o desenvolvimento de
software ao tratar o paralelismo como uma necessidade básica. Para entender melhor essa afirmação temos que entender que CPU é um recurso do nosso sistema que é
compartilhado entre as diversas <em>threads</em>. O que o flamegraph faz é mostrar todo o uso de CPU ignorando a existência de <em>threads</em> e isso ajuda muito na visualização!</p>
</div>
<div class="paragraph">
<p>Ao afirmar the <em>threads</em> não existem não estou dizendo que você não deva abolir <em>threads</em>, muito pelo contrário. Mas muitas vezes o processamento que está distribuído
em diversas <em>threads</em> é implementado pelo memso código. Vamos pensar no Kafka Stream! Nós normalmente implementamos uma pipeline que é única e será executada pela
<em>StreamThread</em>. Uma aplicação em produção terá diversas <em>StreamThread</em> executando o mesmo código! Quando olhamos para o VisualVM, temos que optar por uma dessas
<em>StreamThread</em>, enquanto ao olharmos para o flamegraph, vemos todas as <em>StreamThreads</em>!!!</p>
</div>
<div class="paragraph">
<p>Isso acontece porque ao se colocar todo o tempo de CPU em um único eixo, facilita-se a visualização. O flamegraph reduz o número de variáveis a se considerar para
se extrair um dado simples: tempo de CPU!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_como-extrair-o-flamegraph">Como extrair o Flamegraph?!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Se você fizer essa pesquisa no Google, já aviso que se deparará com diversos posts com muita informação antiga e pouca comparação. Verá posts onde só se usou
as ferramentas de performance do Linux, outros posts usando somente o Java Flight Recorder e outros posts usando agentes nativos que integram código Java com
as ferramentas nativas do Linux. Nesse post eu vou mostrar como exatrair de duas formas e depois comparar os resultados obtidos por ambas as formas.</p>
</div>
<div class="sect2">
<h3 id="_extraindo-usando-apenas-o-java-flight-recorder">Extraindo usando apenas o Java Flight Recorder!</h3>
<div class="paragraph">
<p>A primeira forma de se extrair o flamegraph é pegar as informações necessárias usando apenas ferramentas providas pela JVM e depois processar essa informações
criando o framegraph. A JVM já provê uma série de ferramentas de profiling que estão dentro do JDK. Se você não conhece o comando <code>jcmd</code> recomendo parar tudo que
está fazendo e dar uma olhada nele. <a href="https://docs.oracle.com/en/java/javase/21/docs/specs/man/jcmd.html">Na documentação do <code>jcmd</code></a> você consegue encontrar a
descrição de todo comandos que você pode executar só passando o PID da JVM que você quer olhar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #f8f8f8;"><code data-lang="bash"><span></span>&gt; jcmd MyProgram <span style="color: #008000">help</span> <span style="color: #666666">(</span>or <span style="color: #BA2121">&quot;jcmd 2125 help&quot;</span><span style="color: #666666">)</span>
<span style="color: #666666">2125</span>:
The following commands are available:
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
Thread.print
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.run_finalization
GC.run
VM.uptime
VM.flags
VM.system_properties
VM.command_line
VM.version
<span style="color: #008000">help</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Para gerar o flamegraph independentemente do método, você precisará do <a href="https://github.com/async-profiler/async-profiler"><strong>async-profiler</strong></a>. É uma excelente
ferramenta que gera o flamegraph a partir da gravação do Java Flight Recorder e também gera usando o agente nativo.</p>
</div>
<div class="paragraph">
<p>Nesse primeiro método vamos usar o Java Flight Recorder para gravar as informações de execução e depois gerar o flamegraph, para gravar as informações você
pode usar os dois métodos abaixos, ambos foram extraídos de scripts de profile que eu uso. No primeiro eu inicio a gravação, depois gero trafego (o qual foi
substituído pelo <code>sleep</code>) e por fim finalizo a gravação. A vantagem desse método é que você grava somente o periodo em que o trafego foi gerado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #f8f8f8;"><code data-lang="bash"><span></span><span style="color: #19177C">DURATION</span><span style="color: #666666">=1200</span> <span style="color: #408080; font-style: italic">## 2 minutos</span>
rm -f /tmp/recording.jfr                                            <span style="color: #408080; font-style: italic">## Apaga gravações antigas que podem ter sido feitas</span>
<span style="color: #19177C">NAME</span><span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">$(</span>cat /dev/urandom | tr -dc <span style="color: #BA2121">&#39;a-zA-Z&#39;</span> | fold -w <span style="color: #666666">15</span> | head -n <span style="color: #666666">1</span><span style="color: #008000; font-weight: bold">)</span> <span style="color: #408080; font-style: italic">## Gera um nome aleatório para evitar conflitos</span>
<span style="color: #19177C">PID</span><span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">$(</span>ps -a | grep java | awk <span style="color: #BA2121">&#39;{print $1}&#39;</span><span style="color: #008000; font-weight: bold">)</span>                         <span style="color: #408080; font-style: italic">## Acessa número do processo em execução se rodando em docker/k8s</span>
jcmd <span style="color: #19177C">$PID</span> JFR.start <span style="color: #19177C">name</span><span style="color: #666666">=</span><span style="color: #19177C">$NAME</span> <span style="color: #19177C">settings</span><span style="color: #666666">=</span>profile                     <span style="color: #408080; font-style: italic">## Inicia gravação</span>
sleep <span style="color: #19177C">$DURATION</span>
jcmd <span style="color: #19177C">$PID</span> JFR.stop <span style="color: #19177C">name</span><span style="color: #666666">=</span><span style="color: #19177C">$NAME</span> <span style="color: #19177C">filename</span><span style="color: #666666">=</span>/tmp/recording.jfr</code></pre>
</div>
</div>
<div class="paragraph">
<p>No segundo método, o <code>jcmd</code> é executado de forma asincrona usando os parâmetros <code>duration</code> e <code>delay</code>. Esse método é bom para capturar informações
do ambiente de produção sem precisar reiniciar o servidor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #f8f8f8;"><code data-lang="bash"><span></span><span style="color: #19177C">DELAY</span><span style="color: #666666">=</span>10m
<span style="color: #19177C">DURATION</span><span style="color: #666666">=</span>20m
rm -f /tmp/recording.jfr                                                        <span style="color: #408080; font-style: italic">## Apaga gravações antigas que podem ter sido feitas</span>
<span style="color: #19177C">NAME</span><span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">$(</span>cat /dev/urandom | tr -dc <span style="color: #BA2121">&#39;a-zA-Z&#39;</span> | fold -w <span style="color: #666666">15</span> | head -n <span style="color: #666666">1</span><span style="color: #008000; font-weight: bold">)</span>             <span style="color: #408080; font-style: italic">## Gera um nome aleatório para evitar conflitos</span>
<span style="color: #19177C">PID</span><span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">$(</span>ps -a | grep java | awk <span style="color: #BA2121">&#39;{print $1}&#39;</span><span style="color: #008000; font-weight: bold">)</span>                                     <span style="color: #408080; font-style: italic">## Acessa número do processo em execução se rodando em docker/k8s</span>
jcmd <span style="color: #19177C">$PID</span> JFR.start <span style="color: #19177C">name</span><span style="color: #666666">=</span><span style="color: #19177C">$NAME</span> <span style="color: #19177C">settings</span><span style="color: #666666">=</span>profile <span style="color: #19177C">delay</span><span style="color: #666666">=</span><span style="color: #19177C">$DELAY</span> <span style="color: #19177C">duration</span><span style="color: #666666">=</span><span style="color: #19177C">$DURATION</span> <span style="color: #408080; font-style: italic">## Inicia gravação</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depois de capturado o arquivo <code>recording.jfr</code>, você precisa gerar o flamegraph usando o
<a href="https://github.com/async-profiler/async-profiler/releases/download/v3.0/converter.jar">converter</a> do async-profile.
Para isso execute o comando abaixo e <em>voilà</em>!!! Você tem uma pagina HTML pura para colocar onde quiser. Eu coloquei ela como
artefato dos testes de carga da aplicação.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #f8f8f8;"><code data-lang="bash"><span></span>java -cp converter.jar jfr2flame --dot --total --alloc --classify --title <span style="color: #BA2121">&quot;My CPU Profile&quot;</span> /tmp/recording.jfr /tmp/flamegraph.html</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 1. Aviso</div>
<div class="content">
<div class="paragraph">
<p>O tamanho do arquivo gerado será proporcional ao tempo de gravação, por isso garanta que há espaço em disco
e use sabiamente a duração (<em>duration</em>) e o atrado (<em>delay</em>) para capturar o melhor momento da execução.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_extraindo-usando-agente-nativo">Extraindo usando agente nativo</h3>
<div class="paragraph">
<p>A grande desvantagem de usar somente o Java Flight Recorder é que algumas informações sobre a execução nativa é perdida. Ao migrar para
a execução usando o agente nativo consegui, por exemplo, identificar alguns trechos de código que usavam <strong>exceptions para controle de fluxo
o que pode ser um grande problema de desempenho</strong>.</p>
</div>
<div class="paragraph">
<p>Para executar usando agente natvo com o <a href="https://github.com/async-profiler/async-profiler"><strong>async-profiler</strong></a>, basta fazer o download da buil,
copiar para o ambiente de execução e depois executar o comando <code>asprof</code> como mostrado abaixo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #f8f8f8;"><code data-lang="bash"><span></span><span style="color: #19177C">DURATION</span><span style="color: #666666">=1200</span>
<span style="color: #19177C">PID</span><span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">$(</span>ps -a | grep java | awk <span style="color: #BA2121">&#39;{print $1}&#39;</span><span style="color: #008000; font-weight: bold">)</span>                                                <span style="color: #408080; font-style: italic">## Acessa número do processo em execução se rodando em docker/k8s</span>
/tmp/async-profiler-3.0-linux-x64/bin; ./asprof -d <span style="color: #19177C">$DURATION</span> -f /tmp/flamegraph.html <span style="color: #19177C">$PID</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A desvantagem desse método é que você alterou o ambiente em que o seu software está rodando. Isso não tem problemas na grande maioria dos casos,
mas não é muito bem visto para ambientes de produção.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recomendações">Recomendações</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Eu recomendo que você use constantemente ferramentas de profiling para visualizar o que está acontecendo no seu software. Existe uma máxima na área
de adminstração que pode ser aplicada em qualquer lugar das nossa vidas "o que não pode ser medido, não pode ser gerenciado", logo é importante para
você saber como está o tempo de execução do seu software.</p>
</div>
<div class="paragraph">
<p>A segunda recomendação é você, caso precise melhorar o desempenho do seu software, olhar primeiro para o local que mais impacta o desemepenho. Ganho
de performance é proprocional ao tempo de desempenho, por isso só investa tempo onde há mais indicios de tempo gasto.</p>
</div>
<div class="paragraph">
<p>Uma outra recomendação é que você pode criar ferramentas de análise de desempenho automatizadas usando ferramentas de DevOps. Quem sabe criar uma task no
Jenkins que extrai o FlameGraph e depois salva para análises futuras? Ou salvar essa página para cada nova versão e comparar como o desempenho tem evoluido?</p>
</div>
<div class="paragraph">
<p>Eu espero ter ajuda com alguma coisa!</p>
</div>
</div>
</div>]]></content><author><name>{&quot;twitter&quot;=&gt;&quot;vepo&quot;, &quot;linkedin&quot;=&gt;&quot;https://www.linkedin.com/in/victorosorio/&quot;, &quot;picture&quot;=&gt;&quot;/assets/images/me.avif&quot;}</name></author><category term="Java" /><category term="Observabilidade" /><category term="Profiling" /><category term="Tuning" /><category term="JVM" /><category term="Flamegraph" /><summary type="html"><![CDATA[Já ouviu falar de Flamegraph? E quais ferramentas de profiling você usa? Nesse post vamos falar de como podemos ver qual é o uso da CPU em produção de uma aplicação rodando na JVM usando ferramentas simples e um ótimo formato de visualização.]]></summary></entry></feed>