---
title: 
published: false
description: |
    
tags: [Ciência da Computação, Bases de Dados, SQL, Modelo Entidade-Relacional, Modelagem de Dados]
cover_image: /assets/images/capas/disquete-100-42.jpg
series: Introdução a Bases de Dados
permalink: /posts/mapeamento-entidade-relacional
publish_date: 2025-12-26 11:46:00 +0300
---

No post anterior, projetamos um modelo entidade-relacional (ER) para representar os dados de funcionários de uma empresa. Nele definimos quatro tabelas para representar as entidades `Funcionário`, `Endereço`, `Contato` e `Experiência Anterior`, além dos relacionamentos entre elas. Talvez vocë tenha se perguntado se o modelo não poderia ser feito de outra forma, ou mais simples ou, quem sabe, mais complexo. SIM! Modelagem de dados depende de muitos fatores e pode ser feita de várias formas diferentes, mas há algumas boas práticas que possuem implicações na quantidade e na qualidade dos dados armazenados. Para entender melhor essas boas práticas, vamos falar de normalização de dados.

.Script SQL para criação das tabelas do modelo entidade-relacional de funcionários
[source,sql]
----
CREATE TABLE tb_funcionarios_experiencias_anterior (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    empresa         VARCHAR(100),
    cargo           VARCHAR(100),
    data_inicio     DATE,
    data_fim        DATE
);

CREATE TABLE tb_funcionarios (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    nome            VARCHAR(100),
    sobrenome       VARCHAR(100),
    CPF             VARCHAR(11) UNIQUE,
    data_nascimento DATE,
    cargo           VARCHAR(100),   -- Cargo do funcionário
    salario         DECIMAL(10,2),  -- Salário do funcionário
    gestor_id       BIGINT,         -- Chave Estrangeira para tb_funcionarios (autorreferência)
    gestao          BOOLEAN,        -- Indica se o funcionário está em uma posição de gestão
    experiencia_anterior_id BIGINT, -- Chave Estrangeira para tb_funcionarios_experiencias_anterior
    FOREIGN KEY (experiencia_anterior_id) REFERENCES tb_funcionarios_experiencias_anterior(id),
    FOREIGN KEY (gestor_id) REFERENCES tb_funcionarios(id),
    UNIQUE (experiencia_anterior_id)  -- Garante o relacionamento um-para-um
);
CREATE TABLE tb_funcionarios_enderecos (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    funcionario_id  BIGINT NOT NULL,       -- Chave Estrangeira para tb_funcionarios
    rua             VARCHAR(200),
    cidade          VARCHAR(100),
    estado          VARCHAR(100),
    cep             VARCHAR(20),
    FOREIGN KEY (funcionario_id) REFERENCES tb_funcionarios(id) -- Chave Estrangeira
);

CREATE TABLE tb_funcionarios_contatos (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    funcionario_id  BIGINT NOT NULL, -- Chave Estrangeira para tb_funcionarios
    tipo            VARCHAR(50),     -- Ex: 'telefone', 'email'
    valor           VARCHAR(100),    -- Ex: número de telefone ou endereço de email
    FOREIGN KEY (funcionario_id) REFERENCES tb_funcionarios(id) -- Chave Estrangeira
);
----

== Quais problemas a normalização de dados busca resolver?

Para entender a importância da normalização de dados, precisamos primeiro entender alguns problemas comuns que podem ocorrer em bancos de dados mal projetados. Esses problemas incluem:

* *Redundância de Dados*: Quando os mesmos dados são armazenados em múltiplos lugares, o que pode levar a inconsistências e desperdício de espaço.
* *Inconsistência de Dados*: Quando diferentes versões dos mesmos dados existem em diferentes lugares, levando a confusão e erros.
* *Dificuldade de Manutenção*: Quando a estrutura do banco de dados é complexa demais, tornando difícil adicionar, atualizar ou excluir dados sem afetar outras partes do banco de dados.
* *Complexidade nas Consultas*: Quando a estrutura do banco de dados torna as consultas SQL mais complicadas do que o necessário, dificultando a recuperação eficiente dos dados.



Sistemas computacionais precisam ser compreensíveis, fáceis de manter e eficientes. A normalização de dados é uma técnica que ajuda a alcançar esses objetivos. Se olharmos para o modelo ER que projetamos, podemos identificar algumas áreas onde a normalização pode ser aplicada para melhorar a estrutura do banco de dados.

1. *Cargo do Funcionário*: No modelo atual, o cargo do funcionário está armazenado na tabela `tb_funcionarios` e isso não garante que cargos iguais sejam representados de forma consistente. Se um cargo for atualizado, todas as ocorrências desse cargo precisam ser atualizadas manualmente, o que pode levar a inconsistências.
2. *Salário do Funcionário*: Similar ao cargo, o salário do funcionário está armazenado diretamente na tabela `tb_funcionarios`. Se houver uma política de aumento salarial que afete múltiplos funcionários ou cargos, isso pode levar a redundância e inconsistência.

Para resolver esses problemas, e tantos outros similares, precisamos identificar dentro do nosso modelo de dados quais são as informações redundantes e que possuem dependências funcionais. No caso acima, podemos identificar claramente que o cargo do funcionário e o salário possuem uma dependência funcional, ou seja, o salário depende do cargo. 

== O que é dependência funcional?

A dependência funcional é um conceito da álgebra relacional que descreve a relação entre subconjuntos de atributos de uma relação que podem ser determinados por outros atributos. Em termos simples, dizemos que um atributo B é funcionalmente dependente de um atributo A se, para cada valor de A, existe exatamente um valor correspondente de B. Por exemplo, em um banco de dados de funcionários, o salário pode ser funcionalmente dependente do cargo do funcionário e vice-versa.

Matematicamente, dizemos que `X → Y` (X determina Y) se, para cada valor de `X`, existe exatamente um valor correspondente de `Y`. No nosso exemplo, podemos dizer que *Cargo → Salário*. 

Através da dependência funcional, podemos definir os conceitos de chave, superchave, atributo primo e atributo não-primo, que são fundamentais para a normalização de dados.

=== O que é uma chave em um banco de dados?

Uma chave é um conjunto de atributos que identifica unicamente uma tupla (linha) em uma relação (tabela). Para que o conjunto de atributos seja considerado uma chave, ele deve satisfazer duas propriedades principais:

* *Unicidade*: Nenhuma duas tuplas na relação podem ter os mesmos valores para os atributos da chave.
* *Minimalidade*: Nenhum subconjunto dos atributos da chave pode satisfazer a propriedade de unicidade.

Exemplo? Considere a tabela `tb_funcionarios` que possui os atributos `id`, `nome`, `sobrenome` e `CPF`. A chave primária poderia ser o atributo `id`, pois ele identifica unicamente cada funcionário na tabela. Outra possível chave seria o atributo `CPF`, que também é único para cada funcionário.

Já `nome` e `sobrenome` não podem ser considerados chaves, pois podem haver funcionários com o mesmo nome e sobrenome.

=== O que é uma superchave?

Uma superchave é um subconjunto de atributos que identifica unicamente uma tupla em uma relação, mas pode conter atributos adicionais que não são necessários para a identificação única. Em outras palavras, uma superchave pode ser uma chave, mas também pode incluir atributos extras que não são essenciais para a unicidade.

Exemplo? Considere a tabela `tb_funcionarios` que possui os atributos `id`, `nome`, `sobrenome` e `CPF`. O atributo `CPF` é uma superchave, pois identifica unicamente cada funcionário na tabela. No entanto, o conjunto de atributos `{CPF, nome, sobrenome}` também é uma superchave, pois identifica unicamente cada funcionário na tabela, mesmo que `nome` e `sobrenome` não sejam necessários para essa identificação.

Todo atributo que compõe uma chave é chamado de *atributo primo*, enquanto os atributos que não fazem parte de nenhuma chave são chamados de *atributos não-primos*.

== Qual é a relação entre normalização e dependência funcional?

A normalização de dados é um processo que utiliza o conceito de dependência funcional para organizar os dados em um banco de dados de forma eficiente. O objetivo da normalização é eliminar a redundância e garantir a integridade dos dados, dividindo as tabelas em estruturas menores e mais gerenciáveis. Isso é feito através de várias formas normais (normal forms), cada uma com suas próprias regras e critérios baseados em dependências funcionais.

== Quais são as formas normais existentes?

As formas normais existentes são: 

* *Primeira Forma Normal* (1NF): Garante que todos os atributos de uma tabela sejam atômicos, ou seja, indivisíveis. Isso significa que cada campo deve conter apenas um valor e não uma lista ou conjunto de valores. Naturalmente, todas as tabelas já estão na 1NF, exceto quando há problemas na modelagem.
* *Segunda Forma Normal* (2NF): Garante que todos os atributos não-chave sejam totalmente dependentes da chave primária. Isso significa que não deve haver dependências parciais, onde um atributo depende apenas de parte da chave primária.
* *Terceira Forma Normal* (3NF): Garante que todos os atributos não-chave sejam diretamente dependentes da chave primária e não de outros atributos não-chave. Isso elimina dependências transitivas. 
* *Forma Normal de Boyce-Codd* (BCNF): Uma versão mais rigorosa da 3NF, onde todos os atributos dependem apenas da chave.
* *Quarta Forma Normal* (4NF): Garante que não haja dependências multivaloradas, onde um atributo pode ter múltiplos valores independentes de outro atributo.
* *Quinta Forma Normal* (5NF): Garante que todas as dependências de junção sejam eliminadas, o que significa que uma tabela não pode ser dividida em tabelas menores sem perder informações.

=== Como violar a Primeira Forma Normal (1NF)?

// 1. Using row order to convey information is not permitted.
// 2. Mixing data types within the same column is not permitted.
// 3. Having a table without a primary key is not permitted.
// 4. Repeating groups are not permitted.

Para violar a 1NF, uma tabela deve conter atributos que não são atômicos

.A tabela abaixo viola a 1NF porque o atributo `telefone_1`, `telefone_2` e `telefone_3` formam um conjunto de valores não atômicos.
[source,sql]
----
CREATE TABLE tb_funcionarios (
    id INT PRIMARY KEY,
    nome VARCHAR(100),
    sobrenome VARCHAR(100),
    cpf VARCHAR(11),
    telefone_1 VARCHAR(15),
    telefone_2 VARCHAR(15),
    telefone_3 VARCHAR(15),
);
----

.A tabela abaixo viola a 1NF porque o atributo `telefones` não é atômico, ou seja, ele armazena múltiplos valores em um único campo.
[source,sql]
----
CREATE TABLE tb_funcionarios (
    id INT PRIMARY KEY,
    nome VARCHAR(100),
    sobrenome VARCHAR(100),
    cpf VARCHAR(11),
    telefone_1 VARCHAR(15),
    telefone_2 VARCHAR(15),
    telefone_3 VARCHAR(15),
);
----

=== Como violar a Segunda Forma Normal (2NF)?

// Deletion anomaly
// Update anomaly
// Insertion anomaly

Como os atributos não-chave se relacionam com a chave primária? Para violar a 2NF, uma tabela deve conter atributos não-chave que dependem apenas de parte da chave primária.

=== Como violar a Terceira Forma Normal (3NF)?

=== Como violar a Forma Normal de Boyce-Codd (BCNF)?

=== Como violar a Quarta Forma Normal (4NF)?

=== Como violar a Quinta Forma Normal (5NF)?