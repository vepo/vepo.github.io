---
title: Imersão SQL
published: false
description: |
    
tags: [Ciência da Computação, Bases de Dados, SQL, Formas Normais, Dependência Funcional, Modelagem de Dados]
cover_image: /assets/images/capas/disquete-100-42.jpg
series: Introdução a Bases de Dados
permalink: /posts/imersao-sql
publish_date: 2026-01-05 12:24:00 +0300
---

Agora que sabemos o que são bancos de dados, como são estruturados internamentes e como modelar um banco de dados, vamos entrar a fundo na linguagem SQL, mostrando toda a potencialidade dela.

== Como e quando usar SQL?

SQL é a linguagem de comunicação com bases de dados relacionais. Quando vamos usar um banco de dados relacional, é quase certo que podemos usar uma linguagem em comum com ele para consultar, adicionar ou remover dados, mas o SQL possui outras funcionalidades além do acesso ao dados. Através do SQL é possível gerenciar transações e permissões, assuntos ainda não cobertos.

=== Então todo banco relacional implementa SQL?

Sim e não. Na verdade quase todo banco considerado relacional dá algum suporte a linguagem SQL, mas isso não significa que ele implementa todas as funcionalidade. É preciso lembrar que SQL é um padrão em constante evolução e que nem todas as funcionalidades fazem sentido para todos os bancos.

Alguns bancos também podem optar por fazer adaptações, ou extensões, da linguagem, por isso é importante conhecer a documentação do banco que se está usando. Aqui usaremos o PostgreSQL como exemplo, então, caso queira um tutorial, recomendo seguir o do https://www.w3schools.com/sql/default.asp[W3Schools] ou a https://www.postgresql.org/docs/18/index.html[documentação oficial do PostgreSQL].

Para melhor didática vamos começar a configurar o ambiente do zero criando e configurando uma base de dados. Então acessa o repositório https://github.com/vepo/sql-database-tutorial[github.com/vepo/sql-database-tutorial] e segue pelo tópico https://github.com/vepo/sql-database-tutorial/blob/main/docs/03-sql-tutorial.md[3. SQL Tutorial: Database Navigation and Querying].

=== Como é o modelo de dados que estamos trabalhando?

Antes de começarmos, precisamos brevemente entender o modelo de dados que vamos usar. Vamos usar uma base de dados que mapeia a estrutura de uma empresa. Quais funcionários existem, quais departamentos eles estão alocados, quais são os orçamentos alocados e quais projetos existem. Na imagem abaixo, está o diagrama de entidades e mais abaixo o script usando para criação das tabelas.

// XLJHRgCm47ptLwnuQNCwf3HINwggQfIalUWkKPLozuesu0jEmKQswGcL_Fijf0c69gs4GFREBZFZWNjZKTiYIza5J5IMOsHXYXRNQ3WyHmdF46Ohc0hSQCmOuz8AMmBFybILd1juOm3VZkjGn703ysKmUwIkszkddtTt1F1zklqLsjXGOiO9ycUyclmOhowlXmE2BPSDBCKl0CH6f4xnQdYiqkDtWyaJ9Tq1e-60TXEXUHYZhIlJSJ1hPsxLEYHDAJyzbn0npycZZAJtvJtivHbCKPVrvDbalXZ_elxleth0P5_FKEA6wpFTaUR4AmxHKZMOBsRFmNZnn7P7izlt7-m-pyWrt47rJEtgIrM4LYZP0r1bNSGRRbrXroJi2qKjyLohBO-EhD-Ndr4-G7fyHns-JMJTmwoJ8UFUpbdkr6uBqqt8uQns7n8UzaISItejlHLpLcmNrcZMAkq5liwhAhG9_odzmcD7GoE1I5x0Wz9SR2Iyy18qJvi3D8d83Mk_pLtb-rNbVAmtuBsVdDU3gQeJCmAsIu-vfLD3dQITc5_LyzzEE4gTjK8JAkcnu-vdy0HDYCQGy8QCLpknG5dwLldqvguL89Lj5WIw319XeBveh21FroNOXCEsa56JVVhbqJ5qd0HSgrS-e6x7guQRIsbFXoPQvS6hm8_46RkdUD8_zZy0

image::databases/company_db_diagram.png[]

[source,sql]
----
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20),
    hire_date DATE NOT NULL,
    job_title VARCHAR(100) NOT NULL,
    department_id INT,
    salary DECIMAL(10,2) CHECK (salary >= 0),
    manager_id INT REFERENCES employees(employee_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Departments table
CREATE TABLE departments (
    department_id SERIAL PRIMARY KEY,
    department_name VARCHAR(100) NOT NULL,
    location VARCHAR(100),
    budget DECIMAL(15,2),
    manager_id INT REFERENCES employees(employee_id)
);

-- Projects table
CREATE TABLE projects (
    project_id SERIAL PRIMARY KEY,
    project_name VARCHAR(200) NOT NULL,
    start_date DATE,
    end_date DATE,
    budget DECIMAL(15,2),
    status VARCHAR(20) CHECK (status IN ('Planning', 'Active', 'On Hold', 'Completed', 'Cancelled'))
);

-- Employee projects (junction table)
CREATE TABLE employee_projects (
    employee_id INT REFERENCES employees(employee_id),
    project_id INT REFERENCES projects(project_id),
    role VARCHAR(50),
    hours_worked DECIMAL(5,2),
    PRIMARY KEY (employee_id, project_id)
);
----

É importante notar a cardinalidade de alguns elementos. Um funcionário trabalha para um departamento que possui um gerente. Cada funcionário também possui um gerente, que pode não ser o mesmo do departamento. Cada funcionátrio trabalha em vários projetos, possuindo papeis diferentes. Os projetos não são ligados aos departamentos, podendo ter funcionários de diversos departamentos.

O modelo é propositadamente complexo para possibilitar a elaborações de _queries_ com junções e _subqueires_. A pessoa que deseja escrever queries tem que estar ciente da cardinalidade das relações para que não sejam extraídas informações inverídicas. 

Já que conhecemos o modelo de dados, podemos partir para a interação com ele.

=== Como conectar com uma base de dados?

Todo desenvolvedor comumente se refere aos *Sistemas de Gerenciamento de Banco de Dados* (SGDB, ou DBMS de _Database Management System_) como base de dados ou databases, mas uma instância do PostgreSQL, ou de qualquer outra base de dados, pode gerenciar diversas base de dados em paralelo.

Normalmente quando nossa aplicação conecta com um banco de dados, precisamos saber o _hostname_, a porta e o banco de dados que queremos nos conectar. Mas como vamos conectar localmente usando as ferramentas de linha de comando, não precisamos dessas informações. Mas precisamos selecionar, dentro do programa, qual base de dados queremos usar.

Todo SGDB pode conter mais de uma base de dados e cada base de dados pode conter mais de uma tabela, tanto que existe uma série de comandos para criar a apagar bases de dados, que são comuns na linguagem SQL. Mas a forma como selecionamos qual base estamos usando varia de acordo com a base em uso. Para PostgreSQL, se usa `\c company_db`, já no https://dev.mysql.com/doc/refman/8.4/en/database-use.html[MySQL] e no https://learn.microsoft.com/en-us/sql/t-sql/language-elements/use-transact-sql?view=sql-server-ver17[SQL Server] se usa `USE company_db`.

.Comando SQL para criar uma base de dados
[source,sql]
----
CREATE DATABASE company_db; -- Cria um banco de dados chamado 'company_db'
----

.Comando SQL para destruir uma base de dados
[source,sql]
----
DROP DATABASE company_db; -- Destruir um banco de dados chamado 'company_db'
----

.Comando SQL para usar uma base de dados no PostgreSQL
[source,sql]
----
\c company_db -- Acessando um banco de dados chamado 'company_db'
----

Então agora que conectamos a nossa base de dados dentro do SGDB, vamos criar _queries_?

=== Como escrever consultas (_queries_)?

É preciso lembrar que qualquer consulta a uma base de dados SQL envolve o conceito de Algébra Relacional já discutido anteriormente. Consultas são feitas usando o comando `SELECT` que sempre é construído através do padrão `SELECT <atributos> FROM <relação>`, onde *atributos* é o conjunto de colunas que desejamos selecionar e *relação* é as tabelas ou qualquer outra consulta. Dessa forma a consulta mais simples que podemos fazer é listar todos as linhas e todas as colunas de uma tabela, conforme feito abaixo com a tabela `departments`.

[source,sql]
----
SELECT * FROM departments; -- '*' significa a seleção de todos os atributos presentes na relação
----

Uma consulta, em muitas situações, pode não ser eficiente, porque é bom lembrar que ao enviar uma consulta para um SGDB, este terá que consultar o disco para encontrar todas as linhas e todos os atributos e enviar de volta para o cliente. Essa operação pode ser bastante demorada devido ao tempo de acesso ao disco, e ao tempo de envio dessa informação entre os processos. Por isso é muito incomum fazer esse tipo de requisição em sistemas.

==== Consultas com Seleção e Projeção

Em sistemas, praticamente todas as consultas passam pelas operações de seleção e projeção para se evitar o acesso desncessário ao dados. Isso é feito para que não se adicione latência a operação sendo realizada e para que o sistema não use memória desnecessária.

Vamos supor que eu precise saber o identificador e a cidades em que está localizado um determinado departamento, ignorando o budget e o gerente do mesmo. Ao invés de selecionar todos os departamentos, posso fazer uma consulta específica como a consulta abaixo.

[source,sql]
----
SELECT department_id, location FROM departments WHERE department_name = 'Sales'; 
----

Na consulta acima, extendemos nossa consulta inicial para fazer a projeção através do conjunto de atributos 'department_id, location' da relação que contêm todos os elementos da tabela `departments` com o nome Sales, ou seja, pegamos a tabela `departments` e aplicamos uma seleção.

Em toda consulta, podemos adicionar a declaração `WHERE` para filtrar, durante a leitura, as linhas que serão consideradas parte da relação. A declaração `WHERE` será composta por um predicado booleano que ao ser aplicado em cada linha define se a mesma pode ser adicionada ou não na relação. Esse predicado pode ter outras consultas, como no caso abaixo.

.Consulta que lista todos os departamentos que não possuem funcionários alocados.
[source,sql]
----
SELECT department_id, 
       location 

FROM departments 

WHERE department_id NOT IN (SELECT DISTINCT department_id 
                            FROM employees
                            WHERE department_id IS NOT NULL
                           );
----

==== Consultas com Junção

Outra funcionalidade importantíssima do SQL é a possibilidade de fazer junções entre tabelas. No nosso modelo podemos identificar diversas tabelas com relacionamentos e todos esses relacionamentos podem ser escritos na forma de junções. Por exemplo, se desejarmos saber qual é o custo de um departamento e o valor alocado para mesmo, podem ser tentado a fazer esse calculo usando as tabelas `departments`, `employees`, `employee_projects` e `projects`.

.Consulta que faz uma agregação por departamento do gasto pessoal. O valor calculado está incorreto.
[source,sql]
----
SELECT 
    dep.department_id, 
    dep.department_name, 
    dep.budget, 
    SUM(prj.budget) as project_budget, 
    SUM(emp.salary) as employee_salaries
FROM departments dep 
LEFT JOIN employees emp ON emp.department_id = dep.department_id 
LEFT JOIN employee_projects emp_prj ON emp_prj.employee_id = emp.employee_id 
LEFT JOIN projects prj ON prj.project_id = emp_prj.project_id 
GROUP BY dep.department_id
ORDER BY dep.department_name ASC;
----

.Porque o valor calculado está incorreto?
[sidebar]
O valor calculado na consulta acima está incorreto porque a junção entre as tabelas `employees`, `employee_projects` e `projects` cria uma relação com cardinalidade maior do que a original. Isso acontece porque um funcionário pode trabalhar em vários projetos, então ao fazer a junção, cada linha do funcionário é replicada para cada projeto que ele trabalha. Isso faz com que o salário do funcionário seja somado várias vezes, uma para cada projeto, resultando em um valor total incorreto.

Na consulta acima foi utilizado três novas declarações que quero explicar aqui. `JOIN`, `GROUP BY` e `ORDER BY`. 

Os `JOIN` são usados para fazer junções entre tabelas, ou seja, criar uma nova relação a partir de duas outras. No exemplo acima, foi usado o `LEFT JOIN` que cria uma nova relação com todas as linhas da tabela da esquerda e as linhas da tabela da direita que satisfazem a condição dada. Caso não existam linhas na tabela da direita que satisfaçam a condição, então os atributos dessas linhas serão nulos. Existem outros tipos de `JOIN`, que veremos a seguir.

O `GROUP BY` é usado para agrupar linhas que possuem o mesmo valor em determinados atributos. No exemplo acima, todas as linhas que possuem o mesmo `department_id` são agrupadas em uma única linha. Isso é útil quando queremos fazer agregações, como somas ou médias, sobre grupos de linhas. `GROUP BY` não é obrigatório em todas as consultas, mas é necessário quando a cardinalidade da relação resulta em múltiplas linhas para o mesmo valor de um atributo que está sendo selecionado e podemos já requerer uma agregação dos dados, evitando processamento desnecessário no cliente.

O `ORDER BY` é usado para ordenar as linhas da relação resultante de acordo com os valores de um ou mais atributos. No exemplo acima, as linhas são ordenadas pelo atributo `department_name` em ordem crescente (`ASC`). Também é possível ordenar em ordem decrescente usando a palavra-chave `DESC`. Importante lembrar que o `ORDER BY` pode ser aplicado mesmo quando o `JOIN` ou o `GROUP BY` não são usados, foi usado aqui como demonstrativo apenas, ele pode ser usando em qualquer consulta.

===== Tipos de Junção

Existem diversos tipos de junção que podem ser usados em SQL, cada um com suas características e usos específicos. Os principais tipos de junção são:

* `INNER JOIN`: Retorna apenas as linhas que possuem correspondência em ambas as tabelas. Ou seja, somente as linhas que satisfazem a condição de junção são incluídas na relação resultante.
* `LEFT JOIN` (ou `LEFT OUTER JOIN`): Retorna todas as linhas da tabela da esquerda e as linhas correspondentes da tabela da direita. Se não houver correspondência, os atributos da tabela da direita serão nulos.
* `RIGHT JOIN` (ou `RIGHT OUTER JOIN`): Retorna todas as linhas da tabela da direita e as linhas correspondentes da tabela da esquerda. Se não houver correspondência, os atributos da tabela da esquerda serão nulos.
* `FULL JOIN` (ou `FULL OUTER JOIN`): Retorna todas as linhas de ambas as tabelas. Se não houver correspondência, os atributos da tabela que não possui correspondência serão nulos.
* `CROSS JOIN`: Retorna o produto cartesiano das duas tabelas, ou seja, todas as combinações possíveis entre as linhas das duas tabelas. É o único tipo de `JOIN` que não requer uma condição de junção.

Uma junção sempre é feita entre duas tabelas e baseada em uma condição que define como as linhas das duas tabelas devem ser combinadas. A condição é definida após a palavra-chave `ON` e geralmente envolve a comparação de atributos que possuem algum tipo de relacionamento entre as tabelas. Por exemplo, na consulta abaixo, estamos fazendo um `INNER JOIN` entre as tabelas `employees` e `departments` com base no atributo `department_id`, que é comum a ambas as tabelas.

[source,sql]
----
SELECT emp.first_name, 
       emp.last_name, 
       dep.department_name
FROM employees emp
LEFT JOIN departments dep 
ON emp.department_id = dep.department_id;
----

===== Funções de Agregação

Na consulta que fizemos anteriormente, usamos a função de agregação `SUM` para calcular o total de salários dos funcionários em cada departamento. Funções de agregação são usadas para realizar cálculos em um conjunto de valores e retornar um único valor. As principais funções de agregação em SQL são:

* `COUNT()`: Conta o número de linhas em um conjunto de resultados.
* `SUM()`: Calcula a soma dos valores em um conjunto de resultados.
* `AVG()`: Calcula a média dos valores em um conjunto de resultados.
* `MIN()`: Retorna o valor mínimo em um conjunto de resultados.
* `MAX()`: Retorna o valor máximo em um conjunto de resultados.

Funções de agregação são frequentemente usadas em conjunto com a cláusula `GROUP BY` para agrupar linhas e calcular valores agregados para cada grupo.

==== Subconsultas

Outra funcionalidade poderosa do SQL é a capacidade de usar subconsultas, que são consultas aninhadas dentro de outras consultas. Subconsultas podem ser usadas em várias partes de uma consulta, como na cláusula `SELECT`, `FROM` ou `WHERE`. Elas permitem que você realize consultas mais complexas e dinâmicas.

.Consulta que usa uma subconsulta na cláusula `WHERE`
[source,sql]
----
SELECT 
    dep.department_id, 
    dep.department_name, 
    dep.budget,
    -- Calcula o orçamento dos projetos separadamente
    (SELECT COALESCE(SUM(DISTINCT prj.budget), 0)
     FROM projects prj
     JOIN employee_projects emp_prj ON prj.project_id = emp_prj.project_id
     JOIN employees emp ON emp_prj.employee_id = emp.employee_id
     WHERE emp.department_id = dep.department_id) as project_budget,
    -- Calcula o total de salários dos funcionários separadamente
    (SELECT COALESCE(SUM(emp.salary), 0)
     FROM employees emp
     WHERE emp.department_id = dep.department_id) as employee_salaries
FROM departments dep
ORDER BY dep.department_name ASC;
----

A subconsulta acima calcula o orçamento dos projetos e o total de salários dos funcionários para cada departamento separadamente, evitando o problema de duplicação de linhas que ocorreu na consulta anterior. A subconsulta é executada para cada linha do resultado da consulta principal, permitindo que você obtenha valores dinâmicos com base nos dados atuais.

Talvez você tenha imaginado que essa consulta é mais lenta do que a anterior, mas na verdade, dependendo do otimizador de consultas do SGDB, essa consulta pode ser mais eficiente, pois evita a criação de relações intermediárias com cardinalidade maior do que o necessário.

Outra vantagem das subconsultas é a sua capacidade de tornar as consultas mais legíveis e fáceis de entender, especialmente quando lidamos com consultas complexas que envolvem várias tabelas e condições.

Nessa consulta, também usamos a função `COALESCE`, que retorna o primeiro valor não nulo em uma lista de argumentos. Isso é útil para garantir que, se não houver projetos ou funcionários em um departamento, o valor retornado seja 0 em vez de nulo.

==== Common Table Expressions (CTEs)

Uma outra forma de estruturar consultas complexas em SQL é através do uso de Common Table Expressions (CTEs), que são definidas usando a cláusula `WITH`. CTEs permitem que você defina consultas temporárias que podem ser referenciadas dentro da consulta principal, tornando o código mais organizado e legível.

A consulta abaixo reescreve a consulta anterior usando CTEs para calcular o orçamento dos projetos e o total de salários dos funcionários para cada departamento.

.Consulta que usa CTEs para organizar a consulta principal
[source,sql]
----
WITH department_employees AS (
    SELECT 
        department_id,
        SUM(salary) as total_salary
    FROM employees
    GROUP BY department_id
),
department_projects AS (
    SELECT 
        emp.department_id,
        SUM(DISTINCT prj.budget) as total_project_budget
    FROM projects prj
    JOIN employee_projects emp_prj ON prj.project_id = emp_prj.project_id
    JOIN employees emp ON emp_prj.employee_id = emp.employee_id
    GROUP BY emp.department_id
)
SELECT 
    dep.department_id,
    dep.department_name,
    dep.budget,
    COALESCE(dp.total_project_budget, 0) as project_budget,
    COALESCE(de.total_salary, 0) as employee_salaries
FROM departments dep
LEFT JOIN department_employees de ON dep.department_id = de.department_id
LEFT JOIN department_projects dp ON dep.department_id = dp.department_id
ORDER BY dep.department_name ASC;
----

Essa consulta usa duas CTEs: `department_employees` e `department_projects`, que calculam o total de salários dos funcionários e o orçamento dos projetos para cada departamento, respectivamente. A consulta principal então junta essas CTEs com a tabela `departments` para obter os resultados finais. Usar CTEs pode tornar consultas complexas mais fáceis de entender e manter, além de permitir a reutilização de consultas temporárias dentro da consulta principal.

=== Como inserir dados?

Agora que sabemos como consultar dados, precisamos saber como inserir novos dados na base. Para isso usamos o comando `INSERT INTO`, que permite adicionar novas linhas a uma tabela existente.

.Consulta que insere um novo departamento na tabela `departments`
[source,sql]
----
INSERT INTO departments (department_name, location, budget)
VALUES ('Research & Development', 'Austin', 950000.00)
----

Essa consulta insere um novo departamento chamado "Research & Development" localizado em "Austin" com um orçamento de 950.000,00 na tabela `departments`. É importante garantir que os valores inseridos estejam de acordo com as restrições definidas na tabela, como tipos de dados e chaves primárias.

Uma insersão sempre terá o formato `INSERT INTO <tabela> (<atributos>) VALUES (<valores>)`, onde *tabela* é a tabela onde os dados serão inseridos, *atributos* é o conjunto de colunas que receberão os valores e *valores* é o conjunto de valores a serem inseridos. 

Os valores inseridos podem ser constantes, como no exemplo acima, ou podem ser o resultado de uma consulta. Nesse caso, a consulta deve retornar um conjunto de resultados que corresponde ao número e tipo de atributos especificados na cláusula `INSERT INTO`.

.Consulta que insere novos funcionários na tabela `employees` a partir de uma consulta
[source,sql]
----
INSERT INTO employees (first_name, last_name, email, hire_date, job_title, department_id, salary)
SELECT first_name, last_name, email, hire_date, job_title, department_id, salary
FROM temp_employees
WHERE hire_date >= '2025-01-01';
----

=== Como atualizar dados?

Para atualizar dados existentes em uma tabela, usamos o comando `UPDATE`, que permite modificar os valores de uma ou mais colunas para linhas que satisfazem uma determinada condição. O comando `UPDATE` é estruturado da seguinte forma: `UPDATE <tabela> SET <atributo>=<valor> WHERE <condição>`.

É sempre importante usar a cláusula `WHERE` para evitar atualizar todas as linhas da tabela, a menos que essa seja a intenção.

.Consulta que atualiza o orçamento de um departamento na tabela `departments`
[source,sql]
----
-- Aumenta o salário dos funcionários do departamento 1 em 10%
UPDATE employees
SET salary = salary * 1.10
WHERE department_id = 1;

-- Atualiza o orçamento dos departamentos com base no total de 
-- salários dos funcionários usando um overhead de 20%
UPDATE departments dep
SET budget = (
    SELECT SUM(salary) * 12 * 1.20  -- 20% overhead
    FROM employees emp
    WHERE emp.department_id = dep.department_id
)
WHERE budget IS NULL;
----

== Explorando a sintaxe SQL



== Conclusão

Agora sabemos fazer operações básicas de consulta, inserção e atualização de dados em uma base de dados SQL. Também aprendemos sobre junções, agregações, subconsultas e CTEs, que são ferramentas poderosas para trabalhar com dados relacionais. Esse conhecimento é essencial para qualquer desenvolvedor que trabalhe com bancos de dados relacionais e nos prepara para explorar funcionalidades mais avançadas do SQL em futuras imersões.