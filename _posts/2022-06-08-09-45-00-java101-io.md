---
title: "Java I/O"
published: false
description: Quais s√£o as bibliotecas para leitura de arquivos em Java? O que significa ler e escrever em um programa?
tags: [Java, I/O]
cover_image: /assets/images/java/duke-plug.png
series: Java 101
permalink: /posts/java-101-io
publish_date: 2022-06-08 09:45:00 +0300
---

Esse post faz parte de uma s√©rie introdut√≥ria sobre Java, se voc√™ n√£o conhece a linguagem e n√£o leu os posts anteriores, recomendo os ler para ter uma vis√£o melhor da plataforma. Nessa s√©rie, j√° falamos sobre o que √© o ecossistema Java, o que √© a biblioteca Collections e como Java faz Orienta√ß√£o a Objetos, esses t√≥picos s√£o necess√°rios para o que vamos falar agora: **I/O**.

# O que √© I/O?!?

Quando pensamos em um computador a primeira coisa que pensamos √© no que fazemos online: enviar um tweet, responder email, ver um v√≠deo ou mesmo ler esse post. Mas um computador n√£o entende essas atividades, para ele tudo s√£o bits, ou seja, todas essa s√£o atividades podem ser traduzidas em outras atividades de baixo n√≠vel. Quando eu uso o termo "baixo n√≠vel" entenda como algo de menor abstra√ß√£o, por exemplo, para voc√™ ler esse post, o seu navegador teve que renderizar uma p√°gina HTML, que foi requisitada de um servidor HTTP usando uma conex√£o Socket, que na verdade √© apenas uma troca de bits entre v√°rios computadores. Essas atividades sempre envolvem trocas de informa√ß√µes que s√≥ s√£o poss√≠vel atrav√©s de algo chamado **serializa√ß√£o**.

**Serializa√ß√£o** seria a transforma√ß√£o de uma informa√ß√£o em um formato intermedi√°rio para que ela possa transitar entre dois processos. Ou seja, a informa√ß√£o que voc√™ est√° lendo agora √© composta de alguns arquivos HTML, Javascript, CSS, PNG e JPEG que s√£o enviadas atrav√©s da web usando o protocolo HTTP sobre TLS.

_‚Äî  Voc√™ n√£o ia falar de I/O? Que papo √© esse de **serializa√ß√£o** e internet?!?_

Sim, I/O √© outra forma de falar sobre serializa√ß√£o. Toda informa√ß√£o para ser enviada ela passa pelos passos de (1) serializa√ß√£o, (2) escrita, (3) transmiss√£o, (4) leitura e (5) desserializa√ß√£o. O processo de transmiss√£o pode ser o envio dessa informa√ß√£o atrav√©s de uma API, ou o armazenamento dela em um banco de dados ou mesmo a escrita no disco para que possa ser lida no futuro. Os formatos de serializa√ß√£o de dados s√£o bem interessantes de se analisar, mas n√£o √© o foco desse post, aqui focaremos em conhecer as bibliotecas que a JVM nos oferece para que possamos ler e escrever objetos onde bem desejarmos.

Na JVM existem dois pacotes que lidam com serializa√ß√£o em Java. O mais conhecido deles √© o [`java.io`](https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html) onde est√£o definidas as classes para leitura s√≠ncrona. J√° no [`java.nio`](https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html) est√£o definidas as classes para leitura ass√≠ncrona (Non-blocking I/O).

Seria hipocrisia da minha parte dizer que voc√™ deve conhecer esses pacotes por completo, eu n√£o os conhe√ßo. S√≥ quem trabalha especificamente com I/O deve conhecer bem essas classes. N√£o se surpreenda se um desenvolvedor com anos de experi√™ncia em Java procurar no Google _"how to read a text file in Java"_. Isso acontece porque esses pacotes s√£o complexos e por isso dif√≠ceis de serem internalizados. Mas voc√™ deve saber algumas informa√ß√µes importantes e n√≥s vamos trabalhar elas aqui.

1. Porque a interface `Serializable`? Devo usar?
2. O que √© um `InputStream` e um `OutputStream`?
3. Qual Stream devo usar?
4. Qual a diferen√ßa entre um Stream e os Readers/Writers?

N√≥s n√£o vamos falar de NIO, esse ser√° o assunto de um post mais a frente. N√£o estranhe se voc√™ perceber que um S√™nior n√£o sabe como usar as classes desse pacote, em muitos casos elas s√£o usadas apenas pelos frameworks o que implica que muitos desenvolvedores nunca tiveram contato com ela.

## A diferen√ßa entre IO e NIO

Talvez voc√™ tenha ficado curioso do motivo de existirem dois pacotes para I/O. N√£o ficou? Bom, existem dois pacotes diferentes porque NIO √© um conceito muito mais novo do que IO. IO existe desde que os computadores existem e sempre foi um problema para qualquer software. Se voc√™ n√£o fez faculdade de Ci√™ncia da Computa√ß√£o, saiba que existe at√© uma mat√©ria s√≥ pensando em como se criar estrutura de dados para arquivos, isso porque ao se ler um arquivos nos deparamos com alguns problemas que deveriam ser √≥bvios: (1) o tempo de leitura √© muito inferior ao tempo de acesso a mem√≥ria, (2) os dados s√£o armazenados em blocos que n√£o s√£o facilmente rearranj√°veis e (3) a leitura de blocos pr√≥ximos √© mais r√°pida que a leitura de blocos distantes. Os discos mais novos n√£o possuem o problema (3), mas mesmo assim ler e escrever de arquivo n√£o pode ser feito da mesma forma que ler e escrever na mem√≥ria.

_‚Äî  Escrever na mem√≥ria?!?! Eu nunca escrevi na mem√≥ria!!!_

Todo programa, ao ser executado, est√° armazenado na mem√≥ria. Essa √© uma opera√ß√£o t√£o comum que √© transparente para linguagens alto n√≠vel. Se estiv√©ssemos escrevendo em C seria preciso alocar e desalocar mem√≥ria. Mas em Java a aloca√ß√£o √© feita com um `new` e a mem√≥ria √© desalocada automaticamente. Mas n√£o √© poss√≠vel alocar espa√ßa em disco.

Se compararmos a escrita e mem√≥ria com a escrita em disco, ou interface de redes, vemos que a primeira √© t√£o r√°pida que pode ser considerada imediata. J√° os outros tipos de escrita n√£o podem ser consideradas imediatas, por isso surgiram uma s√©rie de interfaces capazes de avisar ao software quando o dado est√° pronto para ser lido. √â nesse ponto que diferenciamos IO de NIO! O pacote `java.io` s√£o classes usadas para leitura/escrita bloqueante, enquanto o pacote `java.nio` s√£o classes de leitura/escrita n√£o bloqueante. E como NIO √© mais recente que o IO tradicional, seu pacote foi inserido em uma vers√£o do Java bem mais recente (JDK 1.4).

# Arquivos, Sockets e Linux üêß

Uma das grandes vantagens do Sistema Operacional Linux √© que tudo s√£o arquivos. Quase todas as funcionalidades do sistema operacional s√£o expostas atrav√©s de arquivos mapeados no sistema de arquivos. Assim ao inv√©s de fazer uma chamada de sistema complexa para, por exemplo, obter o tempo que a m√°quina est√° em opera√ß√£o, basta ler o arquivo `/proc/uptime`. Ou ler o arquivo `/proc/cpuinfo` para obter uma s√©rie de informa√ß√µes sobre a CPU. 

Essa foi uma escolha arquitetural do sistema que se tornou bastante eficaz porque cria uma interface comum entre diversas opera√ß√µes. Por exemplo, se voc√™ for procurar no Windows a maneira de se ver todos os processo em execu√ß√£o, ver√° que tem uma [API (_lembre-se que API n√£o se refere s√≥ a API REST_) complexa](https://docs.microsoft.com/pt-br/windows/win32/psapi/enumerating-all-processes), mas em um Linux basta executar `ls /proc` e todos os diret√≥rios com n√∫meros s√£o processos. Para saber mais informa√ß√µes dos processos, basta acessar alguns arquivos dentro dessas pastas.

Essa informa√ß√£o pode parecer perdida, mas ela tem uma rela√ß√£o profunda com o que veremos a seguir. Quando o Linux escolhe mapear tudo como arquivo, a escolha feita √© por se tratar diversas formas de dados por uma mesma interface. Arquivos s√£o f√°ceis de serem lidos, ent√£o ao expor tudo como arquivo √© f√°cil conseguir acessar essas informa√ß√µes. A JVM tamb√©m traz a mesma abordagem! Tudo em serializa√ß√£o vai se resumir a poucas classes. A opera√ß√£o de leitura de um arquivo ou leitura de um socket s√£o t√£o semelhantes que podem ser executadas pelo mesmo c√≥digo.

# Apresenta√ß√£o do pacote `java.io`

Para entendermos o pacote `java.io` primeiro precisamos entender o que √© um Stream (ou fluxo em tradu√ß√£o livre). N√£o confunda Stream de I/O com Stream de Collections, eles tem um conceito parecido, mas s√£o aplicados em locais diferentes. Stream significa fluxo e quando falamos de Stream estamos falando de uma informa√ß√£o que flui em sentido √∫nico. 

Para entender melhor √© preciso pensar em como era feito antes... As bibliotecas do C para leitura de arquivo/socket n√£o fazem diferencia√ß√£o entre as interfaces de leitura e escrita, ao se criar um canal de comunica√ß√£o temos um inteiro que identifica o canal e esse inteiro pode ser usado tanto para leitura como para escrita. Observe a documenta√ß√£o das fun√ß√µes [`read`](https://man7.org/linux/man-pages/man2/read.2.html) e [`write`](https://man7.org/linux/man-pages/man2/write.2.html) e veja que elas recebem os mesmo argumentos.

[![Documenta√ß√£o da fun√ß√£o read](/assets/images/c/read.PNG)](https://man7.org/linux/man-pages/man2/read.2.html)

[![Documenta√ß√£o da fun√ß√£o write](/assets/images/c/write.PNG)](https://man7.org/linux/man-pages/man2/write.2.html)

Em Java foi decidido que haveria uma diferencia√ß√£o l√≥gica entre leitura e escrita. Ao se ler um arquivo poder√≠amos ter o fluxo de leitura (InputStream ou Reader) e o fluxo de escrita (OutputStream ou Writer). Cada um desses fluxos teria uma orienta√ß√£o √∫nica, isso significa que um InputStream apenas l√™ e o OutputStream apenas escreve. √â por isso que se usa o nome Stream.

Essa √© a primeira informa√ß√£o importante do pacote `java.io`: **As interfaces de leitura s√£o separadas das interfaces de escrita!** Para apresentar o pacote em um diagrama de classes foi at√© preciso criar essa separa√ß√£o para possibilitar que melhor visualiza√ß√£o.

Outro ponto da biblioteca C que explica o funcionamento do pacote `java.io` s√£o as fun√ß√µes [`open`](https://man7.org/linux/man-pages/man2/open.2.html) e [`close`](https://man7.org/linux/man-pages/man2/close.2.html). Em qualquer sistema operacional para se realizar a leitura em arquivo, ou em um socket, s√≥ √© poss√≠vel com a aloca√ß√£o de recurso. Isso √© feito para evitar que processos diferentes criem estados inconsistentes. Quando um processo chama a fun√ß√£o `open` para um determinado arquivo, ele n√£o poder√° ser aberto por outro processo enquanto n√£o for liberado atrav√©s da fun√ß√£o `close`. Se a fun√ß√£o `close` n√£o for chamada, o arquivo s√≥ ser√° liberado quando o processo morrer o que pode tamb√©m gerar um estado inconsistente. Por isso era importante garantir na escrita do c√≥digo que a fun√ß√£o close sempre fosse chamada e que o arquivo sempre estivesse em um estado consistente. Lembre-se que leitura e escrita n√£o s√£o processos imediatos, se o programa finalizar ou o arquivo for fechado antes da escrita terminar, o arquivo fica em um estado inconsistente.

[![Documenta√ß√£o da fun√ß√£o open](/assets/images/c/open.PNG)](https://man7.org/linux/man-pages/man2/open.2.html)

[![Documenta√ß√£o da fun√ß√£o close](/assets/images/c/close.PNG)](https://man7.org/linux/man-pages/man2/close.2.html)

Agora volta ao Java... Em C era preciso criar mecanismos de garantir que o arquivo estava fechado antes que o programa finalizasse. Em Java isso foi internalizado na linguagem atrav√©s de alguns mecanismos. Por isso temos as interfaces `Closeable` e `AutoCloseable`. Se um objeto precisa liberar recursos depois de usado, ele deve implementar a interface `Closeable` e o m√©todo `close` deve ser chamado. At√© a vers√£o 6 do Java era comum ver o `close` sendo chamado dentro do bloco `finally` de um `try {} catch {} finally {}`.

```java
Reader reader = null;
try {
    reader = // inicia reader
    // l√™ dados
} catch (IOException ioe) {
    // trata exce√ß√£o
} finally {
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException ioe) {
            // trata exce√ß√£o
        }
    }
}
```

Como esse c√≥digo tem muito _boilerplate_ (c√≥digo sem significado √∫nico, repetido), o Java 7 trouxe um recurso na sintaxe chamado _try-with-resources_. Agora todo inicio de um _try-catch_ √© poss√≠vel declarar um ou mais objetos que devem implementar a nova interface chamada `AutoCloseable`. Como esse √© um recurso da linguagem, a interface `AutoCloseable` n√£o faz parte do pacote `java.io`, ao contr√°rio da interface `Closeable`, mas do package `java.lang`. Assim o bloco finally poderia ser removido sem preju√≠zo nenhum a l√≥gica do programa.

```java
try (Reader reader = /* inicia reader */) {
    // l√™ dados
} catch (IOException ioe) {
    // trata exce√ß√£o
}
```

Agora que sabemos que (1) objetos de I/O devem liberar recursos e que as classes de I/O s√£o do tipo `Closeable`, observe as principais classes do pacote. Vamos explorar um pouco delas.

<!--
@startuml
title
Java I/O
end title

interface Serializable {}

interface AutoCloseable {
    + close()
}

interface Closeable {
    + close()
}

interface Readable {
    + int read(CharBuffer cb)
}

abstract class InputStream {
    + int available()
    + void close()
    + void mark(int readlimit)
    + boolean markSupported()
    {abstract} + int read()
    + int read(byte[] b)
    + int read(byte[] b, int off, int len)
    + void reset()
    + long skip(long n)
}


abstract class Reader {
    + void mark(int readAheadLimit)
    + boolean markSupported()
    + int read()
    + int read(char[] cbuf)
    + {abstract} int read(char[] cbuf, int off, int len)
    + int read(CharBuffer target)
    + boolean ready()
    + void reset()
    + long skip(long n)
}

together {
    class ObjectInputStream {
        + boolean readBoolean()
        + byte readByte()
        + char readChar()
        + double readDouble()
        + float readFloat()
        + int readInt()
        + long readLong()
        + Object readObject()
        + short readShort()
    }


    class ByteArrayInputStream {
    }

    class BufferedInputStream {
    }

    class FileInputStream {
    + FileChannel getChannel()
    + FileDescriptor getFD()
    }
}



AutoCloseable <|-- Closeable
Closeable <|-- InputStream
InputStream <|-- ObjectInputStream 
InputStream <|-- ByteArrayInputStream
InputStream <|-- BufferedInputStream
InputStream <|-- FileInputStream 


together {
    class BufferedReader {
        + Stream<String> lines()
        + String readLine()
    }
    class LineNumberReader {
        + String readLine()
        + void setLineNumber(int lineNumber)
    }
    class CharArrayReader {}
    class InputStreamReader {}
    class FileReader {}
}

Closeable <|-- Reader 
Readable <|-- Reader 

Reader <|-- BufferedReader
Reader <|-- LineNumberReader
Reader <|-- CharArrayReader
Reader <|-- InputStreamReader
InputStreamReader <|-- FileReader

@enduml
-->

![Java I/O classes de leitura](/assets/images/java/IO-Read.png)

<!--
@startuml
title
Java I/O
end title

interface Serializable {}

interface AutoCloseable {
    + close()
}

interface Closeable {
    + close()
}

together {
interface Flushable {
    + void flush()
}

interface Appendable {
    + Appendable append(char c)
    + Appendable append(CharSequence csq)
    + Appendable append(CharSequence c, int start, int end)
}
}

abstract class OutputStream {
    + void write(byte[] b)
    + void write(byte[] b, int off, int len)
    {abstract} + void write(int b)
}

abstract class Writer {
    + Writer append(char c)
    + Writer append(CharSequence csq)
    + Writer append(CharSequence csq, int start, int end)
    + void write(char[] cbuf)
    {abstract} + void write(char[] cbuf, int off, int len)
    + void write(int c)
    + void write(String str)
    + void write(String str, int off, int len)
}

AutoCloseable <|-- Closeable

together {
    class ObjectOutputStream {
        + void writeBoolean(boolean val)
        + void writeByte(int val)
        + void writeBytes(String str)
        + void writeChar(int val)
        + void writeChars(String str)
        + void writeDouble(double val)
        + void writeFloat(float val)
        + void writeInt(int val)
        + void writeLong(long val)
        + void writeObject(Object obj)
        + void writeShort(int val)
    }

    class BufferedOutputStream {
    }

    class ByteArrayOutputStream {
    }

    class FileOutputStream {
        + FileChannel getChannel()
        + FileDescriptor getFD()
    }

Closeable <|-- OutputStream 
Flushable <|-- OutputStream 
OutputStream <|-- ObjectOutputStream 
OutputStream <|-- BufferedOutputStream
OutputStream <|-- ByteArrayOutputStream 
OutputStream <|-- FileOutputStream 

together {
    class BufferedWriter {
        + void newLine()
        + void write(String s, int off, int len)
    }
    class CharArrayWriter {
        + void writeTo(Writer out)
    }
    class OutputStreamWriter {
        + String getEncoding()
    }
    class FileWriter {}
    class PrintWriter {}
}

Closeable <|-- Writer 
Flushable <|-- Writer 
Appendable <|-- Writer 

Writer <|-- BufferedWriter
Writer <|-- CharArrayWriter
Writer <|-- OutputStreamWriter
Writer <|-- PrintWriter
OutputStreamWriter <|-- FileWriter
@enduml
-->

![Java I/O classes de leitura](/assets/images/java/IO-Write.png)

# 1. Como ler um arquivo?

Falamos anteriormente que a diferen√ßa entre um InputStream e um Reader √© que o InputStream trabalha com bytes enquanto o Reader com caracteres. Agora vamos mostrar um exemplo pr√°tico? Imagina que voc√™ tem um arquivo texto em formato JSON, como fa√ßo pra ler? Se pensou em ler usando um Reader... v√° com calma! A primeira coisa a fazer √© decidir qual biblioteca vai ser usada para ler o JSON. A escolha deve come√ßar pelo elemento mais complexo.

Para se ler um JSON, temos uma biblioteca praticamente onipresente: [Jackson Databind](https://github.com/FasterXML/jackson-databind/)!

Talk about Scanner class

Input/OutputStream moves bytes
Writer/Reader moves caracteres