---
title: "Java I/O"
published: false
description: Quais são as bibliotecas para leitura de arquivos em Java? O que significa ler e escrever em um programa?
tags: [Java, I/O]
cover_image: /assets/images/java/duke-plug.png
series: Java 101
permalink: /posts/java-101-io
publish_date: 2022-06-08 09:45:00 +0300
---

Esse post faz parte de uma série introdutória sobre Java, se você não conhece a linguagem e não leu os posts anteriores, recomendo ler eles para ter uma visão completa da plataforma. Já falamos sobre o que é o ecossistema Java, o que é a biblioteca Collections e como Java faz Orientação a Objetos, esses tópicos são necessários para o que vamos falar agora: I/O.

# O que é I/O?!?

Quando pensamos em um computador a primeira coisa que pensamos é o que fazemos online: enviar um tweet, responder email, ver um vídeo ou mesmo ler esse post. Todas essa são atividades podem ser traduzidas em outras atividades de baixo nível. Quando eu uso o termo "baixo nível" entenda como algo de menor abstração, por exemplo, para você ler esse post, o seu navegador teve que renderizar uma página HTML, que foi requisitada de um servidor HTTP usando uma conexão Socket. Essas atividades sempre envolvem trocas de informações que só são possível através de algo chamado **serialização**.

**Serialização** seria a transformação de uma informação em um formato intermediário para que ela possa transitar entre dois processos.

_—  Você não ia falar de I/O? Que papo é esse de **serialização**?!?_

Sim, I/O é outra forma de falar sobre serialização. Toda informação para ser enviada ela passa pelos passos de (1) serialização, (2) escrita, (3) transmissão, (4) leitura e (5) desserialização. O processo de transmissão pode ser o envio dessa informação através de uma API, o armazenamento dela em um banco de dados ou mesmo a escrita no disco para que possa ser lida no futuro. Os formatos de serialização de dados são bem interessantes de se analisar, mas não é o foco desse post, aqui focaremos em conhecer as bibliotecas que a JVM nos oferece para que possamos ler e escrever objetos onde desejarmos.

Existem dois pacotes que lidam com serialização em Java. O mais conhecido deles é o [`java.io`](https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html) onde estão definidas as classes para leitura síncrona. Já no [`java.nio`](https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html) estão definidas as classes para leitura assíncrona (Non-blocking I/O).

Seria hipocrisia da minha parte dizer que você deve conhecer esses pacotes por completo, eu não conheço. Só quem trabalha especificamente com I/O deve conhecer bem essas classes, tanto que é comum você desafiar um desenvolvedor Java Sênior a escrever o código de leitura de arquivo sem consultar o Google. Muitos ao ter que ler um arquivo pede ajuda aos universitários ou usa uma classe auxiliar. Mas você deve saber algumas informações importantes e nós vamos trabalhar elas aqui.

1. Porque a interface `Serializable`? Devo usar?
2. O que é um `InputStream` e um `OutputStream`?
3. Qual Stream devo usar?
4. Qual a diferença entre um Stream e os Readers/Writers?

Nós não vamos falar de NIO, esse será o assunto de um post mais a frente. Não estranhe se você perceber que um Sênior não souber como usar as classes desse pacote, em muitos casos elas são usadas apenas pelos frameworks o que implica que muitos desenvolvedores nunca tiveram contato com ela.

## A diferença entre IO e NIO

Talvez você tenha ficado curioso do motivo de existirem dois pacotes para I/O. Não ficou? Bom, existem dois pacotes diferentes porque NIO é um conceito muito mais novo do que IO. IO existe desde que os computadores existem e sempre foi um problema para qualquer software. Se você não fez faculdade de Ciência da Computação, saiba que existe até uma matéria só pensando em como se criar estrutura de dados para arquivos, isso porque ao se ler um arquivos nos deparamos com alguns problemas que deveriam ser óbvios: (1) o tempo de leitura é muito inferior ao tempo de acesso a memória, (2) os dados são armazenados em blocos que não são facilmente rearranjáveis e (3) a leitura de blocos próximos é mais rápida que a leitura de blocos distantes. Os discos mais novos não possuem o problema (3), mas mesmo assim ler e escrever de arquivo não pode ser feito da mesma forma que ler e escrever na memória.

_—  Escrever na memória?!?! Eu nunca escrevi na memória!!!_

Todo programa, ao ser executado, está armazenado na memória. Essa é uma operação tão comum que é transparente para linguagens alto nível. Se estivéssemos escrevendo em C seria preciso alocar e desalocar memória. Mas em Java a alocação é feita com um `new` e a memória é desalocada automaticamente. Mas não é possível alocar espaça em disco.

Se compararmos a escrita e memória com a escrita em disco, ou interface de redes, vamos ver que a primeira é tão rápida que pode ser considerada imediata. Já os outros tipos de escrita não podem ser consideradas imediatas, por isso surgiram uma série de interfaces capazes de avisar ao software quando o dado está pronto para ser lido. É nesse ponto que diferenciamos IO de NIO! O pacote `java.io` são classes usadas para leitura/escrita bloqueante, enquanto o pacote `java.nio` são classes de leitura/escrita não bloqueante. E como NIO é mais recente que o IO tradicional, seu pacote foi inserido em uma versão do Java bem mais recente.

<!--
@startuml
title
Java I/O
end title

interface Serializable {}

interface AutoCloseable {
    + close()
}

interface Closeable {
    + close()
}

interface Readable {
    + int read(CharBuffer cb)
}

abstract class InputStream {
    + int available()
    + void close()
    + void mark(int readlimit)
    + boolean markSupported()
    {abstract} + int read()
    + int read(byte[] b)
    + int read(byte[] b, int off, int len)
    + void reset()
    + long skip(long n)
}


abstract class Reader {
    + void mark(int readAheadLimit)
    + boolean markSupported()
    + int read()
    + int read(char[] cbuf)
    + {abstract} int read(char[] cbuf, int off, int len)
    + int read(CharBuffer target)
    + boolean ready()
    + void reset()
    + long skip(long n)
}

together {
    class ObjectInputStream {
        + boolean readBoolean()
        + byte readByte()
        + char readChar()
        + double readDouble()
        + float readFloat()
        + int readInt()
        + long readLong()
        + Object readObject()
        + short readShort()
    }


    class ByteArrayInputStream {
    }

    class BufferedInputStream {
    }

    class FileInputStream {
    + FileChannel getChannel()
    + FileDescriptor getFD()
    }
}



AutoCloseable <|-- Closeable
Closeable <|-- InputStream
InputStream <|-- ObjectInputStream 
InputStream <|-- ByteArrayInputStream
InputStream <|-- BufferedInputStream
InputStream <|-- FileInputStream 


together {
    class BufferedReader {
        + Stream<String> lines()
        + String readLine()
    }
    class LineNumberReader {
        + String readLine()
        + void setLineNumber(int lineNumber)
    }
    class CharArrayReader {}
    class InputStreamReader {}
    class FileReader {}
}

Closeable <|-- Reader 
Readable <|-- Reader 

Reader <|-- BufferedReader
Reader <|-- LineNumberReader
Reader <|-- CharArrayReader
Reader <|-- InputStreamReader
InputStreamReader <|-- FileReader

@enduml
-->

![Java I/O classes de leitura](/assets/images/java/IO-Read.png)

<!--
@startuml
title
Java I/O
end title

interface Serializable {}

interface AutoCloseable {
    + close()
}

interface Closeable {
    + close()
}

together {
interface Flushable {
    + void flush()
}

interface Appendable {
    + Appendable append(char c)
    + Appendable append(CharSequence csq)
    + Appendable append(CharSequence c, int start, int end)
}
}

abstract class OutputStream {
    + void write(byte[] b)
    + void write(byte[] b, int off, int len)
    {abstract} + void write(int b)
}

abstract class Writer {
    + Writer append(char c)
    + Writer append(CharSequence csq)
    + Writer append(CharSequence csq, int start, int end)
    + void write(char[] cbuf)
    {abstract} + void write(char[] cbuf, int off, int len)
    + void write(int c)
    + void write(String str)
    + void write(String str, int off, int len)
}

AutoCloseable <|-- Closeable

together {
    class ObjectOutputStream {
        + void writeBoolean(boolean val)
        + void writeByte(int val)
        + void writeBytes(String str)
        + void writeChar(int val)
        + void writeChars(String str)
        + void writeDouble(double val)
        + void writeFloat(float val)
        + void writeInt(int val)
        + void writeLong(long val)
        + void writeObject(Object obj)
        + void writeShort(int val)
    }

    class BufferedOutputStream {
    }

    class ByteArrayOutputStream {
    }

    class FileOutputStream {
        + FileChannel getChannel()
        + FileDescriptor getFD()
    }

Closeable <|-- OutputStream 
Flushable <|-- OutputStream 
OutputStream <|-- ObjectOutputStream 
OutputStream <|-- BufferedOutputStream
OutputStream <|-- ByteArrayOutputStream 
OutputStream <|-- FileOutputStream 

together {
    class BufferedWriter {
        + void newLine()
        + void write(String s, int off, int len)
    }
    class CharArrayWriter {
        + void writeTo(Writer out)
    }
    class OutputStreamWriter {
        + String getEncoding()
    }
    class FileWriter {}
    class PrintWriter {}
}

Closeable <|-- Writer 
Flushable <|-- Writer 
Appendable <|-- Writer 

Writer <|-- BufferedWriter
Writer <|-- CharArrayWriter
Writer <|-- OutputStreamWriter
Writer <|-- PrintWriter
OutputStreamWriter <|-- FileWriter
@enduml
-->

![Java I/O classes de leitura](/assets/images/java/IO-Write.png)