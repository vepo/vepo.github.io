---
title: "OO: Eu vejo objetos por todos os cantos!"
published: true
description: Voc√™ sabe o que √© Orienta√ß√£o a Objetos? E voc√™ sabe porque OO √© o principal foco da linguagem Java? A ideia desta s√©rie √© criar um tutorial Java onde mostrarei todos os segredos da linguagem e do ecossistema.
tags: [Orienta√ß√£o a Objeto, Tutorial, Java]
cover_image: /assets/images/java/duke-plug.webp
series: Java 101
permalink: /posts/java-101-objetos
publish_date: 2022-05-30 11:15:00 +0300
---

:figure-caption: Figura
:imagesdir: /assets/images/java-101

Java tem um f√£ clube enorme! S√£o pessoas que usam a linguagem no dia a dia e resolvem problemas importantes para a nossa sociedade. Quando Java completou 25 anos houve at√© a hashtag https://twitter.com/search?q=lang%3Apt%20%23MovedByJava&src=typed_query&f=top[#MovedByJava] para mostrar que o mundo √© movido por software desenvolvido em Java, s√£o bilh√µes de transa√ß√µes em Java em servi√ßos altamente escal√°veis.

MAS... existe um pequeno grupo raivoso e ruidoso que https://twitter.com/search?q=java%20lento&src=typed_query&f=live[odeia Java]. Eu n√£o desejaria nem citar esse grupo, mas creio que isso tem que estar em qualquer tutorial de Java, n√£o para dar voz a esse povo, mas para desmentir. Java n√£o √© lento, talvez voc√™ que n√£o est√° sabendo usar e vamos mais a frente falar sobre _tuning_. Essas pessoas usam argumentos bem simples como "tudo tem que estar em objetos", "eu tenho que escrever um main dentro de um objeto", "nada disso faz sentido"... Resolvi citar eles aqui, porque eles n√£o odeiam Java, eles odeiam Orienta√ß√£o a Objetos e com esse post eu vou te convencer que al√©m de ser uma √≥tima forma de pensar, Orienta√ß√£o a Objetos ajudou a pavimentar os outros paradigmas que est√£o por aqui no ano de 2022.

[#cap-04-um-pouco-de-historia]
== Um pouco de hist√≥ria

Orienta√ß√£o a Objetos surgiu nos anos 60 e era usado para fazer simula√ß√µes no Simula 67. Esta linguagem, por sua vez, acabou por influenciar o C++ (1979), que na verdade √© uma tentativa de adicionar objetos a linguagem C. Por muitos anos o C++ foi uma das linguagens mais influentes do mercado, ela n√£o era, puramente, uma linguagem orientada a objetos, era at√© poss√≠vel intercalar c√≥digo C com c√≥digo C++. A primeira linguagem que surge como puramente orientada a objetos e ainda por cima compilada em _bytecode_ para ser executado em uma M√°quina Virtual foi... 

PAUSA DRAM√ÅTICA... ü•∂

O Smalltalk! O que foi? üßê Achou que era o Java? O Java s√≥ surge em 1991, e em seu lan√ßamento em 1995, e acaba herdando muitas caracter√≠sticas do Smalltalk, tanto que muitas pessoas da comunidade Java vieram do mundo Smalltalk. E uma das coisas que Java herda √© ser primariamente orientada a objetos. 

_‚Äî Mas porque essa preocupa√ß√£o em ser Orientada a Objetos?!_

Porque na verdade a computa√ß√£o n√£o come√ßou com essas linguagens e nem com esses paradigmas, mas como Programa√ß√£o Funcional (ver _https://dl.acm.org/doi/abs/10.1145/72551.72554[Conception, evolution, and application of functional programming languages]_). Linguagens funcionais s√£o excelentes para modelarem problemas matem√°ticos e alguns problemas computacionais, pois elas s√£o declarativas. Podemos transpor a defini√ß√£o de um problema para a linguagem de programa√ß√£o facilmente, podendo at√© mesmo aplicar uma l√≥gica equacional, pois, se as fun√ß√µes s√£o puras, o valor de `f(x)` s√≥ precisa ser calculado uma vez. Logica equacional √© o mesmo que tratar uma fun√ß√£o como uma equa√ß√£o matem√°tica, isso implica que s√≠mbolos iguais ter√£o valores iguais. 

MAS linguagens funcionais apresentam uma certa dificuldade de modelar alguns tipos de sistemas e, com a populariza√ß√£o da computa√ß√£o, foi necess√°rio outros paradigmas para os novos sistemas que foram sendo desenvolvidos. O primeiro desses paradigmas foi a Programa√ß√£o Procedural, popularizado pela linguagens como C. Nesse tipo de linguagem a l√≥gica de programa√ß√£o pode ser estruturada dentro de procedimentos que podem ser tanto fun√ß√µes quanto procedimentos, a diferen√ßa entre os dois √© que uma fun√ß√£o n√£o altera o valor dos par√¢metros e sempre retorna um valor, j√° os procedimentos alteram o valor dos par√¢metros e n√£o retornam nenhum valor. Em C, podemos escrever tanto fun√ß√µes quanto procedimentos.

Linguagens procedurais apresentam bastante dificuldade para encapsular complexidade porque √© dif√≠cil criar abstra√ß√µes com ela. Em C, os dados s√£o sempre modelados usando tipos primitivos ou estruturas, que nada mais s√£o que agrupamentos de tipos primitivos. Mesmo quem desenvolve C hoje em dia, n√£o consegue compreender o que era desenvolver nos anos 70, pois a linguagem continuou avan√ßando. Eu tenho uma leve ideia porque, na universidade, desenvolvi programas para um microcontrolador com o compilador bem limitado. O exemplo abaixo eu retirei de um https://github.com/vepo/csvi[visualizador de CSV] que eu desenvolvi por necessidade. 

[source,c]
----
matrix_config_t *matrix_config_initialize(size_t width, size_t height)
{
    matrix_config_t *config = (matrix_config_t *)malloc(sizeof(matrix_config_t));
    config->columns = width;
    config->heights = height;
    config->column_width = (size_t *)calloc(width, sizeof(size_t));
    config->line_height = (size_t *)calloc(height, sizeof(size_t));
    return config;
}
----

Observe que no c√≥digo h√° a preocupa√ß√£o de se alocar a posi√ß√£o de mem√≥ria necess√°ria para uma determinada estrutura chamada `matriz_config_t` e que essa aloca√ß√£o √© feita atrav√©s de duas fun√ß√µes diferentes `calloc` e `malloc`. Esse c√≥digo pode parecer simples, mas tem diversidades camadas de complexidades, como simplesmente diferenciar essas duas fun√ß√µes.

_‚Äî Aonde voc√™ quer chegar?!?!_


Ora! Qual √© o objetivo de um desenvolvedor? 

_‚Äî Escrever c√≥digo!_

Errado! O objetivo de um desenvolvedor √© resolver problemas atrav√©s da escrita de c√≥digo. Por isso, desenvolvedores n√£o podem e n√£o devem ficar preocupado com complexidades desnecess√°ria. √â para remover essa complexidade que surgem linguagens Orientadas a Objetos. As linguagens procedurais s√£o simples e com poucas funcionalidades, por isso toda a informa√ß√£o √© armazenada de forma simpl√≥ria em estruturas. Isso gera complexidade e o objetivo principal de uma linguagem de programa√ß√£o √© encapsular complexidade.

Vamos tentar explicar de outra forma...

[#cap-04-o-que-e-poo]
== O que √© Programa√ß√£o Orientada a Objetos

Vamos estabelecer algumas hip√≥teses....

=== E se eu puder lidar com tipos complexos

Uma linguagem OO ir√° sempre lidar com tipos de dados cada vez mais complexos pois n√£o estamos apenas falando de programa√ß√£o, mas de encapsulamento de complexidades.

Vamos supor que eu desejo desenvolver uma API para navega√ß√£o rob√≥tica e eu sei que meu rob√¥ tem 4 rodas e que posso definir a velocidade de cada roda. Ser√° que eu preciso saber qual √© a velocidade de cada roda? Ou eu posso apenas mandar comandos para o meu rob√¥? Um exemplo de comandos s√£o: "V√° para frente", "Fa√ßa uma curva de 30¬∫", "Pare".

Quando falamos de Orienta√ß√£o a Objetos, devemos pensar em design de c√≥digo. N√£o estamos falando de programa√ß√£o pura, mas de uma modelagem de dados e conceitos. Os detalhes internos devem ser escondidos para quem s√≥ sejam vis√≠veis para os pr√≥prios times de manuten√ß√£o.

=== E se eu puder associar comportamento aos meus tipos complexos

Todo c√≥digo tem um contexto para ser executado. Quando eu tenho um rob√¥ e eu desejo que ele v√° para uma posi√ß√£o, se essa ordem √© diferente para cada rob√¥ e produz diferentes resultados, mas ela sempre est√° associada a um rob√¥, ou seja, n√£o faz sentido um outro objeto que n√£o seja um rob√¥ se mover (_ainda falarei de heran√ßa_). 

Mas podem existir outros objetos que se movem, certo? E como fica se a fun√ß√£o mover √© somente associada a rob√¥s? 

Em uma linguagem orientada a objetos, n√£o temos fun√ß√µes e nem procedimentos, mas m√©todos. A diferen√ßa √© que uma fun√ß√£o transforma dados, procedimentos executa uma s√©rie de altera√ß√µes nos par√¢metros, mas um m√©todo envia uma mensagem (_essas defini√ß√µes n√£o tem car√°ter acad√™mico, se algu√©m tiver alguma refer√™ncia me manda no Twitter_). Logo um m√©todo vai pertencer a um objeto, assim se formos modelar um Avi√£o, podemos criar um outro m√©todo mover que existir√° somente para um Avi√£o e que ser√° diferente do m√©todo mover de um rob√¥.

=== E se puder compartilhar o comportamento entre tipos diferentes

Objetos tem um tipo especifico, por exemplo n√≥s estamos falando de um rob√¥. Mas eu posso assumir que um rob√¥ √© um tipo de objeto m√≥vel? Posso eu criar m√©todos nesse objeto m√≥vel? O que essa implementa√ß√£o desse m√©todo faz para um rob√¥ √© a mesma coisa que se faz para um avi√£o?

Para cada pergunta acima, existe uma resposta no mundo da Programa√ß√£o Orientada a Objetos e √© o que vamos ver na pr√≥xima sess√£o.

[#cap-04-orientacao-a-objetos]
== Orienta√ß√£o a Objetos

N√≥s falamos um pouco sobre Programa√ß√£o Funcional e Programa√ß√£o Procedural, ent√£o vamos definir o que √© Programa√ß√£o Orientada a Objetos (POO) antes de ver como Java faz POO.

Programa√ß√£o Orientada a Objetos √© um modelo de design, analise e desenvolvimento de software que organiza todo o software ao redor dos dados e suas abstra√ß√µes. Para que isso seja poss√≠vel, √© criado o conceito de Objeto. Um objeto √© um componente de software composto de atributos e comportamento.

Quando falamos de orienta√ß√£o a objeto, focamos na defini√ß√£o do que √© um objeto e das opera√ß√µes que esse objeto pode realizar, ao contr√°rio da l√≥gica necess√°ria para realizar a opera√ß√£o. Os principais benef√≠cios da POO √© a reutiliza√ß√£o de c√≥digo, escalabilidade e efici√™ncia no desenvolvimento. Ent√£o podemos definir que POO vai ter alguns elementos.

=== Elementos

Abaixo vemos as descri√ß√µes de cada elemento da POO, elas n√£o se referem a linguagem Java, mas ao paradigma em si.

==== Classes

**Classes** s√£o tipos de dados definidos pelo usu√°rio que atuam como modelo para objetos, atributos e m√©todos.

==== Objetos

**Objetos** s√£o inst√¢ncias de uma classe criada com dados espec√≠ficos. 

[#cap-04-elementos-metodos]
==== M√©todos

**M√©todos** s√£o fun√ß√µes definidas dentro de uma classe que descrevem o comportamento de um objeto. Cada m√©todo contido nas defini√ß√µes de classe come√ßa com uma refer√™ncia a um objeto de inst√¢ncia. Al√©m disso, as sub-rotinas contidas em um objeto s√£o chamadas de m√©todos de inst√¢ncia. Os programadores usam m√©todos para reutiliza√ß√£o ou para manter a funcionalidade encapsulada dentro de um objeto por vez.

==== Atributos

**Atributos** s√£o definidos no modelo de classe e representam o estado de um objeto. Os objetos ter√£o dados armazenados no campo de atributos. Os atributos de classe pertencem √† pr√≥pria classe.

[#cap-04-principios]
=== Princ√≠pios

Quando falamos em Orienta√ß√£o a Objetos, temos em mente alguns princ√≠pios.

==== Encapsulamento

Encapsulamento significa que um objeto n√£o √© obrigado a expor a sua implementa√ß√£o e nem os seus atributos. Cabe ao design do objeto escolher como ser√° feita essa exposi√ß√£o. Essa caracter√≠stica de oculta√ß√£o de dados fornece maior seguran√ßa ao programa e evita corrup√ß√£o de dados n√£o intencional.

==== Abstra√ß√£o

Objetos criam abstra√ß√µes que tornam poss√≠vel controlar a complexidade. Ao se criar uma classe, o restante do sistema dever√° interagir atrav√©s da interface que ela prop√µe n√£o tendo acesso a sua l√≥gica interna.

[#cap-04-principios-heranca]
==== Heran√ßa

As classes podem reutilizar o c√≥digo de outras classes. Relacionamentos e subclasses entre objetos podem ser atribu√≠dos, permitindo que os desenvolvedores reutilizem a l√≥gica comum enquanto ainda mant√™m uma hierarquia √∫nica. Essa propriedade da OOP for√ßa uma an√°lise de dados mais completa, reduz o tempo de desenvolvimento e garante um maior n√≠vel de precis√£o.

==== Polimorfismo

Os objetos s√£o projetados para compartilhar comportamentos e podem assumir mais de uma forma. O sistema poder√° definir como v√™ um objeto e como interage por ele baseado na sua pr√≥pria classe ou em alguma classe pai, reduzindo a complexidade ou a necessidade de duplicar c√≥digo. Quando uma classe filha √© criada, que estende a funcionalidade da classe pai, ambas podem ser tratada pelo mesmo c√≥digo usando a classe pai como interface. O polimorfismo permite que diferentes tipos de objetos usem a mesma interface.

=== Como Java faz Programa√ß√£o Orientada a Objetos

Java √© uma linguagem primariamente orientada a objetos, logo voc√™ deve primeiro entender o que √© uma classe. Classe √© o arqu√©tipo de um objeto. Arqu√©tipo, resumidamente, √© o tipo comum de algo. Por exemplo, se eu falar que existe o tipo Gato, voc√™ vai imaginar o formato desse animal e algumas outras caracter√≠sticas, mas se eu falar que existe o Garfield voc√™ vai imaginar que ele √© um Gato laranja, gordo e pregui√ßoso. O Garfield √© um indiv√≠duo do arqu√©tipo Gato.

[.text-center]
.Significado de Arqu√©tipo da Wikipedia
image::java-101/cap-04/arquetipo.png[id=significado-arquetipo, align="center"]

Vamos transpor isso pra Java? Podemos ter uma classe Gato, mas o objeto ser√° um Garfield. Assim, podemos ter...

[source,java]
----
package org.animais.mamiferos;

import org.fisica.luz.Cor;
import org.animais.psique.Temperamento;

public class Gato {
    private float pesoEmKg;
    private final Cor cor;
    private Temperamento temperamento;
    public Gato(float pesoEmKg, Cor cor, Temperamento temperamento) {
        this.pesoEmKg = pesoEmKg;
        this.cor = cor;
        this.temperamento = temperamento;
    }

    // M√âTODOS
}
----

Isso significa que podemos modelar qualquer Gato por esse modelo, assim se quisermos ter um Garfield...


[source,java]
----
Gato garfield = new Gato(15.0, Cor.LARANJA, Temperamento.PREGUICOSO);
----

No primeiro trecho de c√≥digo tempo a declara√ß√£o da classe `Gato` no pacote `org.animais.mamiferos`. Isso significa que s√≥ pode existir um tipo de `Gato` nesse pacote, mas isso n√£o implica que eu possa criar o tipo `Gato` para descrever, por exemplo, _instala√ß√µes el√©tricas n√£o-oficiais_, que obviamente n√£o fazem parte do pacote `org.animais.mamiferos`, mas `org.humanos.civilizacoes.brasil.infraestrutura`. Classe √© usada para definir o tipo do objeto, mas o pacote √© o contexto na qual ele existe. Classe e Pacote tem uma rela√ß√£o umbilical, uma Classe sempre deve estar ligada a um Pacote.

A segunda coisa que vamos detalhar nesse trecho de c√≥digo s√£o os modificadores de acesso. Como disse uma linguagem orientada a objetos √© usada para se encapsular detalhes, logo os modificadores de acesso servem para definir quem pode acessar o qu√™. Eles podem ser aplicados para Classes, M√©todos e Campos e existem os seguintes modificadores de acesso.

[options="header"]
|====================================================================================================================================================================================================================================================================================
| Tipo             ^| Token        | Descri√ß√£o                                                                                                                                                                                                                                        
| Package Private  ^| -            | Define que o elemento ser√° acess√≠vel dentro do pacote. Esse √© o modificador padr√£o, isso significa que nesse caso pode ser omitido.                                                                                                              
| Privado          ^| `private`    | Define que o elemento s√≥ pode ser acessado dentro da pr√≥pria classe.                                                                                                                                                                             
| Protegido        ^| `protected`  | Define que o elemento √© acess√≠vel dentro do mesmo pacote ou atrav√©s de heran√ßa.                                                                                                                                                                  
| P√∫blico          ^| `public`     | Define que o elemento √© acess√≠vel em qualquer contexto.                                                                                                                                                                                          
| Final            ^| `final`      | Se aplicada a classe, ela n√£o poder√° ser estendida. Se aplicada a um campo ele n√£o poder√° ter seu valor alterado. Se aplicado a um m√©todo, ele n√£o poder√° ser reimplementado em uma classe que herda ele.                                        
| Est√°tico         ^| `static`     | Pode ser usado tanto em campos como em classes internas. Se usado no campo, ele vai ter apenas um valor e est√° associado a classe. Campos n√£o est√°ticos s√£o associados a objetos. Se aplicado a classes internas, ela n√£o depender√° de um objeto.
|====================================================================================================================================================================================================================================================================================


Ainda existem dois mais dois modificadores (`volatile` e `transiente`), mas eles n√£o s√£o importantes quando falamos de OO. `transiente` ser√° importante quando falarmos de serializa√ß√£o e `volatile` quando falarmos de threads. Dos outros, podemos agrupar o `private`, `protected`, `public` e a aus√™ncia de um desses, pois eles s√£o mutualmente excludentes.

O pr√≥ximo ponto que podemos falar √© sobre m√©todos. Em Java n√£o √© comum termos fun√ß√µes puras, nem linguagem est√° preparada para isso. Temos basicamente dois tipos de m√©todos. Os m√©todos de inst√¢ncia s√£o aqueles que s√£o associados a um objeto. E os m√©todos est√°ticos s√£o aqueles associados a uma classe, sem depender de uma inst√¢ncia. Conseguimos criar m√©todos est√°ticos usando o modificador de acesso `static`. Quando um m√©todo n√£o √© est√°tico, podemos usar `this` para se referir a inst√¢ncia com a qual o m√©todo √© associado.

M√©todos sempre tem par√¢metros e valor de retorno (pode ser `void` que significa um vazio existencial, diferente do vazio de posi√ß√£o que √© a palavra _empty_). M√©todos de inst√¢ncia sempre v√£o te acesso a um objeto espec√≠fico (usando o `this`), enquanto m√©todos est√°ticos n√£o o s√£o.

Vamos ver melhor como os m√©todos funcionam? E se n√≥s cri√°ssemos 3 m√©todos na nossa classe gato. O primeiro seria um m√©todo para mesclar caracter√≠sticas de 2 gatos, o segundo seria o m√©todo `meow` e o terceiro o m√©todo de reprodu√ß√£o (`cruza`).

[source,java]
----
public class Gato {
    public static Gato mistura(Gato gatoA, Gato gatoB) {
        // M√°gica acontece
        return gatoC;
    }

    // Campos, construtores, getters e setters

    public void meow() {
        System.out.println("Miau!");
    }

    public Gato cruza(Felino outro) {
        if ((!(outro instanceof Gato)) || sexo == outro.sexo) {
            throw new CruzamentoException("N√£o √© poss√≠vel gerar filhote!");
        }
        return mistura(this, outro);
    }
}
----

O m√©todo `meow` √© o exemplo cl√°ssico que veremos em heran√ßa, ele n√£o retorna nada, s√≥ executa uma a√ß√£o. Aqui vamos focar nos m√©todos `cruza` e `mistura` (ok, focar na parte reprodutiva foi p√©ssimo... mas estou falando de gatos!). `mistura` √© um m√©todo que aleatoriamente vai gerar um novo gato baseado nas caracter√≠sticas de dois gatos. Nele podemos ver que o m√©todo recebe dois par√¢metros e retorna um valor. No caso desse m√©todo, estamos retornando um novo objeto, mas nada impede de o retorno ser um dos par√¢metros. Outra caracter√≠stica √© que os par√¢metros s√£o uma passagem por refer√™ncia e n√£o por valor como vamos ver um pouco mais a frente. Sobre o m√©todo `cruza`, nele podemos acessar os campos do objeto local e campos da refer√™ncia. Quero ressaltar o uso do `this` que √© a forma de acessar a refer√™ncia ao objeto pela qual o m√©todo √© referenciado, o `this` n√£o pode ser usado para m√©todos est√°ticos.

[#cap-04-principios-heranca-implemenacao]
==== Como Java implementa Heran√ßa

Falamos sobre classes e alguns detalhes, mas agora precisamos falar de heran√ßa.

Temos 3 tipos de classe: a Classe, a Interface e a Classe Abstrata.

_‚Äî Pera√™! Mas como uma classe pode ser tamb√©m Interface e Classe Abstrata?!?!? Tem algum erro l√≥gico nessa afirma√ß√£o!_

N√£o! Segura essa informa√ß√£o que quando formos falar sobre Reflex√£o trataremos do conceito interno de Classe. Por enquanto aceite que existem tr√™s tipos de classe e um deles √© classe. ü§∑‚Äç‚ôÇÔ∏è

A Interface √© quando tempos um contrato de como uma classe deve ser implementada. Ela vai definir a assinatura de alguns m√©todos. Por assinatura entenda que √© a forma como a JVM usa para identificar um m√©todo, ela √© composta pelo nome do m√©todo e a lista de par√¢metros. O tipo de retorno n√£o faz parte de uma assinatura e isso vai ser importante mais a frente. Uma interface tamb√©m pode definir m√©todos `default` e m√©todos `static`. Uma interface normalmente √© usada para definir um tipo, ou comportamento, comum dentro de um sistema. 

Uma classe abstrata √© uma classe que n√£o pode ser instanciada. Normalmente usamos quase abstrata quando desejamos compartilhar comportamento entre v√°rios tipos. Em uma classe abstrata podemos definir vari√°veis e m√©todos, mas tamb√©m podemos definir m√©todos abstratos (usando o modificador `abstract`). Ao se declara um m√©todo abstrato, estamos declarando apenas a assinatura, a implementa√ß√£o ficar√° a cargo de alguma classe que estende nossa classe abstrata.

E por fim uma classe √© uma implementa√ß√£o pela qual podemos instanciar objetos. Classes podem ser estendidas tamb√©m quando queremos modificar um comportamento espec√≠fico. Por exemplo, e se quisermos modificar a forma como o Garfield mia?

[source,java]
----
Gato garfield = new Gato(15.0, Cor.LARANJA, Temperamento.PREGUICOSO) {
    public void meow() {
        System.out.println("Miaaaaaaau!");
    }
};
----

Quando adicionamos um bloco de c√≥digo lodo ap√≥s a instancia√ß√£o da classe, estamos criando uma classe an√¥nima. Esse comportamento ser√° especifico dessa inst√¢ncia. N√≥s poder√≠amos evitar isso usando o modificador `final` no m√©todo ou na classe. Se usarmos no m√©todo, nenhuma subclasse poder√° estender esse m√©todo, mas se usarmos na classe, ela n√£o poder√° ser estendida.

Quando falamos de heran√ßa normalmente usamos as palavras estende e implementa. Estende √© quando temos uma classe abstrata sendo estendida, e isso √© feito usando a palavra reservada `extends`. J√° implementa √© quando temos uma interface sendo implementada pela classe, a palavra reservada `implements`.

O Java tem algumas limita√ß√µes em heran√ßas. Uma classe S√ì pode estender uma classe, mas pode implementar quantas interfaces forem necess√°rias. MAS interfaces com mesma assinatura e tipo de retorno diferentes n√£o s√£o poss√≠veis de serem implementas por uma mesma classe. No caso abaixo, temos que um `Gato` estende um `Felino` e implementa as interfaces `Miador` e `Ronronador`.

[source,java]
----
public class Gato extends Felino implements Miador, Ronronador {
    // Implementa√ß√£o
}
----

[#cap-04-conceitos-oo]
=== Conceitos da Orienta√ß√£o a Objetos

Agora vamos discutir alguns conceitos comuns da orienta√ß√£o a objetos que podem nos auxiliar no dia a dia.

==== Heran√ßa

Para entender heran√ßa, podemos pensar em heran√ßa gen√©tica. Todo objeto ele tem um arqu√©tipo e ele vai possuir uma hierarquia de tipos. Um `Gato` √© um `Felino` que √© um `Animal`. Cada uma dessas classes podem ter comportamentos associados ou apenas assinaturas de m√©todos. Se voltarmos no post anterior, sobre a biblioteca `Collections`, vamos ver o mais comum tipo de heran√ßa.

[.text-center]
.Pacote Java Collections
image::java-101/cap-03/Collections.png[id=jdk-lib-collections, align="center"]

Vamos ver o caso da `LinkedList` que estende uma `AbstractSequentialList` e implementa as interface `List`, `Deque`, `Cloneable` e `Serializable`.

`LinkedList` √© uma classe, `AbstractSequentialList` √© uma classe abstrata e `List` uma interface. `AbstractSequentialList` cont√©m uma implementa√ß√£o de lista que por sua v√™z estende uma `AbstractList`. Podemos dizer que `LinkedList` herda implementa√ß√µes de `AbstractSequentialList` e `AbstractList`. Assim como podemos dizer que `LinkedList` e `ArrayList` herdam implementa√ß√µes de `AbstractList` mesmo tendo comportamentos completamente diferentes. 

Da mesma forma `LinkedList` e `ArrayList` s√£o tipos de `List`, enquanto apenas `LinkedList` √© um tipo de `Deque`.

Quando temos uma classe que herda tipos de outras classe, podemos definir nossos objetos com o tipo que desejarmos. Eu recomendo sempre usar a interface que voc√™ deseja usar e n√£o a implementa√ß√£o final. Quer um exemplo? Vamos imaginar que eu quero definir um m√©todo que far√° uma busca especifica pelo Gato mais gordo. Ao inv√©s de declarar que desejo receber uma `LinkedList`, posso declarar que desejo receber apenas uma `List`.

[source,java]
----
public class Gatos {
    public static Gato maisGordo(List<Gato> gatos) {
        // encontra o Garfield aqui que n√£o tem erro.
    }
}
----

Uma d√∫vida cl√°ssica √© se perguntar porque n√£o devo usar o tipo mais espec√≠fico. Nunca devemos usar as classes porque isso limita o uso do nosso c√≥digo. Ao usar um `List`, eu posso aceitar qualquer implementa√ß√£o de `List`, mesmo implementa√ß√µes que eu n√£o conhe√ßo. Essa preocupa√ß√£o ser√° muito mais real quando estivermos falando de frameworks em que a gera√ß√£o de c√≥digo ou classes do tipo proxy s√£o comuns. 

==== Override

Chamamos de _Override_ a pr√°tica de sobrescrever implementa√ß√µes de m√©todos em classes filhos. Vamos voltar ao nosso exemplo de Gatos, e se existe uma ra√ßa especifica de gatos que n√£o mia, s√£o gatos mudos. Como esse caracter√≠stica √© muito especifica mas ele definitivamente s√£o gatos, podemos criar essa nova classe de gatos e sobrescrever o m√©todo.

[source,java]
----
public class GatoMudo extends Gato {

    @Override
    public void meow() {
        System.out.println("."); // . significa sil√™ncio
    }

}
----

Se tivermos um objeto da classe `GatoMudo`, mesmo que ele esteja definido como `Gato`, ser√° chamado o m√©todo da classe `GatoMudo`.

O uso da anota√ß√£o `@Override` n√£o √© obrigat√≥rio, mas √© altamente recomend√°vel.  

==== Overload

Chamamos de _Overload_ quando criamos um novo m√©todo para um tipo diferente de par√¢metros. Essa t√©cnica √© excelente quando queremos criar m√©todos semelhantes para tipos diferentes. Vamos supor que nosso m√©todo de `mistura` vai ser migrado para a classe abstrata de animais e que queremos criar esse m√©todo para alguns tipos de animais, n√£o para todos, mas ele ser√° diferente para alguns grupos (tem animal que se divide e n√£o reproduz). Assim podemos criar um m√©todo mistura para os tipos `Mamifero`, `Ave`, `Reptil` e `Peixe`, cada m√©todo ter√° uma implementa√ß√£o completamente diferente.

[source,java]
----
public class Gato {
    public static Mamifero mistura(Mamifero mamiferoA, Mamifero mamiferoB) {
        // M√°gica acontece
        return mamiferoC;
    }

    public static Ave mistura(Ave aveA, Ave aveB) {
        // M√°gica acontece
        return aveC;
    }

    public static Reptil mistura(Reptil reptilA, Reptil reptilB) {
        // M√°gica acontece
        return reptilC;
    }

    public static Peixe mistura(Peixe peixeA, Peixe peixeB) {
        // M√°gica acontece
        return peixeC;
    }
}
----

N√≥s fizemos _overload_ de um m√©todo est√°tico, mas poder√≠amos ter feito de um m√©todo de inst√¢ncia.

==== HashCode, Equals e ToString

Uma outra reclama√ß√£o constante de quem n√£o gosta de Java √© a necessidade de se implementar esses tr√™s m√©todos que as vezes parecem in√∫teis.

Primeiro devemos esclarecer que `hashCode`, `equals` e `toString` s√£o m√©todos extremamente √∫teis e usados constantemente pela JVM. √â sempre recomend√°vel a leitura da documenta√ß√£o da classe https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Object.html[Object] sobre esses tr√™s m√©todos.

`hashCode` √© um m√©todo usado para o calculo do _Hash_ do objeto. O hash √© um valor inteiro que ser√° usado para identificar cada objeto. Dois objetos iguais devem ter o mesmo hash, mas dois objetos com o mesmo hash n√£o s√£o iguais. Toda e qualquer classe usando o nome Hash usar esse m√©todo, assim se voc√™ tem um `HashMap` ou um `HashSet`, voc√™ tem o uso do m√©todo.

`equals` √© um m√©todo usado para se verificar um objeto √© igual a outro. Ele √© usado por v√°rias algoritmos da JVM, as vezes associado com o hash ou sem associa√ß√£o. Quando temos um `HashMap` os dois m√©todos s√£o usados. O `equals` √© usando quando temos o que chamamos de **Colis√£o de Hash**, dois objetos diferentes que tem o mesmo hash.

`toString` √© usado para se criar um valor String para a classe. Sempre implemente o toString para melhorar o rastreamento de erros em logs de execu√ß√£o.

[#cap-04-passagem-por-valor-e-referencia]
=== Passagem por valor e Passagem por refer√™ncia

Quando estudamos linguagem como C, estudar o tipo de passagem como argumento de uma fun√ß√£o √© muito importante, porque √© poss√≠vel controlar o que queremos fazer ao se escolher o tipo de par√¢metro. J√° em Java n√£o nos preocupamos muito, mas em ambas a linguagem temos a possibilidade de se passar um argumento como valor ou como refer√™ncia. Vamos primeiro definir para depois mostrar como pode ser feito?

Falamos de **Passagem por valor** de um argumento para uma fun√ß√£o quando ao se alterar o valor desse argumento dentro de um fun√ß√£o, essa altera√ß√£o n√£o √© refletida fora da fun√ß√£o. J√° quando falamos de **Passagem por refer√™ncia** de um argumento, ao se alterar o valor desse argumento dentro da fun√ß√£o ele √© refletido fora da fun√ß√£o. F√°cil de entender? N√£o?!?!

Em C, isso √© meio √≥bvio porque podemos passar o valor ou a refer√™ncia. Vou tentar mostrar aqui:

[source,c]
----
#include <stdio.h>

int incrementaValor(int valor) {
    return valor + 1;
}

int incrementaReferencia(int * valor) {
    (*valor)++
    return *valor;
}

int main() {
    int contador = 0;
    printf("Valor: %d\n", incrementaValor(contador));  // Imprime "Valor: 1"
    printf("Valor: %d\n", incrementaValor(contador));  // Imprime "Valor: 1"

    printf("Valor: %d\n", incrementaReferencia(&contador));  // Imprime "Valor: 1"
    printf("Valor: %d\n", incrementaReferencia(&contador));  // Imprime "Valor: 2"
    return 0;
}
----

O que acontece quando eu chamo a fun√ß√£o `incrementaValor` √© que uma c√≥pia do contador √© enviado para a fun√ß√£o, mas quando chamo `incrementaReferencia` o pr√≥prio contador √© enviado para a fun√ß√£o.

Em Java s√≥ temos passagem por valor quando usamos tipos primitivos (`byte`, `short`, `int`, `long`, `float`, `double` ou `char`). Quando definimos um objeto, sempre estamos passando a refer√™ncia do mesmo para fun√ß√µes. Por isso √© muito importante entender o que √© e como garantir imutabilidade. Quando formos falar de mem√≥ria, vou explicar o que √© o conceito de mem√≥ria e como isso funciona na pr√°tica, mas, resumidamente, tipos primitivos s√£o armazenados na stack do programa enquanto todas as classes s√£o armazenados na memoria heap do programa. Ao se criar um objeto, um ponteiro na stack √© criado para um novo espa√ßo de memoria alocado na Heap. _Calma, voc√™ n√£o tem obriga√ß√£o de entender isso facilmente_!!!

=== Imutabilidade e Mutabilidade

Chamamos de mutabilidade a capacidade de um objeto ter seu estado interno alterado. Em orienta√ß√£o a objetos mutabilidade √© um requisito desejado para quase todas as classes, por isso que s√≥ recentemente o Java incorporou o conceito de imutabilidade a linguagem atrav√©s dos Records. Antes dos Records era comum se usar POJOs em que existia para cada campo um respectivo `get` e um `set`.

.POJO
[sidebar]
POJO √© um acr√¥nimo para _Plain Old Java Object_, que significa velho e simples objeto Java. √â um termo usado para referenciar um padr√£o de classes Java que n√£o dependem da heran√ßa de interfaces ou classes de frameworks externos.

Records √© o tipo que adiciona o conceito de imutabilidade ao c√≥digo Java. Abaixo vou definir a classe **Usuario** tr√™s vezes. Na primeira vez ela √© mut√°vel, na segunda imut√°vel usando POJO e na terceira usando record.

[source,java]
----
public class Usuario {
    private int id;
    private String username;
    private String email;

    public Usuario(int id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    // Implementa hashCode, equals e toString
}
----

Para implementar um campo imut√°vel, devemos usar o modificador de acesso `final`. Um campo final ter√° seu valor definido no construtor e n√£o poder√° ser alterado em todo ciclo de vida do objeto.

[source,java]
----
public class Usuario {
    private final int id;
    private final String username;
    private final String email;

    public Usuario(int id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }

    public int getId() {
        return id;
    }

    public String getUsername() {
        return username;
    }

    public String getEmail() {
        return email;
    }

    // Implementa hashCode, equals e toString
}
----

Ao usar records, √© como se todos os campos j√° fossem definidos como final, mas a grande vantagem se d√° que n√£o precisamos implementar os m√©todos `hashCode`, `equals` e `toString`.

[source,java]
----
public record Usuario(int id, String username, String email) {}
----

[#cap-04-conclusao]
== Conclus√£o

Orienta√ß√£o a Objeto √© uma √≥tima t√©cnica para fazer design de c√≥digo. Ela √© melhor utilizada quando tempos que modelar problemas do mundo real, mas haver√° dificuldade se o modelo for mais pr√≥ximo de um modelo matem√°tico.

O principal ganho com a modelagem a Orienta√ß√£o a Objetos √© a capacidade de se encapsular complexidades.
