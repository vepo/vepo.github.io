---
title: A sintaxe do Java
published: true
description: Voc√™ sabe o que √© o m√≠nimo que voc√™ precisa saber pra desenvolver Java? Aqui eu vou apresentar um pouco da sintaxe do Java. Quero passar por todas as estruturas que v√£o fazer voc√™ criar o melhor c√≥digo poss√≠vel.
tags: [Java, Tutorial]
cover_image: /assets/images/java/duke-thinking.png
series: Java 101
permalink: /posts/java-101-sintaxe
publish_date: 2022-04-29 15:26:00 +0300
---

:figure-caption: Figura
:imagesdir: /assets/images/java-101

A inten√ß√£o desse material √© te apresentar o b√°sico sobre Java oferecendo ferramentas para que voc√™ possa aprender a programar. Nenhum material por s√≠ s√≥ far√° o trabalho completo, para que voc√™ possa se tornar um desenvolvedor √© preciso muito exerc√≠cio, por isso v√° lentamente avan√ßando sobre os t√≥picos propostos e fazendo todos os exerc√≠cios propostos.

Nesse sess√£o voc√™ vai aprender:

* O que √© uma linguagem de programa√ß√£o e no que ela difere de uma linguagem natural
* Os elementos b√°sicos da sintaxe da linguagem Java

---

Anteriormente aprendemos o que √© Java, porque precisamos de uma linguagem de programa√ß√£o e como criar nosso primeiro programa Java. Agora vamos aprender um pouco mais a sintaxe Java e sobre um assunto muito importante para qualquer desenvolvedor: algoritmos. Qualquer linguagem de programa√ß√£o tem uma sintaxe e voc√™ tem que respeitar ela por um motivo meio √≥bvio e muito importante: o computador √© extremamente burro.

== Linguagens Formais e Linguagem Natural

Antes de entender porque o computador √© extremamente burro, vamos tentar diferenciar uma linguagem de programa√ß√£o das linguagens que usamos para conversar com outras pessoas. Se voc√™ nunca estudou formalmente o que √© uma linguagem de programa√ß√£o, talvez seja preciso definir corretamente o que a difere de outras linguagens.

No dia a dia, n√≥s somos acostumados a um tipo de linguagem que √© extremamente male√°vel e pode ser compreendida mesmo que esteja **formalmente** errada. Eu posso omitir um objeto, inverter sujeito e predicado (todo mundo entendia o Mestre Yoda) e a comunica√ß√£o continua acontecendo normalmente. Na nossa cultura, infelizmente, s√£o raras as pessoas que amam estudar a estrutura de portugu√™s, eu mesmo n√£o sou uma delas apesar de gostar de leitura. Conhecer mais a l√≠ngua que falamos n√£o √© comum porque podemos ser entendidos facilmente mesmo usando estruturas b√°sicas e √© uma atividade herc√∫lea e extremamente chata. O portugu√™s por ser uma l√≠ngua falada em locais bem diferentes √© cheio de regras e excuss√µes de dif√≠cil entendimento, a nossa l√≠ngua √© falada no Brasil üáßüá∑, Angola üá¶üá¥, Cabo Verde üá®üáª, Guin√©-Bissau üá¨üáº, Guin√© Equatorial üá¨üá∂, Mo√ßambique üá≤üáø, S√£o Tom√© e Pr√≠ncipe üá∏üáπ, Timor-Leste üáπüá±, China üá®üá≥ e at√© em Portugal üáµüáπ. Esse texto mesmo, apesar de parecer correto, se passar por uma revis√£o profissional ser√° alvo de v√°rias corre√ß√µes sutis que fa√ßo porque s√£o comuns na coloquialidade mas podem casuar pequenos desentendimentos na l√≠ngua escrita, o mais comum deles √© a troca de pessoa ao me referir a voc√™ leitor.

As l√≠nguas Portugu√™s, Ingl√™s, Mandarim, Japon√™s e at√© o https://www.amazon.com.br/homem-sabia-javan%C3%AAs-outros-contos/dp/6550970016?crid=2AKGVQNZY4970&keywords=o+homem+que+falava+javanes&qid=1657880499&sprefix=javan%C3%8As%2Caps%2C415&sr=8-1&linkCode=ll1&tag=vepo0f-20&linkId=7efd916b98ad99a20e6be0794730cf47&language=pt_BR&ref_=as_li_ss_tl[Javan√™s] s√£o o que conhecemos como linguagens naturais, pois elas emergem da experi√™ncia humana e s√£o compreendidas por humanos. Computadores n√£o entendem essas linguagens, eles podem apenas capturar s√≠mbolos, mas eles n√£o conseguem compreender. 

_‚Äî Ah, mas tem o GPT-3 que consegue ler e escrever bons textos._

Calma l√°! √â preciso entender como funciona um computador para n√£o cair no jornalismo barato e marketing agressivo de companhias de Intelig√™ncia Artificial. GPT-3 n√£o √© aquilo que foi prometido e tem suas limita√ß√µes. Eu recomendo ler o artigo https://www.technologyreview.com/2020/08/22/1007539/gpt3-openai-language-generator-artificial-intelligence-ai-opinion/["GPT-3, Fals√°rio: o gerador de linguagem do OpenAI n√£o tem ideia do que est√° falando"] (se n√£o l√™ ingl√™s, use o Google Translator). O entendimento do que √© uma linguagem de programa√ß√£o √© muito importante, por isso vamos fazer uma analogia para demonstrar como lidar com a gram√°tica delas.

Imagine que https://pt.wikipedia.org/wiki/Quarto_chin%C3%AAs[um computador √© como um falante de portugu√™s que est√° preso dentro de um quarto com um livro de regras. Sua fun√ß√£o √©, ao receber caixas com texto em chin√™s, deve consultar o livro de regras para identificar os s√≠mbolos no texto e formular uma resposta baseado nas regras e no texto recebido e enviar a resposta para fora do quarto.] Esse homem n√£o sabe chin√™s e nem consegue compreender o que ele est√° respondendo, ele s√≥ est√° seguindo as regras de quem escreveu o livro. O homem compreende a comunica√ß√£o? Ao interlocutor fora do quarto, parece que o homem fala chin√™s?

[.text-center]
.O Quarto Chin√™s
image::java-101/cap-02/o-quarto-chines.png[id=o-quarto-chines, align="center"]

Programas s√£o o livro de regras que √© escrito por programadores. Isso significa que, por melhor que seja um programa, um computador n√£o tem compreens√£o do que est√° acontecendo. O interlocutor at√© poder√° acreditar que o programa entende chin√™s, mas se houver alguma situa√ß√£o n√£o prevista no livro de regras, n√£o ser√° poss√≠vel formular uma resposta e o interlocutor ficar√° em d√∫vida.

Como j√° falamos, um computador √© uma entidade extremamente burra. Ela s√≥ vai conseguir compreender as regras se elas forem muito bem escritas em uma linguagem muito bem estruturada. Essa linguagem vai ter uma sintaxe bem definida e se por algum motivo ela for violada o computador n√£o ser√° capaz de compreender. Ou seja, o computador n√£o pode usar daquilo que todos os humanos tem: bom senso. Ele n√£o vai conseguir compreender se um sujeito for omitido. √â por esse motivo que as chamamos de **Linguagens Formais**.

.Linguagens Formais
[sidebar]
S√£o linguagens que podem ser representadas de maneira finita e precisa atrav√©s de sistemas com sustenta√ß√£o matem√°tica (dispositivos formais ou modelos matem√°ticos).

Java, C, Javascript, PHP, Python, etc... s√£o linguagens formais. Elas n√£o emergem da experi√™ncia humana, mas s√£o propostas por humanos para se comunicar com computadores. Um humano consegue identificar um erro em uma linguagem natural e mesmo assim compreender o que √© proposto, mas um erro em uma linguagem formal impossibilita todo o processo. Se voc√™ quiser saber como definir uma linguagem formal, eu j√° escrevi sobre isso em https://blog.vepo.dev/posts/como-criar-uma-linguagem-usando-antlr4-e-java["Como criar uma linguagem usando ANTLR4 e Java"].

== A Sintaxe Java

Agora vamos falar do Java... Java √© uma linguagem que normalmente chamamos de _C-Like_, isso significa que ela herda muitas caracter√≠sticas do C. Se voc√™ nunca ouviu falar de C, n√£o se preocupe, apesar dela ser uma das linguagens mais influente da hist√≥ria, ela n√£o tem muito espa√ßo no desenvolvimento web moderno, est√° nichada em desenvolvimento embarcado e nos drivers e kernel dos sistemas operacionais. Mas o C emprestou ao Java muito das estruturas que usamos no dia a dia e s√£o nessas estruturas que vamos focar por enquanto.

O C √© uma linguagem de prop√≥sito geral e estruturada. Isso significa que √© poss√≠vel escrever qualquer tipo de programa com ela, mas por suas caracter√≠sticas o estilo de programa√ß√£o mais comum √© o imperativa. Quando falamos de https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa[paradigma imperativa] dizemos que nosso programa est√° definindo a forma como as coisas devem ser feitas e n√£o a defini√ß√£o formal da solu√ß√£o, como acontece com a https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_declarativa[programa√ß√£o declarativa]. A programa√ß√£o declarativa est√° focada na transforma√ß√£o do dado, enquanto a programa√ß√£o imperativa ir√° ditar os passos que devemos fazer para transformar os dados.

Com o Java √© poss√≠vel programar das duas formas, mas como vamos estudar a sintaxe da linguagem vamos nos preocupar por enquanto apenas com a programa√ß√£o imperativa, por isso vamos deixar orienta√ß√£o a objetos e programa√ß√£o funcional para outro momento. Pensar no Java como uma linguagem imperativa √© pensar que devemos escrever um programa que ir√° transformar os dados de acordo com os passos que definimos, ent√£o precisamos pensar em como esses dados ser√£o transformados. Esse "como" √© o que chamamos de algoritmo. Algoritmo √© uma receita de bolo muito bem definida que transforma dados. Por "muito bem definida" entenda que ele deve ter uma entrada, uma sa√≠da e passos definidos, os passos ser√£o definidos atrav√©s da sintaxe.

J√° falei que um computador √© algo extremamente burro? Sim! Tudo que ele faz √© ler um programa, executar uma instru√ß√£o e executar a pr√≥xima instru√ß√£o. Cada instru√ß√£o altera o estado interno da aplica√ß√£o, esse estado por sua vez √© a mem√≥ria do computador. Quando falamos de programa√ß√£o imperativa, como o fluxo da aplica√ß√£o define os processos de transforma√ß√£o do dado a execu√ß√£o pode ter caminhos diferente dependendo dos dados. Em muitos casos o processo pode ser visualizado atrav√©s de fluxogramas simples. Sempre que voc√™ for tentar entender um programa estrutural, voc√™ vai ter que ter em mente quais s√£o os dados relevantes na execu√ß√£o e o fluxo da execu√ß√£o.

[.text-center]
.Fluxograma simples definindo o processo de leitura de um arquivo.
image::java-101/cap-02/fluxograma.png[id=fluxograma, align="center"]

As estruturas que vamos falar s√£o usadas para definir esse fluxo, como em todas linguagens _C-like_ elas tem nomes em ingl√™s mas elas refletem as decis√µes que devem ser feitas baseadas nos dados em mem√≥ria. Essas estruturas s√£o validadas em temos de compila√ß√£o, mas se voc√™ usa uma boa IDE voc√™ vai ver se houver um erro durante a edi√ß√£o do seu c√≥digo fonte. Enquanto essas estruturas n√£o estiverem muito bem definidas, o programa n√£o poder√° ser compilado e por isso n√£o poder√° ser executado.

Para facilitar o entendimento do fluxo, abaixo listo todas as estruturas que vamos detalhar resumidamente com uma tradu√ß√£o livre to termo em portugu√™s. Ao lado de cada uma temos a documenta√ß√£o oficial (para vers√£o 8 do Java) com a especifica√ß√£o formal. N√£o se preocupe se voc√™ n√£o conseguir entender a documenta√ß√£o. Eu fiz a tradu√ß√£o para que voc√™ possa compreender melhor, nunca a utilize porque isso n√£o √© comum, a n√£o ser que voc√™ deseje aprender https://potigol.github.io/docs/[Potigol], a tradu√ß√£o serve para voc√™ ver que tem uma l√≥gica na nomenclatura, √© como se o c√≥digo fosse um tipo de linguagem verbaliz√°vel.

<<cap-02-bloco>>

<<cap-02-declaracao>>

<<cap-02-variaveis>>

<<cap-02-comentario>>

<<cap-02-se>>

<<cap-02-enquanto>>

<<cap-02-faca-enquanto>>

<<cap-02-para>>

<<cap-02-escolha>>

<<cap-02-quebra>>

<<cap-02-lance>>

<<cap-02-sincronizado>>

<<cap-02-operador-logico>>

<<cap-02-operador-binario>>

<<cap-02-operador-matemarico>>

<<cap-02-operador-unario>>

<<cap-02-cast>>

<<cap-02-operador-condicional>>

[#cap-02-bloco]
=== 1. Bloco (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.2[Block])

Um bloco de c√≥digo √© uma estrutura que pode ser tanto obrigat√≥ria quanto opcional. Essa estrutura √© definida `{}` e dentro desse bloco teremos um novo escopo de vari√°veis assim como as instru√ß√µes que v√£o definir esse bloco. Por escopo entenda que toda vari√°vel definida dentro de um bloco ser√° conhecida apenas por aquele bloco e todo bloco definido dentro dele. Vamos ver a defini√ß√£o de vari√°vel no pr√≥ximo t√≥pico.

Observe o c√≥digo abaixo. Nele temos os blocos `B1` a `B4`. Os blocos `B1` e `B2` fazem parte de estruturas mais complexas e s√£o obrigat√≥rios, que no caso s√£o uma classe e um m√©todo respectivamente (n√£o vamos falar da defini√ß√£o de classe e m√©todo por enquanto). J√° os blocos `B3` e `B4` s√£o opcionais e est√£o a√≠ para mostrar que podemos criar um bloco quando bem entendermos, apesar dessa n√£o ser uma pr√°tica comum no desenvolvimento Java. ü§ì

[source,java]
----
public class HelloWorldSintaxe { // B1
    public static void main(String[] args) { // B2
        System.out.println("Ol√° mundo");

        String variavel = "abc";
        System.out.println("Valor de variavel=" + variavel);

        {} // B3: Bloco vazio

        { // B4
            String variavel2 = "xyz";
            System.out.println("Valor de variavel2=" + variavel2);
        } 

        // System.out.println("Valor de variavel2=" + variavel2);  // Se voc√™
    }

    // private void x() return 1; // Bloco √© obrigat√≥rio no caso de m√©todo, essa constru√ß√£o vai falhar 
}
----

Se voc√™ come√ßar a brincar com esse c√≥digo, vai ver que a `variavel2` s√≥ pode ser usada dentro do `B4`. Isso √© o que chamamos de escopo, ao finalizar a execu√ß√£o de `B4` ela √© completamente desnecess√°ria e poder√° ser eliminada da mem√≥ria. 

[#cap-02-declaracao]
=== 2. Declara√ß√£o (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.5[Statement])

Se voc√™ pegar um c√≥digo Java, ou de qualquer outra linguagem _C-Like_, vai perceber que o comportamento dele √© sempre similar. Existe um m√©todo/fun√ß√£o `main` que deve ter uma assinatura especifica e uma s√©rie de declara√ß√µes.

[source,java]
----
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
----

No c√≥digo acima, temos o mais simples _Hello World_ escrito em Java. Quando a JVM vai executar esse c√≥digo ser√° feito como √© feito em qualquer outra linguagem imperativa, primeiro a JVM l√™ a primeira declara√ß√£o, executa ela alterando o estado do programa, e depois executa a pr√≥xima at√© n√£o existirem mais declara√ß√µes ou o programa for finalizado por alguma instru√ß√£o.

Podemos dizer que toda estrutura Java √© uma declara√ß√£o e toda declara√ß√£o tem significado. Declara√ß√µes em Java devem ser separadas por `;` ou devem conter um Bloco de c√≥digo. Tudo que devemos entender de uma declara√ß√£o √© que ela tem um significado e que elas s√£o executadas em sequencia.

Vamos imaginar um outro c√≥digo hipot√©tico que √© composto pela chama de 3 m√©todos. Tudo que podemos supor √© que as tr√™s declara√ß√µes s√£o executadas em sequ√™ncia, desde que n√£o aconte√ßa nada excepcional.

[source,java]
----
metodo1();
declaracao1();
metodo2();
----

[#cap-02-variaveis]
=== 3. Defini√ß√£o de Vari√°veis (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.4[Local Variable Declaration])

Vari√°veis s√£o posi√ß√µes da mem√≥ria usadas para armazenar informa√ß√µes necess√°rias durante a execu√ß√£o do c√≥digo. Uma vari√°vel pode ser de um tipo primitivo (`byte`, `short`, `int`, `long`, `float` `double`, `boolean` ou `char`) ou um objeto. Tipos primitivos diferem de objeto porque armazenam apenas um valor sem ter nenhum m√©todo associado a ele. Uma vari√°vel ir√° pertencer a um bloco de c√≥digo e sua exist√™ncia existe do momento da declara√ß√£o at√© a finaliza√ß√£o do bloco. Como falamos, vari√°veis s√£o posi√ß√µes de mem√≥ria, mas existem dois tipos de mem√≥ria em Java, que vamos falar posteriormente, a heap e a stack. Tipos primitivos s√£o declarados na heap, enquanto objetos s√£o declarados na heap, isso significa que para tipos primitivos cada vari√°vel √© uma posi√ß√£o √∫nica enquanto um mesmo objeto pode ser compartilhado por v√°rias vari√°veis. 

_‚Äî Ein?!?!_

Sim! A princ√≠pio √© dif√≠cil de entender. Todo bloco de c√≥digo possui um valor associado a uma vari√°vel, no tipo primitivo temos na vari√°vel o valor exato enquanto nos objetos temos uma refer√™ncia ao valor. Vamos demonstrar por um exemplo? D√™ uma olhada no c√≥digo abaixo. Observer que uma defini√ß√£o de vari√°vel sempre √© acompanhada no formato `<tipo> <nome da vari√°vel> = <valor>;`.

[source,java]
----
int x = 0;    // x = 0
int y = x;    // x = 0,  y = 0
x = y + 20;   // x = 20, y = 0
y = 10;       // x = 20, y = 10

Usuario usr1 = new Usu√°rio(1, "Jo√£o"); // usr1 = Usuario[id=1, nome=Jo√£o]
Usuario usr2 = usr1;                   // usr1 = Usuario[id=1, nome=Jo√£o],     usr2 = Usuario[id=1, nome=Jo√£o]
Usuario usr3 = new Usu√°rio(1, "Jo√£o"); // usr1 = Usuario[id=1, nome=Jo√£o],     usr2 = Usuario[id=1, nome=Jo√£o],     usr3 = Usuario[id=1, nome=Jo√£o]
usr1.setNome("Jo√£o Doe");              // usr1 = Usuario[id=1, nome=Jo√£o Doe], usr2 = Usuario[id=1, nome=Jo√£o Doe], usr3 = Usuario[id=1, nome=Jo√£o]
usr1 = null;                           // usr1 = null,                         usr2 = Usuario[id=1, nome=Jo√£o Doe], usr3 = Usuario[id=1, nome=Jo√£o]
----

No c√≥digo acima vemos os dois tipos de dados, temos a classe `Usuario` e temos o tipo primitivo `int`. Quando criamos uma vari√°vel do tipo primitivo a partir de outro valor, podemos alterar livremente o outro valor que a nova vari√°vel permanecer√° inalterada. Mas o mesmo n√£o acontece com a classe `Usuario`, que apesar de todos terem valores iguais, `usr1` e `usr2` por algum momento apontam para o mesmo objeto. `usr3` nunca se altera porque √© um objeto distinto mesmo tendo o mesmo valor que `usr1` e `usr2`.

Na √∫ltima linha do trecho de c√≥digo usamos o valor `null`. `null` n√£o √© um tipo, apenas significa nulo em tradu√ß√£o livre, mas em computa√ß√£o significa a aus√™ncia de valor. √â quando dizemos que uma vari√°vel n√£o contem valor, ela n√£o aponta para lugar nenhum. Vari√°veis que s√£o tipos primitivos n√£o pode ser nulas, elas deve sempre ter um valor associado.

[#cap-02-comentario]
=== 4. Coment√°rio (https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.7[Comments])

Coment√°rios s√£o trechos de c√≥digo que ser√£o ignorados durante o processo de compila√ß√£o. Apesar que alguns autores falam que todo coment√°rio √© uma falha, afirma√ß√£o que eu discordo veementemente, eles s√£o necess√°rios para documentar informa√ß√µes que n√£o podem ser documentadas no c√≥digo. Tenha sempre em mente que coment√°rios s√£o necess√°rios, com o tempo e a experi√™ncia voc√™ vai aprender sobre o que escrever nos coment√°rios. Por enquanto vamos nos contentar em como comentar.

Existem 3 tipos de coment√°rios em Java:
1. Coment√°rios de fim de linha
2. Coment√°rios tradicionais
3. Javadoc

Para criar um coment√°rio em linha, adicione os dois caracteres `//` e tudo que voc√™ escrever at√© o fim da linha ser√° desconsiderado durante a compila√ß√£o. O exemplo abaixo foi retirado do c√≥digo do https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L1012[Apache Kafka], apesar de estar em ingl√™s ele cont√©m informa√ß√µes relevantes ao c√≥digo.

[source,java]
----
// Try to calculate partition, but note that after this call it can be RecordMetadata.UNKNOWN_PARTITION,
// which means that the RecordAccumulator would pick a partition using built-in logic (which may
// take into account broker load, the amount of data produced to each partition, etc.).
int partition = partition(record, serializedKey, serializedValue, cluster);
----

Para criar um coment√°rio tradicional, inicie com `/**` e todo caractere at√© encontrar o final `**/` ser√° desconsiderado. Abaixo temos mais um coment√°rio retirado do c√≥digo do https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java#L289[Apache Kafka], ele explica a decis√£o de n√£o existir um `break` naquela posi√ß√£o como veremos mais a frente.


[source,java]
----
case REAUTH_RECEIVE_HANDSHAKE_OR_OTHER_RESPONSE:
    handshakeResponse = (SaslHandshakeResponse) receiveKafkaResponse();
    if (handshakeResponse == null)
        break;
    handleSaslHandshakeResponse(handshakeResponse);
    setSaslState(SaslState.REAUTH_INITIAL); // Will set immediately
    /*
     * Fall through and start SASL authentication using the configured client
     * mechanism. Note that we have to either fall through or add a loop to enter
     * the switch statement again. We will fall through to avoid adding the loop and
     * therefore minimize the changes to authentication-related code due to the
     * changes related to re-authentication.
     */
case REAUTH_INITIAL:
    sendInitialToken();
    setSaslState(SaslState.INTERMEDIATE);
    break
----

O Javadoc √© um tipo especial de coment√°rio tradicional que nos permite gerar uma documenta√ß√£o oficial a partir do c√≥digo. Ele se diferencia do coment√°rio tradicional por iniciar com `/****`, n√£o apenas `/**`, e pode estar acima de classes, m√©todos e campos. Javadoc segue uma linguagem de marca√ß√£o deve ser usada sempre, pois al√©m de poder ser usada como documenta√ß√£o oficial, ela tamb√©m ser√° exibida pelas IDEs em funcionalidades que ir√£o lhe auxiliar durante o desenvolvimento. Javadoc tamb√©m aceita tags HTML, as n√£o tente usar CSS e Javascript. 

No exemplo abaixo temos um trecho da documenta√ß√£o oficial do https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L1234[Apache Kafka]. √â interessante notar que o autor desse c√≥digo se preocupou em descrever a funcionalidade do m√©todo, e os motivos pelo qual as exce√ß√µes s√£o lan√ßadas, mas ignorou a descri√ß√£o do par√¢metro porque √© intuitivo. Evite coment√°rios desnecess√°rios.

[source,java]
----

/**
 * Get the partition metadata for the given topic. This can be used for custom partitioning.
 * @throws AuthenticationException if authentication fails. See the exception for more details
 * @throws AuthorizationException if not authorized to the specified topic. See the exception for more details
 * @throws InterruptException if the thread is interrupted while blocked
 * @throws TimeoutException if metadata could not be refreshed within {@code max.block.ms}
 * @throws KafkaException for all Kafka-related exceptions, including the case where this method is called after producer close
 */
@Override
public List<PartitionInfo> partitionsFor(String topic) {}
----

[.text-center]
.O coment√°rio acima gerou essa documenta√ß√£o.
image::java-101/cap-02javadoc.png[id=cap02-javadoc, align="center", link=https://kafka.apache.org/32/javadoc/org/apache/kafka/clients/producer/KafkaProducer.html#partitionsFor(java.lang.String)]

Comentar c√≥digo n√£o √© uma atividade simples, ela ser√° trabalhada com a maturidade. Com o tempo voc√™ vai aprende que informa√ß√µes devem ser consideradas auxiliar ao c√≥digo. Voc√™ n√£o precisa comentar o que est√° no c√≥digo, mas a informa√ß√£o que falta ao c√≥digo, n√£o √© o **como**, mas o **porque** do c√≥digo. Eu gosto de comentar pressupostos e escolhas arquiteturais porque em alguns meses eu n√£o vou lembrar ou outra pessoa que pegar meu c√≥digo tamb√©m n√£o vai saber o motivo de alguns escolhas.

[#cap-02-se]
=== 5. Se (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.9[if])

Agora vamos ver a primeira declara√ß√£o de fluxo que tamb√©m √© a mais comum. Mais conhecida como `if`, ou condicional, √© composto por `if (express√£o booleana) <bloco> else <bloco>`, onde express√£o booleana √© qualquer fun√ß√£o que retorne um `boolean` ou uma express√£o l√≥gica que veremos em Operadores L√≥gicos. A express√£o pode ser resumida para `if (express√£o booleana) <bloco>` ou pode ser encadeada em v√°rias outras declara√ß√µes condicionais `if (express√£o booleana) <bloco> else if (outra express√£o booleana) <bloco> else <bloco>`. 

[source,java]
----
int x = leNumeroInteiro();

if (x % 2 == 0) { // o operador % retorna o resto da divis√£o
    System.out.println("O valor lido √© par!");
} else {
    System.out.println("O valor lido √© impar!");
}

if (x % 3 == 0) {
    System.out.println("O valor lido √© m√∫ltiplo de 3!");
} else if (x % 3 == 1) {
    System.out.println("O valor lido tem a forma f(x) = 3x + 1");
} else {
    System.out.println("O valor lido tem a forma f(x) = 3x + 2");
}
----

No exemplo acima temos 3 express√µes l√≥gica. A primeira calcula se o valor √© par ent√£o logicamente o bloco else ser√° executado para todo valor impar. A segunda calcula se o valor √© divis√≠vel por 3, isso significa que o bloco else ser√° chamado para todo valor n√£o divis√≠vel, mas com o `if` encadeado fazemos a vis√£o daquele que s√£o no formato `3x + 1` e `3x + 2`. Vamos ver as express√µes mais a frente.

[#cap-02-enquanto]
=== 6. Enquanto (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.11[while])

Enquanto define que um bloco de c√≥digo ser√° executado at√© que uma express√£o l√≥gica seja falsa. A execu√ß√£o do bloco de c√≥digo √© feita continuamente logo depois do teste da express√£o l√≥gica. Exemplo?

[source,java]
----
int x = leValor();
while(x > 0) {
    System.out.println("Valor √© positivo!");
    x = leValor();
}
----

O bloco de c√≥digo acima ser√° executado continuamente at√© que venha um valor 0 ou negativo.

[#cap-02-faca-enquanto]
=== 7. Fa√ßa enquanto (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.13[do-while])

O Fa√ßa enquanto funciona de forma bem similar, a diferen√ßa √© que o teste √© feito depois que o bloco de c√≥digo √© executado. Ele √© muito similar a declara√ß√£o anterior, a diferen√ßa √© a ordem de execu√ß√£o entre o teste l√≥gico e o bloco de c√≥digo.

[source,java]
----
do {
    executa();
} while (emExecu√ß√£o)
----

[#cap-02-para]
=== 8. Para (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14[for])

O famoso `for` √© um pouco mais complexo. Ele √© composto por 3 blocos que podem ser chamados de **inicializa√ß√£o**, **condi√ß√£o** e **passo**. Ao iniciar ser√° executado uma √∫nica vez o trecho de c√≥digo **inicializa√ß√£o** e em cada itera√ß√£o ser√° executado o trecho de c√≥digo **condi√ß√£o**, que deve retornar uma express√£o booleana, depois ser√° executado o bloco de c√≥digo para depois ser executado o trecho **passo**. O exemplo mais comum √© para se iterar em um array.

[source,java]
----
int[] array = new int[] {0 , 1, 2, 3, 4, 5};
for (int i = 0; i < array.length; i++) {
    // bloco de c√≥digo
}
----

[#cap-02-escolha]
=== 9. Escolha (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.11[switch])

O `switch` escolhe o c√≥digo de acordo com o valor de uma vari√°vel. O `switch` √© uma estrutura que pode facilmente induzir a erros porque cada bloco n√£o √© exclusivo, o fluxo de execu√ß√£o passar de um bloco ao outro at√© que seja encontrada a instru√ß√£o `break`. Vamos ver um exemplo?

[source,java]
----
int x = leValor();
switch (x) {
    case 1:
        System.out.println("√â igual a 1!");
    case 2:
        System.out.println("√â maior ou igual a 2!");
    case 3:
        System.out.println("√â maior ou igual a 3!");
    case 4:
        System.out.println("√â maior ou igual a 4!");
    case 5:
        System.out.println("√â maior ou igual a 5!");
    default
        System.out.println("√â maior que 5 ou menor que 1!");
}
----

O que aconteceria se o valor de `x` for igual a 3? Seriam executados os blocos de 3 at√© o `default`.

[source]
----
√â maior ou igual a 3!
√â maior ou igual a 4!
√â maior ou igual a 5!
√â maior que 5 ou menor que 1!
----

Se quisermos um valor exato, podemos usar o break:

[source,java]
----
int x = leValor();
switch (x) {
    case 1:
        System.out.println("√â igual a 1!");
        break;
    case 2:
        System.out.println("√â igual a 2!");
        break;
    case 3:
        System.out.println("√â igual a 3!");
        break;
    case 4:
        System.out.println("√â igual a 4!");
        break;
    case 5:
        System.out.println("√â igual a 5!");
        break;
    default
        System.out.println("√â maior que 5 ou menor que 1!");
}
----

Agora voc√™ deve ter se perguntado porque no texto do bloco `default` eu usei _menor que 1_? Isso porque o `switch` n√£o √© usado para intervalos de valores, mas para valores exatos e caso nenhum valor seja igual aos valores declarados √© chamado o bloco `default`. 

Vale lembrar que o switch pode ser usado para n√∫meros, enumeradores e qualquer valor constante, inclusive String.

[#cap-02-quebra]
=== 10. Quebra e continua (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.15[break] e https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.16[continue])

Uma quebra deve ser chamada dentro bloco `switch`, `while`, `do` ou `for`. Ao se deparar com essa instru√ß√£o o programa ir√° finalizar a execu√ß√£o do bloco externo imediatamente.

Vamos demonstrar isso com um exemplo b√°sico? No c√≥digo abaixo vamos criar um `for` que ser√° finalizado usando `break`. Observe que o ponto de parada do for seria no m√°ximo inteiro poss√≠vel, mas atrav√©s do break finalizamos em 10.

[source,java]
----
System.out.println("Iniciando for...");
for (int i = 0; i < Integer.MAX_VALUE; i++) {
    System.out.println("Valor: " + i);
    if (i == 10) {
        break;
    }
}
----

Quando usamos `break` dentro de um switch evitamos que os blocos de c√≥digos abaixo dele seja executados.

O `continue` tem um comportamento parecido, mas ao inv√©s de finalizar o bloco ser√° apenas finalizada a itera√ß√£o. Ele s√≥ √© aceito em itera√ß√µes como `while`, `do` ou `for`. Vamos incrementar o exemplo acima para imprimir apenas n√∫meros impares. Observe que no c√≥digo abaixo foi preciso mudar a condi√ß√£o de execu√ß√£o do `break` porque ele nunca seria executado se us√°ssemos `i == 10`.

[source,java]
----
System.out.println("Iniciando for...");
for (int i = 0; i < Integer.MAX_VALUE; i++) {
    if (i % 2 == 0) {
        continue;
    }
    System.out.println("Valor: " + i);
    if (i > 10) {
        break;
    }
}
----

Se voc√™ leu a documenta√ß√£o atentamente, viu que `break` e `continue` podem aceitar r√≥tulos. O que isso significa? Vamos imaginar que temos um loop encadeado em que buscamos um valor dentro de uma matrix. Como as linhas dessa matrix s√£o ordenadas, se o valor em uma coluna for maior que o valor desejado, podemos pular para pr√≥xima linha. A decis√£o do `break` e do `continue` √© feita usando os r√≥tulos que todo bloco de c√≥digo aceita.

[source,java]
----
int[][] matrix = new int[][] {
        { 2, 2, 2, 3, 4, 5 },
        { 2, 4, 8, 8, 9, 9 },
        { 1, 2, 4, 5, 6, 8 },
        { 0, 3, 4, 8, 8, 9 },
        { 3, 4, 4, 6, 6, 9 },
        { 0, 3, 6, 7, 8, 8 },
};
linhas: for (int linha = 0; linha < matrix.length; ++linha) {
    colunas: for (int coluna = 0; coluna < matrix[linha].length; ++coluna) {
        if (matrix[linha][coluna] == 7) {
            System.out.println("N√∫mero 7 encontrado! (" + linha + "," + coluna + ")");
            break linhas;
        } else if (matrix[linha][coluna] > 7) {
            System.out.println("Desistindo da linha! (" + linha + "," + coluna + ")");
            continue linhas;
        } else if (matrix[linha][coluna] < 7) {
            System.out.println("Pulando para pr√≥xima coluna! (" + linha + "," + coluna + ")");
            continue colunas;
        }
        System.out.println("C√≥digo nunca executado!");
    }
}
----

Se n√£o fosse usado um r√≥tulo, o `break` e o `continue` iriam atuar somente no bloco de c√≥digo mais interno.

[#cap-02-lance]
=== 11. Lance (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.18[throw])

O `throw` deve ser usado quando algo excepcional acontece. Algo inesperado, tanto que ele lan√ßa uma `Exception`, que significa exce√ß√£o.

Exce√ß√µes podem ser tratadas em c√≥digo, mas as vezes elas n√£o podem ser tratadas o que implica a finaliza√ß√£o da execu√ß√£o. Ao se lan√ßar uma exception, a JVM vai criar uma estrutura que contem o contexto da execu√ß√£o que chamamos de Stacktrace.

Para entender o que √© uma Stacktrace, √© preciso entender como um programa lida com contextos. Quando executamos um bloco de c√≥digo √© criado uma posi√ß√£o no topo da pilha de execu√ß√£o (_stack_ √© pilha em ingl√™s). Ao terminar esse bloco, essa posi√ß√£o √© removida da pilha. Vamos olhar o programa abaixo:

[source,java]
----
public class StacktraceHelloWorld {
    private static void m1(int x) {
        if (x % 2 == 0 && x > 100) {
            throw new RuntimeException("Primeiro n√∫mero impar depois de 100");
        }
        m2(x + new Random().nextInt(2));
    }

    private static void m2(int j) {
        if (j % 2 == 0 && j > 100) {
            throw new RuntimeException("Primeiro n√∫mero par depois de 100");
        }
        m1(j + new Random().nextInt(2));
    }

    public static void main(String[] args) {
        m1(0);
    }
}
----

A pilha vai ter como funda√ß√£o o m√©todo `main`, depois ela ser√° formada por um encadeamento de chamadas ao m√©todos `m1` e `m2`. Nenhum dos elementos √© removido da pilha porque os m√©todos nunca terminam, els ficam se chamando at√© que a exce√ß√£o do tipo `RuntimeException` seja lan√ßada.

Esse exemplo √© meramente did√°tico para mostrar como funciona o uso do `throw`. Mas se alterarmos o tipo de `RuntimeException` para apenas `Exception` vemos que n√£o ser√° poss√≠vel de compilar porque h√° uma exce√ß√£o n√£o tratada (_Unhandled exception type Exception_). Isso acontece porque existem 3 tipos de exce√ß√µes:

1. `Error`
2. `RuntimeException`
3. `Exception`

`Error` n√£o deve ser definido em um programa. Ele ser√° lan√ßado quando a JVM n√£o souber lidar com uma situa√ß√£o especifica, o exemplo mais comum √© o `OutOfMemoryError` quando a JVM n√£o conseguir alocar mais mem√≥ria.

Uma `RuntimeException` √© uma exce√ß√£o que acontece em tempo de execu√ß√£o, mas poderia ser resolvido com pequenas valida√ß√µes, ou seja, √© algo deveria ter sido previsto. √â o que acontece quando valores nulos n√£o s√£o validados (`NullPointerException`) ou quando acontece a divis√£o por zero (`ArithmeticException`).

Os demais casos devem estender a classe `Exception`, mas ela adicionar√° uma peculiaridade ao c√≥digo. Se um m√©todo n√£o trata um `Exception`, ele deve declarar que lan√ßa a mesma. Isso porque ela √© um resultado esperado, mas que pode ou n√£o ser tratado em c√≥digo. Um exemplo? Quando estamos lidando com conex√µes de rede, sempre existe a possibilidade de a conex√£o ser finalizada, por isso sempre temos a `IOException`. Essa declara√ß√£o se d√° usando o `throws` e este n√£o pode ser ignorado. Ou a exce√ß√£o √© tratado no m√©todo acima ou lan√ßada para o pr√≥ximo m√©todo.

[source,java]
----
public void conecta() throws IOException {
    // abre e fecha conex√£o
}
----

[#cap-02-sincronizado]
=== 12. Sincronizado (https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.19[synchronized])

`synchronized` deve ser usada com muita parcim√¥nia. N√≥s vamos ver o seu uso mais a fundo quando formos falar de threads. Mas sendo sucinto, ela pode ser usada tanto para m√©todos quanto para objetos.

Para entender o conceito de sincronia, √© preciso entender o que √© paralelismo e concorr√™ncia. Eu tenho duas atividades que rodam em paralelo quando elas acontecem ao mesmo tempo e n√£o h√° interfer√™ncia entre si. Mas elas se tornam concorrentes quando existem recursos compartilhados que n√£o podem ser acessados ao mesmo tempo.

Dif√≠cil de entender, n√£o? Ent√£o vamos criar um modelo real. Digamos que uma loja tenha um livro caixa que deve registrar todas as vendas. Mas esse livro caixa s√≥ √© atualizado no final do dia atrav√©s das anota√ß√µes de cada vendedor. Assim quando o vendedor realiza uma venda, ele faz uma anota√ß√£o que depois ser√° repassada para o livro caixa. As vendas acontecem em paralelo. Mas ao finalizar a venda existe o registro do estoque que √© um caderno √∫nico que registra a entrada e sa√≠da de itens do estoque. Ou seja, quando o vendedor finaliza a venda, ele deve pegar o registro do estoque e adicionar uma sa√≠da. Se o vendedor A est√° em posse do registro, o vendedor B precisar√° ficar esperando, logo a baixa no caixa s√£o opera√ß√µes concorrentes.

`synchronized` ir√° definir sob qual objeto ser√° definida a sincronia da execu√ß√£o. Ele pode ser usado tanto para m√©todo (est√°tico ou de inst√¢ncia) ou objeto avulso.

[source,java]
----
class Concorrente {
    public static synchronized void syncStaticMethod() {
        // Toda execu√ß√£o desse m√©todo ser√° concorrente
    }

    public synchronized void syncMethod() {
        // Toda execu√ß√£o desse m√©todo ser√° concorrente somente se for a mesma inst√¢ncia de Concorrente
    }

    public void method(Object lock) {
        synchronized (lock) {
            // Toda execu√ß√£o desse bloco ser√° concorrente somente se a inst√¢ncia de lock for a mesma
        }
    }
}
----

Para que a sincronia seja bem elaborada, devem ser usados tamb√©m os m√©todos `wait`, `notify` e `notifyAll`. Mas n√≥s veremos como isso deve ser feito mais a frente, caso voc√™ precise lidar com valores compartilhados, prefira usar https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html[`AtomicReference`] ou outras classes do pacote https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html[`java.util.concurrent.atomic`].

[#cap-02-operador-logico]
=== 13. Operadores L√≥gicos

Os operadores l√≥gicos do Java s√£o usados para se criar express√µes booleanas. Uma express√£o booleana s√≥ pode retornar dois tipos de valores: verdadeiro ou falso. 

Como vimos no uso do `if`, devemos sempre definir um valor booleano, mas as vezes ele pode ser uma s√©rie de valores encadeados em uma express√£o.

√â muito importante saber resolver esses tipos de express√£o, essa √© um campo da matem√°tica que se chama Algebra Booleana e, na minha opini√£o, √© um dos requisitos mais b√°sicos para desenvolvimento de software.

No Java tempos tr√™s operadores booleanos `&&`, `||` e `!`

[options="header"]
|=====================================================================================
^| Operador  ^| Descri√ß√£o  ^| Exemplo     | Significado                                  
^| `&&`      ^| E          ^| `a && b`    | `true` somente se `a` e `b` forem verdadeiras
^| `\|\|`    ^| OU         ^| `a \|\| b`  | `true` qualquer um dos valores for verdadeiro
^| `!`       ^| Nega√ß√£o    ^| `!a`        | `true` se `a` for `false e vice versa        
|=====================================================================================

[#cap-02-operador-binario]
=== 14. Operadores Bin√°rios

Operadores bin√°rios realizam opera√ß√µes bin√°rias. Para entender como funcionam opera√ß√µes bin√°rias √© preciso entender que toda informa√ß√£o √© armazenada em formato bin√°rio, isso significa que o n√∫mero `6544` √© o mesmo valor de `0b0001100110010000` e `0x1990`.

[options="header"]
|======================================================
^| Operador  | Descri√ß√£o                                
^| `<<`      | Translada os bits para esquerda          
^| `>>`      | Translada os bits para a direita         
^| `&`       | Faz a opera√ß√£o E bit a bit               
^| `\|`      | Faz a opera√ß√£o OU bit a bit              
^| `^`       | Faz a opera√ß√£o XOU bit a bit             
^| `~`       | Inverte (complemento) os valores dos bits
|======================================================

[#cap-02-operador-matemarico]
=== 15. Operadores Matem√°ticos

Operadores matem√°ticos realizam opera√ß√µes matem√°ticas b√°sicas.

[options="header"]
|========================================================================
^| Operador  | Descri√ß√£o                                                  
^| +         | Operador aditivo (tamb√©m usado para concatena√ß√£o de String)
^| -         | Operador de subtra√ß√£o                                      
^| *         | Operador de multiplica√ß√£o                                  
^| /         | Operador de divis√£o                                        
^| %         | Operador restante                                          
|========================================================================

[#cap-02-operador-unario]
=== 16. Operadores Un√°rios

Operadores un√°rios realizam opera√ß√µes matem√°ticas b√°sicas usando uma √∫nica vari√°vel. Os operadores un√°rios mais comuns s√£o `++` e `--` que fazem duas opera√ß√µes sequenciais: retornam o valor e alteram o valor da vari√°vel. A posi√ß√£o do operador ir√° influenciar na ordem das opera√ß√µes. Veja o c√≥digo abaixo a diferen√ßa.

[source,java]
----
int x = 0;    // x=0
int y = ++x;  // x=1 y=1
int z = 0;    // z=0
int w = z++;  // z=1 w=0
----

O operador un√°rio pode ser usado tamb√©m com express√µes, mas para isso deve acompanhar o `=`. Veja no c√≥digo abaixo.

[source,java]
----
int x = 0;         // x=0
x += 10;           // x=10
int y=2;           // x=10 y=2
x-=y;              // x=8 y=2
boolean w = true;  // w=true
boolean v != x;    // w=true v=false
----

[#cap-02-cast]
=== 17. Cast

O cast √© uma convers√£o. Java √© uma linguagem orientada a objetos, por isso todo valor estende a classe Object, mas todo valor tem uma pr√≥pria classe. Usamos o cast em duas situa√ß√µes distintas, quando vamos lidar com classes mais especificas ou quando precisamos mudar o tipo de n√∫meros.

O primeiro caso vamos ver mais a frente, j√° o segundo √© quando precisamos alterar um tipo de valor para calculo matem√°tico.

[source,java]
----
float x = 1.23121f;
int y = ((int) (x * 100.0f)) / 2;
System.out.println("x= " + x + " y=" + y);  // x= 1.23121 y=61
----

[#cap-02-operador-condicional]
=== 18. Operador condicional

O operador condicional √© como se fosse um `if` em uma s√≥ linha. Ele √© composto de uma express√£o booleana e dois blocos que devem retornar um valor.

Vamos supor que precisamos calcular o valor absoluto de um n√∫mero inteiro, isso pode ser feito com uma linha s√≥.

[source,java]
----
void int abs(int valor) {
    return valor > 0 ? valor : -valor;
}
----

[#cap-02-exercicios]
== Exerc√≠cios

Os exerc√≠cios s√£o propostos como forma de validar que voc√™ pode ir para o pr√≥ximo passo. Para fixar o conte√∫do dessa sess√£o implemente alguns algoritmos b√°sicos como:

1. Implemente a √°rea do c√≠rculo
2. Implemente o calculo da m√©dia aritm√©tica
3. Implemente o calculo da mediana

Para implementar os exerc√≠cios procure por **// [EXERC√çCIO][CAP 02]**, implemente e execute `mvn clean test` para validar.

++++
{% github https://github.com/vepo/java-101-codigo %}
++++