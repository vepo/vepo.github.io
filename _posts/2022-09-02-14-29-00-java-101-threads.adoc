---
title: Concorrência e Paralelismo
published: false
description: O que eu preciso saber de concorrência e paralelismo para desenvolver usando Java?
tags: [Java]
cover_image: /assets/images/java/duke-tumble.png
series: Java 101
permalink: /posts/java-101-threads
publish_date: 2022-09-02 14:47:00 +0300
---

:figure-caption: Figura
:imagesdir: /assets/images/java-101

Esse post faz parte de uma série introdutória sobre Java, se você não conhece a linguagem e não leu os posts anteriores, recomendo os ler para ter uma visão melhor da plataforma. Nessa série, já falamos sobre o que é o ecossistema Java, o que é a biblioteca Collections, como Java faz Orientação a Objetos e o que é a biblioteca I/O, esses tópicos são necessários para o que vamos falar agora: **Concorrência e Paralelismo**.

[#cap-06-o-que-e-concorrencia-e-paralelismo]
== O que é Concorrência e Paralelismo?!?

Nos frameworks modernos é muito raro lidarmos com paralelismo, apesar que podemos lidar com concorrência o tempo inteiro. Para entender isso precisamos primeiro compreender a diferença entre esses dois conceitos. Para isso vamos imaginar que estamos em uma biblioteca, nessa biblioteca tem dois tipos de livros: os comuns e os raros. Os livros comuns estão acessíveis na estantes para que todos possam ler e pegar emprestado, mas os livros raros estão disponíveis em uma sala especifica em que você precisa pedir para um bibliotecário pegar ele e deve ler somente na sala.

Vamos imaginar que surgiu um estranho interesse por se ler livros raros na cidade e isso gerou uma procura inesperada que surpreendeu até mesmo a direção da biblioteca.

_—  Todos estão disponíveis na internet! Só acessar o https://www.gutenberg.org/browse/languages/pt[Projeto Gutenberg]!!!_

Isso gerou uma fila enorme na sessão de livros raros pois só tinha um bibliotecário para encontrar o livro, registrar a saída e ele ainda precisava observar se o livro estava sendo manipulado corretamente. Logo surgiram várias opções de como melhorar o atendimento da biblioteca, mas só poderiam ser consideradas as opções que mantivessem o cuidado para com as obras.

[.text-center]
.Biblioteca da Escola Sá de Miranda
image::java-101/cap-06/biblioteca-antiga.jpg[id=cap-06-biblioteca-antiga, align="center"]

A primeira opção foi contratar mais um bibliotecário. Feita a contratação ele começou a dividir as tarefas com o mais antigo. Enquanto o primeiro cuidava de encontrar as obras e registrar as saídas, o segundo fiscalizava se todos os usuários da biblioteca estavam manuseando corretamente o livro.

A direção da biblioteca achou a opção boa, mas eles perceberam que o aumento da eficiência foi de apenas 30% enquanto se esperava 100% de eficiência com a contratação de um novo funcionário. Isso aconteceu porque as atividades foram distribuídas, mas nenhuma atividade era feita em paralelo. A atividade que mais demandava tempo era encontrar a obra e registrar a sua saída com cerca de 90% do tempo, logo essa atividade deveria ser feita em paralelo. **Paralelismo** acontece quando a mesma tarefa é realizada simultaneamente por mais de um bibliotecário. Assim os dois bibliotecários decidiram que iriam trabalhar em todo o conjunto de atividades aumentando a eficiência de 30% para 50%.

Mas eles encontraram um pequeno problema, só havia um computador na bancada e por isso eles precisavam se revesar para usar o computador. No começo eles replicavam a atividade que faziam quando havia apenas 1 bibliotecário: atendiam o cliente, encontravam o livro e registravam a saída. Mas perceberam que o tempo de registrar o livro também era demorado, ele demorava cerca de 3 vezes o tempo de pegar o livro, pois o software era bem lento e implementado em Javascript. Logo eles foram procurar solução para o problema deles e descobriram que estavam enfrentando um problema de concorrência. **Concorrência** acontece quando dois ou mais bibliotecários desejam acessar recursos limitados.

Eles perceberam que o mais demorado era entrar no sistema, logo resolveram atender 3 clientes por vez. Assim cada bibliotecário pegava o pedido de 3 clientes e depois registravam no sistema. Essa abordagem fez com que o atendimento se tornasse 70% mais eficiente do que era quando se tinha apenas um funcionário. 

Por fim a biblioteca decidiu contratar uma bibliotecária para fiscalizar o manuseio dos livros porque percebeu que só tinha homens nessa história. E o aumento de eficiência passou para 150% pois ela conseguia fiscalizar e atender na bancada quando possível.

Eu espero que com essa história você tenha compreendido que esse processo acontece com qualquer servidor web. É EXATAMENTE ASSIM! Pense que a biblioteca é o servidor, os bibliotecários são _threads_, os livros são os recursos que o servidor usa e os clientes são os clientes que estão acessando a API do servidor. Eu não sei se os conceitos de concorrência e paralelismo são usado na bibliotecas, eles são conceitos da computação que foram usado nesse texto para descrever e diferenciar eles. Logo podemos redefinir **Paralelismo** quando a mesma tarefa é realizada simultaneamente por mais de uma _thread_ ou processo e **Concorrência** quando acontece duas ou mais _threads_, ou processos desejam acessar recursos limitados.

[#cap-06-thread-e-processo]
== O que é Thread e Processo?!?

Falar de Paralelismo e Concorrência não é uma tarefa fácil porque envolve vários conceitos de vários níveis. Até agora nós falamos de conceitos abstratos, mas agora vamos falar de algo bem mais concreto. Eu citei Thread e Processo e esses são conceitos sobre o sistema operacional. 

Um processo é um programa rodando na memória. Ele é instanciado pelo sistema operacional e terá seu ciclo de vida até ser encerrado por si mesmo ou pelo próprio sistema operacional. Cada processo tem um identificador único e compartilha os recursos da máquina com outros processo. No trecho abaixo vemos a listagem dos 9 primeiros processos iniciados pelo Linux que ainda estão em execução, observe que o `PID` é o identificado único de cada processo, se eu quiser finalizar um processo preciso enviar um comando `kill -15 <PID>` onde **-15** é o sinal que o programa deve ser encerrado, se eu usar **-9** ele será encerrado imediatamente.

[source,bash]
----
$ ps -aux | head
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0 202552  5172 ?        Ss   Jul01  70:40 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root           2  0.0  0.0      0     0 ?        S    Jul01   0:05 [kthreadd]
root           4  0.0  0.0      0     0 ?        S<   Jul01   0:00 [kworker/0:0H]
root           6  0.0  0.0      0     0 ?        S    Jul01   0:35 [ksoftirqd/0]
root           7  0.0  0.0      0     0 ?        S    Jul01   0:07 [migration/0]
root           8  0.0  0.0      0     0 ?        S    Jul01   0:00 [rcu_bh]
root           9  0.0  0.0      0     0 ?        S    Jul01  37:47 [rcu_sched]
root          10  0.0  0.0      0     0 ?        S<   Jul01   0:00 [lru-add-drain]
root          11  0.0  0.0      0     0 ?        S    Jul01   0:22 [watchdog/0]
----

Se fossemos falar em processos no nosso exemplo da biblioteca, teríamos que criar uma biblioteca nova. Como eu disse, dois processo compartilham recursos mas isso não significa que eles podem acessar o mesmo recurso ao mesmo tempo. Por exemplo, se eu tenho um servidor rodando na porta 80, não posso iniciar outro processo na porta 80. Um processo não tem acesso a memória de outro processo, isso significa que para um mesmo objeto não pode existir em dois processos diferentes. (_Até pode, mas não vamos falar de RMI porque é complicado e já foi removido da biblioteca padrão do Java_.)

_—  E se eu quiser que as requisições que cheguem na porta 80 sejam processadas em paralelo, como faço?!?!_

Lembra da nossa biblioteca? Pois é, cada biblioteca é um processo, mas cada bibliotecário é uma _Thread_. _Thread_ são dois fluxos que compartilham o mesmo espaço de memória, ou seja, é quando um processo tem dois fluxos de execução em paralelo compartilhando recursos. Threads podem acessar a mesma porta, assim como podem acessar os mesmo objetos. Mas ele não podem ser feitas ao mesmo momento. Lembra do computador do balcão da biblioteca? A metáfora da biblioteca foi construída para similar exatamente o que acontece em um computador.

[#cap-06-thread-e-processo-em-java]
== Thread e Processo em Java

Vamos agora mostrar algumas classes que podemos usar para manipular processos e threads usando Java. Uma das preocupações da plataforma Java foi criar uma abstração para que o mesmo código possa ser usado em qualquer sistema operacional, logo todo o código demonstrado pode ser executando tando em Linux quando Windows e sistemas derivados do Unix como o MacOS.

=== Processos

Para que possamos acessar as informações de todos os processos em execução podemos usar a classe https://docs.oracle.com/javase/9/docs/api/java/lang/ProcessHandle.html[ProcessHandle] (_adicionada no Java 9_). Navegue pela documentação dela para perceber que processos podem ter uma relação de parentescos como podemos perceber através dos métodos `children()`, `descendants​()` e `parent​()`. Na execução abaixo vemos as informações do processo atual e a listagem de todos os processos em execução.

[source]
----
$ jshell
|  Welcome to JShell -- Version 18
|  For an introduction type: /help intro

jshell> System.out.println(ProcessHandle.current().pid());
System.out.println(ProcessHandle.current  .pid()  );
20092

jshell> System.out.println(ProcessHandle.current().info());
System.out.println(ProcessHandle.current  .info  );
[user: Optional[VEPO], cmd: C:\Users\vepo\.sdkman\candidates\java\18-open\bin\java.exe, startTime: Optional[2022-09-02T18:49:28.093Z], totalTime: Optional[PT0.328125S]]

jshell> ProcessHandle.allProcesses().forEach(System.out::println);
ProcessHandle.allProcesses  .forEach(System.out::println);
0
4
72
[...] 
----

Caso você deseje criar um novo processo, é preciso fazer uma chamada de sistema usando a classe https://docs.oracle.com/javase/9/docs/api/java/lang/Runtime.html[Runtime]. No trecho de código abaixo usamos o método `exec` para criar um novo processo. 

[source,bash]
----
jshell> Runtime.getRuntime().exec("pwd")
Runtime.getRuntime  .exec("pwd")
$4 ==> Process[pid=19628, exitValue="not exited"]
----

Na resposta da execução podemos ver que o método `exec` retorna o novo processo, mas não espera por ele terminar, retornando apenas um objeto https://docs.oracle.com/javase/9/docs/api/java/lang/Process.html[Process] para poder ser manipulado. Em posse desse objeto, podemos esperar por ele terminar e ver se a execução foi um sucesso.

[source,bash]
----
jshell> Runtime.getRuntime().exec("pwd").waitFor()
Runtime.getRuntime  .exec("pwd").waitFor
$5 ==> 0
----

Percebeu que o método `waitFor` retornou **0**? Todo processo precisa finalizar com um número e zero significa sucesso. Qualquer número diferente de zero significa que o programa foi finalizado com erro. O programa que eu executei acima é o `pwd` que retorna o diretório corrente em Linux, apesar de usar Windows uso o Git Bash que é um porte do MinGW que simula um bash Linux.

=== Threads

_Threads_ também são criadas pelo sistemas operacional, mas o Java dá suporte a duas bibliotecas bem interessantes que precisamos demonstrar. A primeira é a classe https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Thread.html[Threads] que deve ser usada com muita parcimônia essa classe, o livro Java Efetivo nos diz no **Item 80: Dê preferência aos executores, às tarefas e às streams em vez de threads**. Os https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Executors.html[Executors] são a proxima classe que vamos ver que podem entregar as mesmas funcionalidades.

_— Então porque entender Threads?!?!_

_Threads_ são importantes porque são um conceito do sistema operacional. Um executor não elimina uma thread, ele apenas facilita a implementação delas e otimiza o seu uso. Threads são gerenciadas pelo Sistema Operacional. O tempo de CPU será dividido entre os processos e as threads. Isso significa que se seu computador tem 4 CPUs e seu programa tem ao menos 2 threads, é provável que em algum momento seu programa esteja rodando em 2 CPUs ao mesmo tempo, mas quem define isso é o sistema operacional.

Threads são um recurso do sistema operacional limitado e caro. No Windows isso não é transparente, mas no Linux é possível acessar essas informações facilmente através do arquivo `/proc/sys/kernel/threads-max`. Na execução abaixo vemos que essa instância do Linux só pode rodar 32.768 processos concorrentes e 100.435 threads concorrentes, o que dá em média 3 threads por processo.

[source,bash]
----
$ cat /proc/sys/kernel/threads-max
100435

$ cat /proc/sys/kernel/pid_max 
32768
----

_— Mas 3 threads por processo não é muito pouco?!?!_

Não! Porque é praticamente impossível rodar 32.768 processos concorrentes e a grande maioria dos processos tem apenas uma thread rodando.

_— Mas o que acontece quando o Java pede uma thread nova?_

Para entender isso, precisamos compreender outro conceito importante de Sistemas Operacionais o espaço do usuário e o espaço do kernel (https://pt.wikipedia.org/wiki/Espa%C3%A7o_de_usu%C3%A1rio[_user space_ e _kernel space_]). Espaço do usuário é todo o código dos nossos programas, já o espaço do kernel é o código do sistema operacional que nossos programas usam para realizar algumas operações. Toda operação que sai do espaço do usuário e vai para o espaço do kernel é custosa porque pode envolver recursos compartilhados como sockets, arquivos ou threads. Logo, criar uma nova thread é custoso porque tem que criar uma nova thread no sistema operacional que não é apenas alocar um espaço na memória.

No código abaixo uma thread é criada que sua única função é pegar o instante em que é iniciada, dormir por 500ms e armazenar o instante em que ela é finalizada. Os tempos deve ser armazenados no array tempos porque nenhuma variável pode ser alterada diretamente entre duas threads que não seja uma variável `final`, pois estamos falando de duas pilhas de execução diferentes.

[source,java]
----
long[] tempos = new long[4];
tempos[0] = System.nanoTime();
Thread t = new Thread() {
    @Override
    public void run() {
        tempos[1] = System.nanoTime();
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        tempos[2] = System.nanoTime();
    }
};
t.start();
try {
    t.join();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
tempos[3] = System.nanoTime();
System.out.println(String.format("Tempo de inicialização: %dµs", (tempos[1] - tempos[0]) / 1000));
System.out.println(String.format("Tempo de execução     : %dµs", (tempos[2] - tempos[1]) / 1000));
System.out.println(String.format("Tempo total           : %dµs", (tempos[3] - tempos[0]) / 1000));
----

O resultado da execução é o visto abaixo, observe que demora quase meio milissegundo para que a thread seja iniciada. Esse tempo pode parecer pouco, mas se houver um uso abusivo dessa classe pode impactar a performance, pois esse tempo é latência adicionada ao processamento.

[source]
----
Tempo de inicialização: 436µs
Tempo de execução     : 510061µs
Tempo total           : 510643µs
----

Observe também que usamos os métodos `start` e `join`, eles servem para controlar a thread. Uma thread não inicia sua execução imediatamente, é preciso que o código que a instanciou dispare a execução. Mas quando a execução se inicia os dois códigos começam a ser executados em paralelo, para que se aguarde a finalização da thread é preciso usar o método `join` que fará com que a thread corrente seja bloqueada até que a outra seja finalizada.

Outro ponto importante é o uso da exceção `InterruptedException`, ela é lançada pela JVM toda vez que a thread é interrompida pelo sistema operacional. 

_— Mas o que significa a thread ser interrompida pelo sistema operacional?_

Ora, já teve vezes em que uma janelinha do Windows ficou não responsiva e você foi lá forçou ela a ser fechada? Ou você executou um comando no bash e não quis esperar a resposta e pressionou **CRTL + C**. Nessa hora o sistema operacional envia um sinal ao programa que ele deve finalizar, o https://pt.wikipedia.org/wiki/SIGTERM[SIGTERM]. Quando esse sinal é recebido pela thread, ela deve liberar todos os recursos e se finalizar, por isso quanto tempos uma `InterruptedException` é hora de limpar a casa e fechar tudo.

Se você ignorar essa exception, o seu processo pode virar um https://pt.wikipedia.org/wiki/Processo_zombie[processo zumbi], pois outras threads podem ter obedecido o sinal e já ter finalizada criando instabilidade para a execução. Então, recebeu um `InterruptedException`, fecha tudo e chama `Thread.currentThread().interrupt()`.

Há um outro sinal que não fornece essa informação, o https://pt.wikipedia.org/wiki/SIGKILL[SIGKILL], o sistema operacional simplesmente mata a execução sem nenhuma educação e protocolo.

Por fim, você deve ter reparado que implementamos o método `run` na thread. Esse método é definido na classe https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Runnable.html[Runnable], essa classe é muito importante porque nem sempre precisamos definir uma thread nova, podemos estender essa classe e criar quantas threads forem necessária com o mesmo código.

Existe a possibilidade de se criar grupos de threads com a classe https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadGroup.html[ThreadGroup], mas não vamos abordar ela porque todas as funcionalidades delas podem ser endereçadas com Executors.

=== Executors

Executors são a nova, _em relação a Thread_, biblioteca adicionada no Java 5 que permite um controle melhor sobre Threads e grupos de threads. A vantagem do uso da classe Executors é que temos uma interface bem mais interessante, como veremos a diante. Primeiro vamos focar em performance.

Como falamos, criar thread pode ser uma operação cara, com executors podemos criar pool de threads ou reutilizar threads já existentes sem a necessidade de se criar novas threads. Se compararmos a execução vemos que o uso de pools de thread diminuem o tempo gasto com a inicialização dessas threads. Nos teste que executamos, vemos que o tempo de inicialização e o tempo médio total são menores, somente o tempo médio de execução é maior, mas isso é devido a fatores externos ao código já que executamos o mesmo código em ambos o caso.

[source]
----
Usando Threads
Tempo de inicialização: 402µs
Tempo de execução     : 511415µs
Tempo total           : 511939µs

Tempo médio de inicialização: 77370µs
Tempo médio de execução     : 50792817µs
Tempo médio total           : 50880048µs

Usando Executors
Tempo de inicialização: 2829µs    (+2.427µs)
Tempo de execução     : 509877µs  (-1.538µs)
Tempo total           : 513237µs  (+1.298µs)

Tempo médio de inicialização: 19708µs    (-57.662µs)
Tempo médio de execução     : 50806122µs (+13.305µs)
Tempo médio total           : 50839674µs (-40.374µs)
----

Para se criar um https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/ExecutorService.html[`ExecutorService`] deve se usar a classe https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Executors.html[`Executors`]. Nessa classe tempos vários tipos de ExecutorServices, mas os mais importantes são os **FixedThreadPool**, **CachedThreadPool** e **ScheduledThreadPool**. Cada um desses tem suas peculiaridades que não vamos abordar aqui, apenas vamos ressaltar que **ScheduledThreadPool** deve ser usado quando precisamos criar threads que executam em intervalos pré definidos.

[source,java]
----
long[] tempos = new long[4];
tempos[0] = System.nanoTime();
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<?> ft = executor.submit(() -> {
        tempos[1] = System.nanoTime();
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        tempos[2] = System.nanoTime();
    });
try {
    ft.get();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
tempos[3] = System.nanoTime();
System.out.println(String.format("Tempo de inicialização: %dµs", (tempos[1] - tempos[0]) / 1000));
System.out.println(String.format("Tempo de execução     : %dµs", (tempos[2] - tempos[1]) / 1000));
System.out.println(String.format("Tempo total           : %dµs", (tempos[3] - tempos[0]) / 1000));
executor.shutdown();
----

A grande diferença é que quando criamos uma nova execução o ExecutorService retorna um https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Future.html[`Future`] que irá prover informações sobre a execução e o retorno da execução. Um executor não aceita apenas um `Runnable`, mas também https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Callable.html[`Callable`] que retorna valores. A opção por usar `Callable` irá tornar seu código mais legível.

Outro ponto importante do uso de `ExecutorService` é que assim que uma nova atividade é submetida, ela entrará na fila de execução. É preciso ressaltar que ela só será executada quando houver thread disponível. Isso significa que um `ExecutorService` deve ser usado para atividades rápidas e não com longa duração. Se você precisar executar algo que dure toda execução crie um ExecutorService de tamanho pré-definido, usando `newFixedThreadPool` ou cria a thread manualmente.

Por fim um ExecutorService não finaliza automaticamente, ele deve ser finalizado através do método `shutdown`. Caso você não chame esse método o seu programa vai virar um processo zumbi.