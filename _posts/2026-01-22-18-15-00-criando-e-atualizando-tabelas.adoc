---
title: "SQL na Prática: Criando e Atualizando tabelas"
published: false
description: |
    
tags: [SQL, PostgreSQL, Consultas SQL, Banco de Dados Relacional, Modelagem de Dados, Backend]
cover_image: /assets/images/capas/disquete-100-42.jpg
series: Introdução a Bases de Dados
permalink: /posts/sql-na-pratica
publish_date: 2026-01-22 18:13:00 +0300
---

No post anterior, aprendemos como consultar e modificar dados. Talvez você não tenha tido a curiosidade de se perguntar como as tabelas foram criadas, apesar do script ter sido fornecido, mas agora é o momento de dar um passo atrás e explicar: como criar e atualizar as próprias tabelas.

== O que é o esquema de uma tabela?

Uma das principais vantagens dos bancos de dados relacionais é que o sistema gerencia e garante a consistência dos dados, e isso é feito por meio do esquema do banco de dados.

Como já definimos antes, o esquema (ou *schema*) é a descrição de uma coleção de dados que estabelece a estrutura de armazenamento.

No modelo relacional, os dados são organizados em relações compostas por atributos, em que cada linha de uma tabela representa uma entidade em si. Dessa forma, o esquema de um banco tem a responsabilidade de definir:

1. Quais são as relações (tabelas) e seus nomes;
2. Quais atributos cada relação contém;
3. Como as relações se relacionam entre si;
4. Quais restrições de integridade se aplicam a cada atributo;
5. Qual o tipo de dados armazenado em cada atributo.

Nesse post vamos ver como criar e atualizar tabelas, ou seja, como definir e modificar o esquema do banco de dados.

== Como faço para criar uma tabela?

Para criar uma tabela em SQL, usamos o comando `CREATE TABLE`. Vamos o exemplo de criação usado anteriormente para ilustrar:

.Criando a tabela "employees"
[source,sql]
----
CREATE TABLE employees (
    employee_id   SERIAL PRIMARY KEY,
    first_name    VARCHAR(50) NOT NULL,
    last_name     VARCHAR(50) NOT NULL,
    email         VARCHAR(100) UNIQUE NOT NULL,
    phone         VARCHAR(20),
    hire_date     DATE NOT NULL,
    job_title     VARCHAR(100) NOT NULL,
    department_id INT,
    salary        DECIMAL(10,2) CHECK (salary >= 0),
    manager_id    INT REFERENCES employees(employee_id),
    created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
----

=== Como definir os tipos de dados dos atributos?

No exemplo acima, criamos a tabela `employees` com vários atributos, cada um com seu tipo de dado e restrições específicas. Podemos ver, por exemplo, o atributo `phone`, que é do tipo `VARCHAR(20)` e não possui nenhuma restrição de integrridade. `VARCHAR` significa que campo armazenará uma cadeia de caracteres (texto) com tamanho variável, mesmo tendo definido que o tamanho máximo é 20 caracteres. Alguns dos possíveis tipos de dados em PostgreSQL são listados na tabela abaixo: 

.Tipos de dados comuns em PostgreSQL e MySQL, para referência acesse https://www.postgresql.org/docs/current/datatype.html ou https://dev.mysql.com/doc/refman/8.4/en/data-types.html
[cols="1,1,1", options="header"]
|=== 
| PostgreSQL
| MySQL
| Descrição

| `INT` ou `INTEGER`
| `INT`
| Números inteiros (sem casas decimais).

| `BIGINT`
| `BIGINT`
| Números inteiros grandes (64 bits), usados para armazenar valores maiores que os inteiros normais.

| `DECIMAL(p,s)` ou `NUMERIC(p,s)`
| `DECIMAL(p,s)`
| Números decimais com precisão definida. `p` é a precisão total (número total de dígitos) e `s` é a escala (número de dígitos à direita da vírgula).

| `FLOAT` ou `REAL`
| `FLOAT`
| Números de ponto flutuante (números com casas decimais).

| `SERIAL`
| N/A
| Números inteiros auto-incrementáveis, geralmente usados para chaves primárias.

| `BIGSERIAL`
| N/A
| Números inteiros grandes auto-incrementáveis, usados para chaves primárias quando se espera um grande volume de dados.

| `VARCHAR`
| `VARCHAR`
| Cadeia de caracteres (texto) com tamanho variável. O número entre parênteses indica o tamanho máximo permitido.

| `CHAR`
| `CHAR`
| Cadeia de caracteres (texto) com tamanho fixo. O número entre parênteses indica o tamanho exato.

| `TEXT`
| `TEXT`
| Cadeia de caracteres (texto) de tamanho ilimitado.

| `DATE`
| `DATE`
| Data no formato AAAA-MM-DD.

| `TIME`
| `TIME`
| Hora no formato HH:MM:SS.


| `TIMESTAMP`
| `TIMESTAMP`
| Data e hora no formato AAAA-MM-DD HH:MM:SS.

| `BOOLEAN`
| N/A
| Valores lógicos: `TRUE` ou `FALSE`.

|===

No nosso exemplo, também usamos os seguintes tipos: `SERIAL`, `VARCHAR`, `DATE`, `DECIMAL` e `TIMESTAMP`.

=== Como garantir a integridade do dado?

Além dos tipos de dados, as restrições de integridade são fundamentais para garantir que os dados armazenados estejam sempre consistentes e válidos. No exemplo da tabela `employees`, utilizamos diversas restrições:

.Criando a tabela "employees" com restrições
[source,sql]
----
CREATE TABLE employees (
    employee_id   SERIAL PRIMARY KEY,
    first_name    VARCHAR(50) NOT NULL,
    last_name     VARCHAR(50) NOT NULL,
    email         VARCHAR(100) UNIQUE NOT NULL,
    phone         VARCHAR(20),
    hire_date     DATE NOT NULL,
    job_title     VARCHAR(100) NOT NULL,
    department_id INT,
    salary        DECIMAL(10,2) CHECK (salary >= 0),
    manager_id    INT REFERENCES employees(employee_id),
    created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
----

Vamos detalhar cada uma dessas restrições:

==== `PRIMARY KEY` (Chave Primária)

A chave primária é um dos conceitos mais importantes em bancos de dados relacionais. Ela identifica unicamente cada linha da tabela. No nosso exemplo:

[source,sql]
----
employee_id SERIAL PRIMARY KEY
----

Isso significa que:
- `employee_id` será único para cada funcionário
- Não poderá ser nulo (`NULL`)
- Automaticamente será criado um índice para buscas rápidas
- O valor é gerado automaticamente usando `SERIAL` (auto-incremento)

==== `NOT NULL`

A restrição `NOT NULL` garante que um campo não pode ficar vazio. Por exemplo:

[source,sql]
----
first_name VARCHAR(50) NOT NULL
----

Isso impede que um funcionário seja cadastrado sem primeiro nome.

==== `UNIQUE`

A restrição `UNIQUE` garante que todos os valores em uma coluna sejam diferentes entre si:

[source,sql]
----
email VARCHAR(100) UNIQUE NOT NULL
----

Isso assegura que não teremos dois funcionários com o mesmo e-mail.

==== `CHECK`

A restrição `CHECK` permite definir uma condição que deve ser verdadeira para todos os registros:

[source,sql]
----
salary DECIMAL(10,2) CHECK (salary >= 0)
----

Aqui garantimos que nenhum funcionário terá um salário negativo.

==== `DEFAULT`

A cláusula `DEFAULT` define um valor padrão para a coluna quando nenhum valor é fornecido:

[source,sql]
----
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
----

Assim, quando um novo funcionário for inserido sem especificar o `created_at`, o banco automaticamente preencherá com a data e hora atuais.

==== `REFERENCES` (Chave Estrangeira)

A chave estrangeira estabelece um relacionamento entre tabelas:

[source,sql]
----
manager_id INT REFERENCES employees(employee_id)
----

Isso indica que `manager_id` deve corresponder a um `employee_id` válido na mesma tabela (auto-relacionamento). Isso garante a **integridade referencial** - não podemos atribuir um gerente que não existe.

=== Como criar tabelas relacionadas?

Vamos criar agora as tabelas `departments` e `projects` para completar nosso esquema:

.Criando a tabela "departments"
[source,sql]
----
CREATE TABLE departments (
    department_id   SERIAL PRIMARY KEY,
    department_name VARCHAR(100) NOT NULL UNIQUE,
    budget          DECIMAL(12,2) CHECK (budget > 0),
    manager_id      INT REFERENCES employees(employee_id)
);
----

.Criando a tabela "projects"
[source,sql]
----
CREATE TABLE projects (
    project_id    SERIAL PRIMARY KEY,
    project_name  VARCHAR(200) NOT NULL,
    start_date    DATE NOT NULL,
    end_date      DATE CHECK (end_date > start_date),
    department_id INT REFERENCES departments(department_id)
);
----

Observe como as restrições garantem a consistência:
- O orçamento (`budget`) deve ser positivo
- A data de término (`end_date`) deve ser posterior à data de início
- As chaves estrangeiras ligam as tabelas corretamente

=== E se eu precisar modificar uma tabela existente?

Após criar uma tabela, podemos precisar alterá-la. O comando `ALTER TABLE` permite modificar a estrutura existente:

.Adicionando uma nova coluna
[source,sql]
----
ALTER TABLE employees ADD COLUMN birth_date DATE;
----

.Modificando o tipo de uma coluna
[source,sql]
----
ALTER TABLE employees ALTER COLUMN phone TYPE VARCHAR(30);
----

.Adicionando uma restrição
[source,sql]
----
ALTER TABLE employees ADD CONSTRAINT unique_phone UNIQUE (phone);
----

.Removendo uma coluna
[source,sql]
----
ALTER TABLE employees DROP COLUMN birth_date;
----

.Adicionando uma chave estrangeira
[source,sql]
----
ALTER TABLE projects 
ADD CONSTRAINT fk_projects_department 
FOREIGN KEY (department_id) REFERENCES departments(department_id);
----

=== Como remover uma tabela?

Para remover uma tabela completamente, usamos o comando `DROP TABLE`:

[source,sql]
----
DROP TABLE projects;
----

**Cuidado!** Este comando remove a tabela e todos os seus dados permanentemente.

Se a tabela for referenciada por uma chave estrangeira, você precisará usar `CASCADE`:

[source,sql]
----
DROP TABLE departments CASCADE;
----

Isso removerá a tabela `departments` e todas as dependências (como a chave estrangeira em `projects`).

== Conclusão

Neste post, aprendemos a criar e gerenciar o esquema de um banco de dados relacional. Vimos que:

1. O comando `CREATE TABLE` define a estrutura inicial das tabelas
2. Os tipos de dados determinam que tipo de informação cada coluna pode armazenar
3. As restrições de integridade (`PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, `CHECK`, `NOT NULL`, `DEFAULT`) garantem a consistência dos dados
4. O comando `ALTER TABLE` permite modificar tabelas existentes
5. O comando `DROP TABLE` remove tabelas (com cuidado!)

Dominar a criação e modificação de tabelas é fundamental para qualquer profissional que trabalhe com bancos de dados. Uma boa modelagem inicial, com restrições bem definidas, evita problemas de inconsistência e facilita a manutenção do sistema no longo prazo.

No próximo post, veremos como consultar dados de múltiplas tabelas usando `JOINs` para explorar os relacionamentos que definimos aqui. Até lá!