---
title: "SQL na Prática: Criando e Atualizando tabelas"
published: false
description: |
    
tags: [SQL, PostgreSQL, Consultas SQL, Banco de Dados Relacional, Modelagem de Dados, Backend]
cover_image: /assets/images/capas/disquete-100-42.jpg
series: Introdução a Bases de Dados
permalink: /posts/sql-na-pratica
publish_date: 2026-01-22 18:13:00 +0300
---

No post anterior, aprendemos como consultar e modificar dados. Talvez você não tenha tido a curiosidade de se perguntar como as tabelas foram criadas, apesar do script ter sido fornecido, mas agora é o momento de dar um passo atrás e explicar: como criar e atualizar as próprias tabelas.

== O que é o esquema de uma tabela?

Uma das principais vantagens dos bancos de dados relacionais é que o sistema gerencia e garante a consistência dos dados, e isso é feito por meio do esquema do banco de dados.

Como já definimos antes, o esquema (ou *schema*) é a descrição de uma coleção de dados que estabelece a estrutura de armazenamento.

No modelo relacional, os dados são organizados em relações compostas por atributos, em que cada linha de uma tabela representa uma entidade em si. Dessa forma, o esquema de um banco tem a responsabilidade de definir:

1. Quais são as relações (tabelas) e seus nomes;
2. Quais atributos cada relação contém;
3. Como as relações se relacionam entre si;
4. Quais restrições de integridade se aplicam a cada atributo;
5. Qual o tipo de dados armazenado em cada atributo.

Nesse post vamos ver como criar e atualizar tabelas, ou seja, como definir e modificar o esquema do banco de dados.

== Como faço para criar uma tabela?

Para criar uma tabela em SQL, usamos o comando `CREATE TABLE`. Vamos o exemplo de criação usado anteriormente para ilustrar:

.Criando a tabela "employees"
[source,sql]
----
CREATE TABLE employees (
    employee_id   SERIAL PRIMARY KEY,
    first_name    VARCHAR(50) NOT NULL,
    last_name     VARCHAR(50) NOT NULL,
    email         VARCHAR(100) UNIQUE NOT NULL,
    phone         VARCHAR(20),
    hire_date     DATE NOT NULL,
    job_title     VARCHAR(100) NOT NULL,
    department_id INT,
    salary        DECIMAL(10,2) CHECK (salary >= 0),
    manager_id    INT REFERENCES employees(employee_id),
    created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
----

=== Como definir os tipos de dados dos atributos?

No exemplo acima, criamos a tabela `employees` com vários atributos, cada um com seu tipo de dado e restrições específicas. Podemos ver, por exemplo, o atributo `phone`, que é do tipo `VARCHAR(20)` e não possui nenhuma restrição de integrridade. `VARCHAR` significa que campo armazenará uma cadeia de caracteres (texto) com tamanho variável, mesmo tendo definido que o tamanho máximo é 20 caracteres. Alguns dos possíveis tipos de dados em PostgreSQL são listados na tabela abaixo: 

.Tipos de dados comuns em PostgreSQL, para referência acesse https://www.postgresql.org/docs/current/datatype.html
[cols="1,1,1", options="header"]
|=== 
| PostgreSQL
| MySQL
| Descrição

| `INT` ou `INTEGER`
| `INT`
| Números inteiros (sem casas decimais).

| `BIGINT`
| `BIGINT`
| Números inteiros grandes (64 bits), usados para armazenar valores maiores que os inteiros normais.

| `DECIMAL(p,s)` ou `NUMERIC(p,s)`
| `DECIMAL(p,s)`
| Números decimais com precisão definida. `p` é a precisão total (número total de dígitos) e `s` é a escala (número de dígitos à direita da vírgula).

| `FLOAT` ou `REAL`
| `FLOAT`
| Números de ponto flutuante (números com casas decimais).

| `SERIAL`
| N/A
| Números inteiros auto-incrementáveis, geralmente usados para chaves primárias.

| `BIGSERIAL`
| N/A
| Números inteiros grandes auto-incrementáveis, usados para chaves primárias quando se espera um grande volume de dados.

| `VARCHAR`
| `VARCHAR`
| Cadeia de caracteres (texto) com tamanho variável. O número entre parênteses indica o tamanho máximo permitido.

| `CHAR`
| `CHAR`
| Cadeia de caracteres (texto) com tamanho fixo. O número entre parênteses indica o tamanho exato.

| `TEXT`
| `TEXT`
| Cadeia de caracteres (texto) de tamanho ilimitado.

| `DATE`
| `DATE`
| Data no formato AAAA-MM-DD.

| `TIME`
| `TIME`
| Hora no formato HH:MM:SS.


| `TIMESTAMP`
| `TIMESTAMP`
| Data e hora no formato AAAA-MM-DD HH:MM:SS.

| `BOOLEAN`
| N/A
| Valores lógicos: `TRUE` ou `FALSE`.

|===

No nosso exemplo, também usamos os seguintes tipos: `SERIAL`, `VARCHAR`, `DATE`, `DECIMAL` e `TIMESTAMP`.