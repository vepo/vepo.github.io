---
title: A sintaxe do Java
published: true
description: Voc√™ sabe o que √© o m√≠nimo que voc√™ precisa saber pra desenvolver Java? Aqui eu vou apresentar um pouco da sintaxe do Java. Quero passar por todas as estruturas que v√£o fazer voc√™ criar o melhor c√≥digo poss√≠vel.
tags: [Java]
cover_image: /assets/images/java/duke-thinking.png
series: Java 101
permalink: /posts/java-101-sintaxe
publish_date: 2022-04-29 15:26:00 +0300
---

A inten√ß√£o dessa s√©rie √© te apresentar o b√°sico sobre a linguagem Java e te dar ferramentas para que voc√™ possa aprender a programar. Nenhum material por s√≠ s√≥ far√° o trabalho completo, para que voc√™ possa se tornar um desenvolvedor √© preciso muito exerc√≠cio, por isso v√° lentamente avan√ßando sobre os t√≥picos propostos e fazendo todos os exerc√≠cios propostos. 

Nesse sess√£o voc√™ vai aprender:

* O que √© uma linguagem de programa√ß√£o e no que ela difere de uma linguagem natural
* Os elementos b√°sicos da sintaxe da linguagem Java

---

Na nossa s√©rie sobre o b√°sico do Java ficou faltando um t√≥pico muito importante: sintaxe. Qualquer linguagem tem uma sintaxe e se voc√™ n√£o sabe porque isso √© importante eu preciso te dar uma informa√ß√£o muito importante: o computador √© extremamente burro.

# Linguagens Formais e Linguagem Natural

Se voc√™ nunca estudou formalmente o que √© uma linguagem de programa√ß√£o, talvez seja preciso definir corretamente o que difere uma linguagem de programa√ß√£o de outras linguagens. 

N√≥s somos acostumados a um tipo de linguagem que √© extremamente male√°vel e pode ser compreendida mesmo que esteja **formalmente** errada. S√£o raras as pessoas que amam estudar a estrutura de portugu√™s, eu mesmo n√£o sou uma delas apesar de gostar de letras. Estudar a lingua que usamos no dia a dia n√£o √© comum por dois motivos bem √≥bvios: podemos ser entendidos mesmo sem uma estrutura formal e √© um conjunto de regras chatas.

Portugu√™s, Ingl√™s, Mandarim, Japon√™s e at√© o [Javan√™s](https://amzn.to/3z8wVdt) s√£o o que conhecemos como linguagens naturais. Elas emergem da experi√™ncia humana e s√£o compreendidas por humanos. Computadores n√£o entendem essas linguagens, eles podem apenas capturar s√≠mbolos, mas eles n√£o conseguem compreender. 

_‚Äî Ah, mas tem o GPT-3 que consegue ler e escrever bons textos._

Calma l√°! √â preciso entender como funciona um computador para n√£o cair no jornalismo barato e marketing agressivo de companhias de Intelig√™ncia Artificial. GPT-3 n√£o √© aquilo que foi prometido e tem suas limita√ß√µes. Eu recomendo ler o artigo ["GPT-3, Fals√°rio: o gerador de linguagem do OpenAI n√£o tem ideia do que est√° falando"](https://www.technologyreview.com/2020/08/22/1007539/gpt3-openai-language-generator-artificial-intelligence-ai-opinion/) (se n√£o l√™ ingl√™s, use o Google Translator). E √© nesse ponto que vamos demonstrar o que √© uma linguagem de programa√ß√£o, pra isso vamos usar uma analogia.

Imagine que [um computador √© como um falante de portugu√™s que est√° preso dentro de um quarto com um livro de regras. Sua fun√ß√£o √©, ao receber caixas com texto em chin√™s, deve consultar o livro de regras para identificar os s√≠mbolos no texto e conseguir formular uma resposta baseado nas regras. Ao formular uma resposta, ela deve ser enviada pra fora do quarto.](https://pt.wikipedia.org/wiki/Quarto_chin%C3%AAs) Esse homem n√£o sabe chin√™s e nem consegue compreender o que ele est√° respondendo, ele s√≥ est√° seguindo as regras de quem escreveu o livro.

![Imagem descrevendo O Quarto Chin√™s](/assets/images/o-quarto-chin√™s.png)

Programas s√£o o livro de regras que √© escrito por programadores. Por melhor que seja um programa, um computador n√£o tem compreens√£o do que est√° acontecendo. E se houver alguma situa√ß√£o n√£o prevista no livro de regras, n√£o ser√° poss√≠vel formular uma resposta. 

Para que o computador entenda essas regras, elas devem ser escritas em uma linguagem bem estruturada. Essa linguagem vai ter uma sintaxe bem definida e se por algum motivo ela for violada o computador n√£o ser√° capaz de compreender. Essas s√£o o que chamamos de Linguagens Formais.

Java, C, Javascript, PHP, Python, etc... s√£o linguagens formais. Elas n√£o emergem da experi√™ncia humana, mas s√£o propostas por humanos para se comunicar com computadores. Um humano consegue identificar um erro em uma linguagem natural e mesmo assim compreender o que √© proposto, mas um erro em uma linguagem formal impossibilita todo o processo. Se voc√™ quiser saber como definir uma linguagem formal, eu j√° escrevi sobre isso em [Como criar uma linguagem usando ANTLR4 e Java](https://vepo.github.io/posts/como-criar-uma-linguagem-usando-antlr4-e-java).

# A Sintaxe Java

Java √© uma linguagem da chamada C-Like. Isso significa que ela herda muitas caracter√≠sticas do C. Se voc√™ n√£o ouviu falar de C, n√£o se preocupe, apesar dela ser uma das linguagens mais influente da hist√≥ria, ela n√£o tem muito espa√ßo desenvolvimento web moderno, est√° nichada em desenvolvimento embarcado e drivers do sistema operacional. Mas o C emprestou ao Java muito das estruturas que usamos no dia a dia.

Como j√° falamos anteriormente, o Java √© uma linguagem compilada. Isso significa que ao escreve um c√≥digo Java, toda a sintaxe √© validada por um compilador e se houver algum erro n√£o √© poss√≠vel prosseguir at√© que ele seja corrigido. Algumas pessoas veem isso como um problema, mas linguagens compiladas conseguem prever erros antes da execu√ß√£o e, em geral, tem uma performance melhor em tempo de execu√ß√£o.

Abaixo eu listo todas as estruturas que vamos detalhar resumidamente. Ao lado dela temos a documenta√ß√£o oficial (para vers√£o 8) com a especifica√ß√£o formal. Se voc√™ n√£o conseguir entender a documenta√ß√£o, n√£o tem problema. Para essa listagem eu vou tomar a liberdade de traduzir os nomes das estruturas, mas √© por motivo meramente did√°tico, nunca use esse nome, apenas o nome em ingl√™s. A tradu√ß√£o serve para voc√™ ver que tem uma l√≥gica na nomenclatura, √© como se o c√≥digo fosse um tipo de linguagem verbaliz√°vel.

1. Bloco ([Block](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.2))
2. Declara√ß√£o ([Statement](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.5))
3. Coment√°rio ([Comments](https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.7))
4. Se ([if](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.9))
5. Enquanto ([while](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.11))
6. Fa√ßa enquanto ([do-while](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.13))
7. Para ([for](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14))
8. Desvio ([switch](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.11))
9. Quebra e continua ([break](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.15) e [continue](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.16))
10. Lance ([throw](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.18))
11. Sincronizado ([synchronized](https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.19))
12. Operadores L√≥gicos
13. Operadores Bin√°rios
14. Operadores Matem√°ticos
15. Operadores Un√°rios
16. Cast
17. Operador condicional

## 1. Bloco

Um bloco de c√≥digo √© uma estrutura que pode ser tanto obrigat√≥ria quanto opcional. Essa estrutura √© definida `{}` e dentro desse bloco teremos um novo escopo de vari√°veis. Isso significa que toda vari√°vel definida dentro de um bloco ser√° conhecida apenas por aquele block e todo bloco definido dentro dele.

Observe o c√≥digo abaixo. Nele temos os blocos `B1` a `B4`. Os blocos `B1` e `B2` fazem parte de estruturas mais complexas, e s√£o obrigat√≥rios, que no caso s√£o uma classe e um m√©todo respectivamente. J√° os blocos `B3` e `B4` s√£o opcionais e est√£o a√≠ para mostrar que podemos criar um bloco quanto bem entendermos, apesar dessa n√£o ser uma pr√°tica comum no desenvolvimento Java. ü§ì

```java
public class HelloWorldSintaxe { // B1
    public static void main(String[] args) { // B2
        System.out.println("Ol√° mundo");

        String variavel = "abc";
        System.out.println("Valor de variavel=" + variavel);

        {} // B3: Bloco vazio

        { // B4
            String variavel2 = "xyz";
            System.out.println("Valor de variavel2=" + variavel2);
        } 

        // System.out.println("Valor de variavel2=" + variavel2);  // Se voc√™
    }

    // private void x() return 1; // Bloco √© obrigat√≥rio no caso de m√©todo, essa constru√ß√£o vai falhar 
}
```

Se voc√™ come√ßar a brincar com esse c√≥digo, vai ver que a `variaevel2` s√≥ pode ser usada dentro do `B4`. Isso √© o que chamamos de escopo, ao finalizar a execu√ß√£o de `B4` ela √© completamente desnecess√°ria e poder√° ser eliminada da mem√≥ria. 

## 2. Declara√ß√£o

Toda estrutura Java √© uma declara√ß√£o e toda declara√ß√£o tem significado. Declara√ß√µes em Java devem ser separadas por `;` ou devem conter um Bloco de c√≥digo. Tudo que devemos entender de uma declara√ß√£o √© que ela tem um significado e que elas s√£o executadas em sequencia.

Vamos imaginar um c√≥digo hipot√©tico abaixo. Tudo que podemos supor √© que as tr√™s declara√ß√µes s√£o executadas em sequ√™ncia, desde que n√£o aconte√ßa nada excepcional.

```java
metodo1();
declaracao1();
metodo2();
```

## 3. Coment√°rio

Coment√°rios s√£o trechos que ser√£o removidos durante o processo de compila√ß√£o. Apesar que alguns autores falam que todo coment√°rio √© uma falha, eu discordo veementemente. Coment√°rios s√£o necess√°rios, mas voc√™ deve saber o que comentar! Mas primeiro vamos mostrar como comentar...

Coment√°rios podem ser em linha, em block ou como documenta√ß√£o oficial. 

Para criar um coment√°rio em linha, adicione os dois caracteres `//` e tudo que voc√™ escrever at√© o fim da linha ser√° desconsiderado durante a compila√ß√£o.

Para criar um bloco de coment√°rio, inicie com `/*` e todo caractere at√© encontrar o final `*/` ser√° desconsiderado.

```java
metodo1(); //  coment√°rio em linha
metodo2(); 
/* if(m3()) {
    m4();
}*/
metodo5();
```

Uma das grandes funcionalidades do Java √© permitir c√≥digo como documenta√ß√£o oficial. √â o famoso [Javadoc](https://docs.oracle.com/javase/8/docs/api/overview-summary.html) que √© gerado a partir do seu c√≥digo. Mas o Javadoc √© um tipo de coment√°rio especifico que fica imediatamente antes da classe, dos m√©todos ou de um campo e √© come√ßado com `/**`. Um Javadoc segue uma linguagem de marca√ß√£o que pode ser muito √∫til em alguns projetos. A vantagem de se usar o Javadoc, √© que al√©m dele poder ser exportado em HTML, as IDEs o utilizam. Ent√£o use-o.

Agora que voc√™ aprendeu a comentar, vamos aprender sobre o que comentar? Coment√°rios s√£o informa√ß√µes auxiliar ao c√≥digo. Isso significa que voc√™ n√£o precisa comentar o que est√° no c√≥digo, mas a informa√ß√£o que falta ao c√≥digo. N√£o √© o **como**, mas o **porque** do c√≥digo. Eu gosto de comentar pressupostos e escolhas arquiteturais porque em alguns meses eu n√£o vou lembrar e outra pessoa que pegar meu c√≥digo tamb√©m n√£o vai lembrar.

## 4. Se

A declara√ß√£o condicional √© a mais comum de todas, √© composto por `if (express√£o booleana) <bloco> else <bloco>`, onde express√£o booleana √© qualquer fun√ß√£o que retorne um `boolean` ou uma express√£o l√≥gica que veremos em Operadores L√≥gicos.

A declara√ß√£o condicional pode ser encadeada, se isso acontecer coloque como primeira express√£o a mais comum. Um exemplo?

```java
int x = leNumeroInteiro();

if (x % 2 == 0) { // o operador % retorna o resto da divis√£o
    System.out.println("O valor lido √© par!");
} else {
    System.out.println("O valor lido √© impar!");
}


if (x % 3 == 0) {
    System.out.println("O valor lido √© m√∫ltiplo de 3!");
} else if (x % 3 == 1) {
    System.out.println("O valor lido tem a forma f(x) = 3x + 1");
} else {
    System.out.println("O valor lido tem a forma f(x) = 3x + 2");
}
```

No exemplo acima temos 3 express√µes l√≥gica. A primeira calcula se o valor √© par ent√£o logicamente o bloco else ser√° executado para todo valor impar. A segunda calcula se o valor √© divis√≠vel por 3, isso significa que o bloco else ser√° chamado para todo valor n√£o divis√≠vel, mas com o `if` encadeado fazemos a vis√£o daquele que s√£o no formato `3x + 1` e `3x + 2`.

## 5. Enquanto

Enquanto define que um bloco de c√≥digo ser√° executado at√© que uma express√£o l√≥gica seja falsa. Exemplo?

```java
int x = leValor();
while(x > 0) {
    System.out.println("Valor √© positivo!");
    x = leValor();
}
```

O bloco de c√≥digo ser√° executado continuamente at√© que venha um valor 0 ou negativo.

## 6. Fa√ßa enquanto

O Fa√ßa enquanto funciona de forma bem similar, a diferen√ßa √© que o teste √© feito depois que o bloco de c√≥digo √© executado. 

```java
do {
    executa();
} while (emExecu√ß√£o)
```

## 7. Para

O famoso `for` √© um pouco mais complexo. Ele √© composto por 3 blocos que podem ser chamados de **inicializa√ß√£o**, **condi√ß√£o** e **passo**. Ao iniciar ser√° executado uma √∫nica vez o trecho de c√≥digo **inicializa√ß√£o** e em cada itera√ß√£o ser√° executado o trecho de c√≥digo **condi√ß√£o**, que deve retornar uma express√£o booleana, depois ser√° executado o bloco de c√≥digo para depois ser executado o trecho **passo**. O exemplo mais comum √© para se iterar em um array.

```java
int[] array = new int[] {0 , 1, 2, 3, 4, 5};
for (int i = 0; i < array.length; i++) {
    // bloco de c√≥digo
}
```

## 8. Desvio

O `switch` desvia o c√≥digo de acordo com o valor de uma vari√°vel. O `switch` √© uma estrutura que pode facilmente induzir a erros porque cada bloco n√£o √© exclusivo, o fluxo de execu√ß√£o passar de um bloco ao outro at√© que seja encontrada a instru√ß√£o `break`. Vamos ver um exemplo?

```java
int x = leValor();
switch (x) {
    case 1:
        System.out.println("√â igual a 1!");
    case 2:
        System.out.println("√â maior ou igual a 2!");
    case 3:
        System.out.println("√â maior ou igual a 3!");
    case 4:
        System.out.println("√â maior ou igual a 4!");
    case 5:
        System.out.println("√â maior ou igual a 5!");
    default
        System.out.println("√â maior que 5 ou menor que 1!");
}
```

O que aconteceria se o valor de `x` for igual a 3? Seriam executados os blocos de 3 at√© o `default`.

```
√â maior ou igual a 3!
√â maior ou igual a 4!
√â maior ou igual a 5!
√â maior que 5 ou menor que 1!
```

Se quisermos um valor exato, podemos usar o break:

```java
int x = leValor();
switch (x) {
    case 1:
        System.out.println("√â igual a 1!");
        break;
    case 2:
        System.out.println("√â igual a 2!");
        break;
    case 3:
        System.out.println("√â igual a 3!");
        break;
    case 4:
        System.out.println("√â igual a 4!");
        break;
    case 5:
        System.out.println("√â igual a 5!");
        break;
    default
        System.out.println("√â maior que 5 ou menor que 1!");
}
```

Agora voc√™ deve ter se perguntado porque no texto do bloco `default` eu usei _menor que 1_? Isso porque o `switch` n√£o √© usado para intervalos de valores, mas para valores exatos e caso nenhum valor seja igual aos valores declarados √© chamado o bloco `default`. 

Vale lembrar que o switch pode ser usado para n√∫meros, enumeradores e qualquer valor constante, inclusive String.

## 9. Quebra e continua

Uma quebra deve ser chamada dentro bloco `switch`, `while`, `do` ou `for`. Ao se deparar com essa instru√ß√£o o programa ir√° finalizar a execu√ß√£o do bloco externo imediatamente.

Vamos demonstrar isso com um exemplo b√°sico? No c√≥digo abaixo vamos criar um `for` que ser√° finalizado usando `break`. Observe que o ponto de parada do for seria no m√°ximo inteiro poss√≠vel, mas atrav√©s do break finalizamos em 10.

```java
System.out.println("Iniciando for...");
for (int i = 0; i < Integer.MAX_VALUE; i++) {
    System.out.println("Valor: " + i);
    if (i == 10) {
        break;
    }
}
```

Quando usamos `break` dentro de um switch evitamos que os blocos de c√≥digos abaixo dele seja executados.

O `continue` tem um comportamento parecido, mas ao inv√©s de finalizar o bloco ser√° apenas finalizada a itera√ß√£o. Ele s√≥ √© aceito em itera√ß√µes como `while`, `do` ou `for`. Vamos incrementar o exemplo acima para imprimir apenas n√∫meros impares. Observe que no c√≥digo abaixo foi preciso mudar a condi√ß√£o de execu√ß√£o do `break` porque ele nunca seria executado se us√°ssemos `i == 10`.

```java
System.out.println("Iniciando for...");
for (int i = 0; i < Integer.MAX_VALUE; i++) {
    if (i % 2 == 0) {
        continue;
    }
    System.out.println("Valor: " + i);
    if (i > 10) {
        break;
    }
}
```

Se voc√™ leu a documenta√ß√£o atentamente, viu que `break` e `continue` podem aceitar r√≥tulos. O que isso significa? Vamos imaginar que temos um loop encadeado em que buscamos um valor dentro de uma matrix. Como as linhas dessa matrix s√£o ordenadas, se o valor em uma coluna for maior que o valor desejado, podemos pular para pr√≥xima linha. A decis√£o do `break` e do `continue` √© feita usando os r√≥tulos que todo bloco de c√≥digo aceita.

```java
int[][] matrix = new int[][] {
        { 2, 2, 2, 3, 4, 5 },
        { 2, 4, 8, 8, 9, 9 },
        { 1, 2, 4, 5, 6, 8 },
        { 0, 3, 4, 8, 8, 9 },
        { 3, 4, 4, 6, 6, 9 },
        { 0, 3, 6, 7, 8, 8 },
};
linhas: for (int linha = 0; linha < matrix.length; ++linha) {
    colunas: for (int coluna = 0; coluna < matrix[linha].length; ++coluna) {
        if (matrix[linha][coluna] == 7) {
            System.out.println("N√∫mero 7 encontrado! (" + linha + "," + coluna + ")");
            break linhas;
        } else if (matrix[linha][coluna] > 7) {
            System.out.println("Desistindo da linha! (" + linha + "," + coluna + ")");
            continue linhas;
        } else if (matrix[linha][coluna] < 7) {
            System.out.println("Pulando para pr√≥xima coluna! (" + linha + "," + coluna + ")");
            continue colunas;
        }
        System.out.println("C√≥digo nunca executado!");
    }
}
```

Se n√£o fosse usado um r√≥tulo, o `break` e o `continue` iriam atuar somente no bloco de c√≥digo mais interno.

## 10. Lance

O `throw` deve ser usado quando algo excepcional acontece. Algo inesperado, tanto que ele lan√ßa uma `Exception`, que significa exce√ß√£o.

Exce√ß√µes podem ser tratadas em c√≥digo, mas as vezes elas n√£o podem ser tratadas o que implica a finaliza√ß√£o da execu√ß√£o. Ao se lan√ßar uma exception, a JVM vai criar uma estrutura que contem o contexto da execu√ß√£o que chamamos de Stacktrace.

Para entender o que √© uma Stacktrace, √© preciso entender como um programa lida com contextos. Quando executamos um bloco de c√≥digo √© criado uma posi√ß√£o no topo da pilha de execu√ß√£o (_stack_ √© pilha em ingl√™s). Ao terminar esse bloco, essa posi√ß√£o √© removida da pilha. Vamos olhar o programa abaixo:

```java
public class StacktraceHelloWorld {
    private static void m1(int x) {
        if (x % 2 == 0 && x > 100) {
            throw new RuntimeException("Primeiro n√∫mero impar depois de 100");
        }
        m2(x + new Random().nextInt(2));
    }

    private static void m2(int j) {
        if (j % 2 == 0 && j > 100) {
            throw new RuntimeException("Primeiro n√∫mero par depois de 100");
        }
        m1(j + new Random().nextInt(2));
    }

    public static void main(String[] args) {
        m1(0);
    }
}
```

A pilha vai ter como funda√ß√£o o m√©todo `main`, depois ela ser√° formada por um encadeamento de chamadas ao m√©todos `m1` e `m2`. Nenhum dos elementos √© removido da pilha porque os m√©todos nunca terminam, els ficam se chamando at√© que a exce√ß√£o do tipo `RuntimeException` seja lan√ßada.

Esse exemplo √© meramente did√°tico para mostrar como funciona o uso do `throw`. Mas se alterarmos o tipo de `RuntimeException` para apenas `Exception` vemos que n√£o ser√° poss√≠vel de compilar porque h√° uma exce√ß√£o n√£o tratada (_Unhandled exception type Exception_). Isso acontece porque existem 3 tipos de exce√ß√µes:

1. `Error`
2. `RuntimeException`
3. `Exception`

`Error` n√£o deve ser definido em um programa. Ele ser√° lan√ßado quando a JVM n√£o souber lidar com uma situa√ß√£o especifica, o exemplo mais comum √© o `OutOfMemoryError` quando a JVM n√£o conseguir alocar mais mem√≥ria.

Uma `RuntimeException` √© uma exce√ß√£o que acontece em tempo de execu√ß√£o, mas poderia ser resolvido com pequenas valida√ß√µes, ou seja, √© algo deveria ter sido previsto. √â o que acontece quando valores nulos n√£o s√£o validados (`NullPointerException`) ou quando acontece a divis√£o por zero (`ArithmeticException`).

Os demais casos devem estender a classe `Exception`, mas ela adicionar√° uma peculiaridade ao c√≥digo. Se um m√©todo n√£o trata um `Exception`, ele deve declarar que lan√ßa a mesma. Isso porque ela √© um resultado esperado, mas que pode ou n√£o ser tratado em c√≥digo. Um exemplo? Quando estamos lidando com conex√µes de rede, sempre existe a possibilidade de a conex√£o ser finalizada, por isso sempre temos a `IOException`. Essa declara√ß√£o se d√° usando o `throws` e este n√£o pode ser ignorado. Ou a exce√ß√£o √© tratado no m√©todo acima ou lan√ßada para o pr√≥ximo m√©todo.

```java
public void conecta() throws IOException {
    // abre e fecha conex√£o
}
```

## 11. Sincronizado

`synchronized` deve ser usada com muita parcim√¥nia. N√≥s vamos ver o seu uso mais a fundo quando formos falar de threads. Mas sendo sucinto, ela pode ser usada tanto para m√©todos quanto para objetos.

Para entender o conceito de sincronia, √© preciso entender o que √© paralelismo e concorr√™ncia. Eu tenho duas atividades que rodam em paralelo quando elas acontecem ao mesmo tempo e n√£o h√° interfer√™ncia entre si. Mas elas se tornam concorrentes quando existem recursos compartilhados que n√£o podem ser acessados ao mesmo tempo.

Dif√≠cil de entender, n√£o? Ent√£o vamos criar um modelo real. Digamos que uma loja tenha um livro caixa que deve registrar todas as vendas. Mas esse livro caixa s√≥ √© atualizado no final do dia atrav√©s das anota√ß√µes de cada vendedor. Assim quando o vendedor realiza uma venda, ele faz uma anota√ß√£o que depois ser√° repassada para o livro caixa. As vendas acontecem em paralelo. Mas ao finalizar a venda existe o registro do estoque que √© um caderno √∫nico que registra a entrada e sa√≠da de itens do estoque. Ou seja, quando o vendedor finaliza a venda, ele deve pegar o registro do estoque e adicionar uma sa√≠da. Se o vendedor A est√° em posse do registro, o vendedor B precisar√° ficar esperando, logo a baixa no caixa s√£o opera√ß√µes concorrentes.

`synchronized` ir√° definir sob qual objeto ser√° definida a sincronia da execu√ß√£o. Ele pode ser usado tanto para m√©todo (est√°tico ou de inst√¢ncia) ou objeto avulso.

```java
class Concorrente {
    public static synchronized void syncStaticMethod() {
        // Toda execu√ß√£o desse m√©todo ser√° concorrente
    }

    public synchronized void syncMethod() {
        // Toda execu√ß√£o desse m√©todo ser√° concorrente somente se for a mesma inst√¢ncia de Concorrente
    }

    public void method(Object lock) {
        synchronized (lock) {
            // Toda execu√ß√£o desse bloco ser√° concorrente somente se a inst√¢ncia de lock for a mesma
        }
    }
}
```

Para que a sincronia seja bem elaborada, devem ser usados tamb√©m os m√©todos `wait`, `notify` e `notifyAll`. Mas n√≥s veremos como isso deve ser feito mais a frente, caso voc√™ precise lidar com valores compartilhados, prefira usar [`AtomicReference`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html) ou outras classes do pacote [`java.util.concurrent.atomic`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html).

## 12. Operadores L√≥gicos

Os operadores l√≥gicos do Java s√£o usados para se criar express√µes booleanas. Uma express√£o booleana s√≥ pode retornar dois tipos de valores: verdadeiro ou falso. 

Como vimos no uso do `if`, devemos sempre definir um valor booleano, mas as vezes ele pode ser uma s√©rie de valores encadeados em uma express√£o.

√â muito importante saber resolver esses tipos de express√£o, essa √© um campo da matem√°tica que se chama Algebra Booleana e, na minha opini√£o, √© um dos requisitos mais b√°sicos para desenvolvimento de software.

No Java tempos tr√™s operadores booleanos `&&`, `||` e `!`

| Operador | Descri√ß√£o | Exemplo  | Significado                                   |
|:--------:|-----------|----------|-----------------------------------------------|
| `&&`     | E         | `a && b` | `true` somente se `a` e `b` forem verdadeiras |
| `||`     | OU        | `a || b` | `true` qualquer um dos valores for verdadeiro |
| `!`      | Nega√ß√£o   | `!a`     | `true` se `a` for `false e vice versa         |

## 13. Operadores Bin√°rios

Operadores bin√°rios realizam opera√ß√µes bin√°rias. Para entender como funcionam opera√ß√µes bin√°rias √© preciso entender que toda informa√ß√£o √© armazenada em formato bin√°rio, isso significa que o n√∫mero `6544` √© o mesmo valor de `0b0001100110010000` e `0x1990`.

| Operador | Descri√ß√£o |
|:--------:|-------------|
| `<<` | Translada os bits para esquerda  |
| `>>` | Translada os bits para a direita |
| `&`  | Faz a opera√ß√£o E bit a bit   |
| `|`  | Faz a opera√ß√£o OU bit a bit  |
| `^`  | Faz a opera√ß√£o XOU bit a bit |
| `~`  | Inverte (complemento) os valores dos bits |


## 14. Operadores Matem√°ticos

Operadores matem√°ticos realizam opera√ß√µes matem√°ticas b√°sicas.

| Operador | Descri√ß√£o |
|:--------:|-------------|
| + | Operador aditivo (tamb√©m usado para concatena√ß√£o de String) |
| - | Operador de subtra√ß√£o |
| * | Operador de multiplica√ß√£o |
| / | Operador de divis√£o |
| % | Operador restante |

## 15. Operadores Un√°rios

Operadores un√°rios realizam opera√ß√µes matem√°ticas b√°sicas usando uma √∫nica vari√°vel. Os operadores un√°rios mais comuns s√£o `++` e `--` que fazem duas opera√ß√µes sequenciais: retornam o valor e alteram o valor da vari√°vel. A posi√ß√£o do operador ir√° influenciar na ordem das opera√ß√µes. Veja o c√≥digo abaixo a diferen√ßa.

```java
int x = 0;    // x=0
int y = ++x;  // x=1 y=1
int z = 0;    // z=0
int w = z++;  // z=1 w=0
```

O operador un√°rio pode ser usado tamb√©m com express√µes, mas para isso deve acompanhar o `=`. Veja no c√≥digo abaixo.

```java
int x = 0;         // x=0
x += 10;           // x=10
int y=2;           // x=10 y=2
x-=y;              // x=8 y=2
boolean w = true;  // w=true
boolean v != x;    // w=true v=false
```

## 16. Cast

O cast √© uma convers√£o. Java √© uma linguagem orientada a objetos, por isso todo valor estende a classe Object, mas todo valor tem uma pr√≥pria classe. Usamos o cast em duas situa√ß√µes distintas, quando vamos lidar com classes mais especificas ou quando precisamos mudar o tipo de n√∫meros.

O primeiro caso vamos ver mais a frente, j√° o segundo √© quando precisamos alterar um tipo de valor para calculo matem√°tico.

```java
float x = 1.23121f;
int y = ((int) (x * 100.0f)) / 2;
System.out.println("x= " + x + " y=" + y);  // x= 1.23121 y=61
```

## 17. Operador condicional

O operador condicional √© como se fosse um `if` em uma s√≥ linha. Ele √© composto de uma express√£o booleana e dois blocos que devem retornar um valor.

Vamos supor que precisamos calcular o valor absoluto de um n√∫mero inteiro, isso pode ser feito com uma linha s√≥.

```java
void int abs(int valor) {
    return valor > 0 ? valor : -valor;
}
```

# Exerc√≠cios

Os exerc√≠cios s√£o propostos como forma de validar que voc√™ pode ir para o pr√≥ximo passo. Para fixar o conte√∫do dessa sess√£o implemente alguns algoritmos b√°sicos como:

1. Implemente a √°rea do c√≠rculo
2. Implemente o calculo da m√©dia aritm√©tica
3. Implemente o calculo da mediana

Para implementar os exerc√≠cios procure por **// [EXERC√çCIO SINTAXE]**, implemente e execute `mvn clean test` para validar.

{% github https://github.com/vepo/java-101 %}