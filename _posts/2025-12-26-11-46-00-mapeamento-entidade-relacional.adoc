---
title: Mapeamento Entidade-Relacional para Modelo Relacional
published: true
description: |
    Neste post, exploramos como mapear um modelo entidade-relacional para um banco de dados relacional utilizando SQL. Vemos como definir entidades, objetos de valor e relacionamentos entre tabelas, além de aplicar restrições de integridade para garantir a consistência dos dados. Também discutimos a importância dos índices para melhorar o desempenho das consultas.
tags: [Ciência da Computação, Bases de Dados, SQL, Modelo Entidade-Relacional, Modelagem de Dados]
cover_image: /assets/images/capas/disquete-100-42.jpg
series: Introdução a Bases de Dados
permalink: /posts/mapeamento-entidade-relacional
publish_date: 2025-12-26 11:46:00 +0300
---

Agora que entendemos os conceitos básicos de uma base de dados relacional e como ela é estruturada, vamos explorar como mapear um modelo entidade-relacional (ER) para uma aplicação. Nesse processo os dados representados no modelo ER são representados em tabelas relacionais que podem ser consultadas e manipuladas usando SQL. 

TIP: Você pode encontrar os exemplos no repositório https://github.com/vepo/sql-database-tutorial[vepo/sql-database-tutorial].

== O que são Entidades?

A base de um modelo relacional são as tabelas que armazenam entidades, objetos de valor e os relacionamentos entre eles. Para entender melhor como fazer esse mapeamento, vamos definir o que são esses conceitos. 

_*Uma Entidade é um objeto ou ente do mundo real que possui existência própria e cujas características ou propriedades desejamos armazenar.*_ Uma entidade pode ser um ente físico (uma pessoa, um carro, um livro ou uma peça) ou um ente abstrato (um curso, um evento, uma conta bancária ou uma transação). O que define uma entidade é que sua existência é baseda em sua identidade única e não nos atributos que ela possui.

Por exemplo, vamos supor que temos um banco de dados para armazenar as informações de funcionários de uma grande empresa. Os campos que queremos armazenar são: nome, sobrenome, data de nascimento e cargo. É possível que existam dois funcionários com o mesmo nome, sobrenome e data de nascimento, mas eles sejam entidades diferentes? Sim, pois cada funcionário é uma pessoa no mundo real. Se depois de adicionado o funcionário desejarmos adicionar um novo campo para armazenar o número de CPF, isso diferenciará os dois funcionários.

Para exemplificar, vamos considerar uma tabela chamada `tb_funcionarios` que armazena as informações dos funcionários da empresa:

.Script para criação da tabela de Funcionários
[source,sql]
----
CREATE TABLE tb_funcionarios (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    nome            VARCHAR(100),
    sobrenome       VARCHAR(100),
    data_nascimento DATE,
    cargo           VARCHAR(100),
    salario         DECIMAL(10,2)
);
----

Nesse exemplo, a tabela `tb_funcionarios` representa a entidade "Funcionário". Cada linha na tabela corresponde a um funcionário específico, identificado de forma única pelo campo `id`, que é a chave primária da tabela. Os outros campos armazenam os atributos do funcionário, como nome, sobrenome, data de nascimento, cargo e salário.

Cada funcionário é considerada uma entidade distinta e única que pode ser identificada pelo seu `id`, independentemente dos outros atributos que possam ser iguais entre diferentes funcionários. A tabela `tb_funcionarios` que armazena as entidades, pode ser considerada um _conjunto de entidades_.

_*Um Conjunto de Entidades é uma coleção de entidades do mesmo tipo que compartilham os mesmos atributos ou propriedades.*_ Cada conjunto de entidades pode ser visto como um conjunto matemático no sentido que todos os seus elementos são distintos e não há uma ordem específica entre eles.

== O que são Objetos de Valor e Relacionamentos?

Agora precisamos adicionar mais informações sobre os funcionários como o endereço e telefone. Essas informações não serão armazenadas na tabela `tb_funcionarios`, pois elas não definem a identidade do funcionário. Para isso, criaremos uma nova tabela chamada `tb_funcionarios_enderecos` e outra chamada `tb_funcionarios_contatos` para armazenar essas informações como objetos de valor relacionados à entidade funcionário.

_*Um Objeto de Valor é um objeto que não possui identidade própria e sua existência é baseada em seus atributos.*_ Diferente das entidades, os objetos de valor são definidos pelos atributos que possuem. Dois objetos de valor são considerados iguais se todos os seus atributos forem iguais, o que não significa que eles são a mesma linha em uma tabela relacional.

Vamos criar as tabelas `tb_funcionarios_enderecos` e `tb_funcionarios_contatos` para armazenar os endereços e contatos dos funcionários:

.Script para criação das tabelas de Endereços e Contatos
[source,sql]
----
CREATE TABLE tb_funcionarios_enderecos (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    funcionario_id  BIGINT NOT NULL,       -- Chave Estrangeira para tb_funcionarios
    rua             VARCHAR(200),
    cidade          VARCHAR(100),
    estado          VARCHAR(100),
    cep             VARCHAR(20),
    FOREIGN KEY (funcionario_id) REFERENCES tb_funcionarios(id) -- Chave Estrangeira
);

CREATE TABLE tb_funcionarios_contatos (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    funcionario_id  BIGINT NOT NULL, -- Chave Estrangeira para tb_funcionarios
    tipo            VARCHAR(50),     -- Ex: 'telefone', 'email'
    valor           VARCHAR(100),    -- Ex: número de telefone ou endereço de email
    FOREIGN KEY (funcionario_id) REFERENCES tb_funcionarios(id) -- Chave Estrangeira
);
----

Talvez você tenha notado que as tabelas `tb_funcionarios_enderecos` e `tb_funcionarios_contatos` possuem uma coluna chamada `funcionario_id`, que é uma chave estrangeira referenciando a tabela `tb_funcionarios`. Isso estabelece um relacionamento entre as tabelas, indicando que cada endereço e contato está associado a um funcionário específico.

_*Um Relacionamento é uma associação entre uma ou mais tabelas que define como os dados se relacionam entre si.*_ Relacionamentos são essenciais para manter a integridade dos dados e garantir que as informações estejam corretamente vinculadas.

== Como podemos classificar os tipos de Relacionamentos?

No nosso exemplo, o relacionamento entre as tabelas `tb_funcionarios`, `tb_funcionarios_enderecos` e `tb_funcionarios_contatos` é do tipo um-para-muitos (_one-to-many_). Isso significa que um funcionário pode ter múltiplos endereços e contatos, mas cada endereço ou contato está associado a apenas um funcionário.

// https://editor.plantuml.com/uml/SoWkIImgISv8pUFYIiqhoIofL70hpKikoSpFIopAp5Uevgg5IxZcfQGMfIQZ2ZhdvvKaba35KBJg-kd2jM3AGFLnSN4vfEQbW1q00000

.PlantUML Diagrama de Relacionamento entre Funcionários, Endereços e Contatos
image::databases/er-funcionario-contatos-enderecos.png[]

Relacionamentos podem ser classificados em três tipos principais:

* _Um-para-um (one-to-one)_: Cada registro em uma tabela está associado a no máximo um registro em outra tabela.
* _Um-para-muitos (one-to-many)_: Um registro em uma tabela pode estar associado a múltiplos registros em outra tabela.
* _Muitos-para-muitos (many-to-many)_: Múltiplos registros em uma tabela podem estar associados a múltiplos registros em outra tabela. Esse tipo de relacionamento geralmente requer uma tabela intermediária para gerenciar as associações.

Apesar dos tipos de relacionamentos serem importantes, eles não são diretamente definidos na linguagem SQL. Em vez disso, eles são definidos pela forma em que as chaves primárias e as estrangeiras são configuradas entre as tabelas. 

Vamos imaginar agora que queremos armazenar a informação da profissional anterior dos funcionários em uma tabela chamada `tb_funcionarios_experiencias_anterior`, que terá um relacionamento um-para-um com a tabela `tb_funcionarios`. Cada funcionário terá apenas uma experiência profissional registrada. Para isso precisamos alterar a tabela `tb_funcionarios` e criar a nova tabela `tb_funcionarios_experiencias_anterior`:

.Script para criação da tabela de Experiências Profissionais
[source,sql]
----
CREATE TABLE tb_funcionarios_experiencias_anterior (
    id              BIGSERIAL PRIMARY KEY, -- Chave Primária
    empresa         VARCHAR(100),
    cargo           VARCHAR(100),
    data_inicio     DATE,
    data_fim        DATE
);

ALTER TABLE tb_funcionarios
ADD experiencia_anterior_id BIGINT, -- Chave Estrangeira para tb_funcionarios_experiencias_anterior
ADD FOREIGN KEY (tb_funcionarios) REFERENCES tb_funcionarios_experiencias_anterior(id), -- Chave Estrangeira
ADD UNIQUE (tb_funcionarios); -- Garante o relacionamento um-para-um
----

Nesse exemplo, a tabela `tb_funcionarios_experiencias_anterior` armazena as informações sobre as experiências profissionais dos funcionários. A tabela `tb_funcionarios` foi alterada para incluir uma coluna `experiencia_anterior_id`, que é uma chave estrangeira referenciando a tabela `tb_funcionarios_experiencias_anterior`. A restrição `UNIQUE` garante que cada funcionário possa ter no máximo uma experiência profissional associada, estabelecendo assim o relacionamento um-para-um.

Com essa estrutura, podemos ter a certeza que cada funcionário terá apenas uma experiência profissional registrada, e cada experiência profissional estará associada a apenas um funcionário.

== O que são Restrições de Integridade (_Constraints_)?

Não sei se você notou, mas no exemplo acima, utilizamos algumas restrições de integridade (_constraints_) para garantir a consistência dos dados no banco de dados relacional. As restrições de integridade são regras que definem como os dados podem ser inseridos, atualizados ou deletados em uma tabela. Elas ajudam a manter a integridade dos dados e evitam inconsistências.

Bases de dados relacionais permitem definir as restrições de integridade diretamente na definição das tabelas usando a linguagem SQL. Algumas das restrições mais comuns incluem:

* _Chave Primária (PRIMARY KEY)_: Garante que cada registro em uma tabela seja único e não nulo. No exemplo, usamos a chave primária para identificar unicamente cada funcionário, endereço, contato e experiência profissional.
* _Chave Estrangeira (FOREIGN KEY)_: Garante que os valores em uma coluna correspondam aos valores em outra tabela, estabelecendo um relacionamento entre as tabelas. No exemplo, usamos chaves estrangeiras para associar endereços e contatos aos funcionários.
* _Único (UNIQUE)_: Garante que os valores em uma coluna sejam únicos. No exemplo, usamos a restrição `UNIQUE` para garantir que cada funcionário tenha no máximo uma experiência profissional associada.
* _Não Nulo (NOT NULL)_: Garante que uma coluna não possa conter valores nulos. Isso é útil para garantir que certos atributos essenciais estejam sempre presentes em um registro.
* _Verificação (CHECK)_: Permite definir uma condição que os valores em uma coluna devem satisfazer. Por exemplo, podemos usar uma restrição `CHECK` para garantir que a data de término de uma experiência profissional seja posterior à data de início.
* _Padrão (DEFAULT)_: Define um valor padrão para uma coluna quando nenhum valor é especificado durante a inserção de um registro.

Com as restrições de integridade, podemos garantir que os dados no banco de dados relacional estejam sempre consistentes e válidos, evitando problemas como duplicidade de registros, referências inválidas entre tabelas e valores nulos em campos essenciais. 

E se no nosso exemplo quisermos garantir que o campo `cargo` na tabela `tb_funcionarios` não possa ser nulo? Podemos adicionar a restrição `NOT NULL` na definição da tabela:


.Script para criação da tabela de Funcionários com restrição NOT NULL
[source,sql]
----
ALTER TABLE tb_funcionarios
MODIFY cargo VARCHAR(100) NOT NULL; -- Adiciona a restrição NOT NULL
----

Esse exemplo não é completo, poderiamos também que os valores dos demais campos não fossem nulos, mas serve para ilustrar como as restrições de integridade podem ser aplicadas para garantir a consistência dos dados no banco de dados relacional.

Mas ainda falta um detalhe importante: e se nossa empresa for muito grande e quisermos encontrar facilmente um determinado funcionário pelo nome ou cargo? Para isso, podemos criar índices nas colunas `nome`, `sobrenome` e `cargo` da tabela `tb_funcionarios`.

== O que são Índices (_Indexes_)?

Para entender como a consulta é realizada em uma base de dados, podemos pedir para a base explicar como ela pretende executar a consulta. Isso é possível utilizando o comando `EXPLAIN` antes da consulta SQL. Vamos imaginar que queremos encontrar todos os funcionários com o cargo de "Desenvolvedor". A consulta SQL seria a seguinte:

.Script para consulta de funcionários pelo cargo
[source,sql]
----
EXPLAIN SELECT * FROM tb_funcionarios WHERE cargo = 'Desenvolvedor';
----

A resposta do comando `EXPLAIN` nos mostrará o plano de execução que a base de dados pretende utilizar para realizar a consulta. Se não houver um índice na coluna `cargo`, a base de dados terá que fazer uma varredura completa na tabela `tb_funcionarios`, o que pode ser lento se a tabela tiver muitos registros.

Mas podemos melhorar o desempenho da consulta criando um índice na coluna `cargo`:

.Script para criação de índice na coluna cargo
[source,sql]
----
CREATE INDEX idx_funcionarios_cargo ON tb_funcionarios(cargo);
----

Com o índice criado, a base de dados poderá utilizar o índice para localizar rapidamente os registros que correspondem ao cargo "Desenvolvedor", melhorando significativamente o desempenho da consulta.

== Conclusão

Neste post, exploramos como mapear um modelo entidade-relacional para um banco de dados relacional utilizando SQL. Vimos como definir entidades, objetos de valor e relacionamentos entre tabelas, além de aplicar restrições de integridade para garantir a consistência dos dados. Também discutimos a importância dos índices para melhorar o desempenho das consultas. Compreender esses conceitos é fundamental para projetar e implementar aplicações usando bases de dados relacionais de forma eficiente e eficaz.