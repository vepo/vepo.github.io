---
title: "Java I/O"
published: true
description: Quais s√£o as bibliotecas para leitura de arquivos em Java? O que significa ler e escrever em um programa? A ideia desta s√©rie √© criar um tutorial Java onde mostrarei todos os segredos da linguagem e do ecossistema.
tags: [Java, Tutorial, I/O]
cover_image: /assets/images/java/duke-chez-100-42.webp
series: Java 101
permalink: /posts/java-101-io
publish_date: 2022-07-04 23:53:00 +0300
---

:figure-caption: Figura
:imagesdir: /assets/images/java-101

Esse post faz parte de uma s√©rie introdut√≥ria sobre Java, se voc√™ n√£o conhece a linguagem e n√£o leu os posts anteriores, recomendo os ler para ter uma vis√£o melhor da plataforma. Nessa s√©rie, j√° falamos sobre o que √© o ecossistema Java, o que √© a biblioteca Collections e como Java faz Orienta√ß√£o a Objetos, esses t√≥picos s√£o necess√°rios para o que vamos falar agora: **I/O**.

[#cap-05-o-que-e-io]
== O que √© I/O?!?

Quando pensamos em um computador a primeira coisa que pensamos √© no que fazemos online: enviar um tweet, responder email, ver um v√≠deo ou mesmo ler esse post. Mas um computador n√£o entende essas atividades, para ele tudo s√£o bits, ou seja, todas essa s√£o atividades podem ser traduzidas em outras atividades de baixo n√≠vel. Quando eu uso o termo "baixo n√≠vel" entenda como algo de menor abstra√ß√£o, por exemplo, para voc√™ ler esse post, o seu navegador teve que renderizar uma p√°gina HTML, que foi requisitada de um servidor HTTP usando uma conex√£o Socket, que na verdade √© apenas uma troca de bits entre v√°rios computadores. Essas atividades sempre envolvem trocas de informa√ß√µes que s√≥ s√£o poss√≠vel atrav√©s de algo chamado **serializa√ß√£o**.

**Serializa√ß√£o** seria a transforma√ß√£o de uma informa√ß√£o em um formato intermedi√°rio para que ela possa transitar entre dois processos. Ou seja, a informa√ß√£o que voc√™ est√° lendo agora √© composta de alguns arquivos HTML, Javascript, CSS, PNG e JPEG que s√£o enviadas atrav√©s da web usando o protocolo HTTP sobre TLS.

_‚Äî  Voc√™ n√£o ia falar de I/O? Que papo √© esse de **serializa√ß√£o** e internet?!?_

Sim, I/O √© outra forma de falar sobre serializa√ß√£o. Toda informa√ß√£o para ser enviada ela passa pelos passos de (1) serializa√ß√£o, (2) escrita, (3) transmiss√£o, (4) leitura e (5) desserializa√ß√£o. O processo de transmiss√£o pode ser o envio dessa informa√ß√£o atrav√©s de uma API, ou o armazenamento dela em um banco de dados ou mesmo a escrita no disco para que possa ser lida no futuro. Os formatos de serializa√ß√£o de dados s√£o bem interessantes de se analisar, mas n√£o √© o foco desse post, aqui focaremos em conhecer as bibliotecas que a JVM nos oferece para que possamos ler e escrever objetos onde bem desejarmos.

Na JVM existem dois pacotes que lidam com serializa√ß√£o em Java. O mais conhecido deles √© o https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html[`java.io`] onde est√£o definidas as classes para leitura s√≠ncrona. J√° no https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html[`java.nio`] est√£o definidas as classes para leitura ass√≠ncrona (Non-blocking I/O).

Seria hipocrisia da minha parte dizer que voc√™ deve conhecer esses pacotes por completo, eu n√£o os conhe√ßo. S√≥ quem trabalha especificamente com I/O deve conhecer bem essas classes. N√£o se surpreenda se um desenvolvedor com anos de experi√™ncia em Java procurar no Google _"how to read a text file in Java"_. Isso acontece porque esses pacotes s√£o complexos e por isso dif√≠ceis de serem internalizados. Mas voc√™ deve saber algumas informa√ß√µes importantes e n√≥s vamos trabalhar elas aqui.

1. Porque a interface `Serializable`? Devo usar?
2. O que √© um `InputStream` e um `OutputStream`?
3. Qual Stream devo usar?
4. Qual a diferen√ßa entre um Stream e os Readers/Writers?

N√≥s n√£o vamos falar de NIO, esse ser√° o assunto de um post mais a frente. N√£o estranhe se voc√™ perceber que um S√™nior n√£o sabe como usar as classes desse pacote, em muitos casos elas s√£o usadas apenas pelos frameworks o que implica que muitos desenvolvedores nunca tiveram contato com ela.

=== A diferen√ßa entre IO e NIO

Talvez voc√™ tenha ficado curioso do motivo de existirem dois pacotes para I/O. N√£o ficou? Bom, existem dois pacotes diferentes porque NIO √© um conceito muito mais novo do que IO. IO existe desde que os computadores existem e sempre foi um problema para qualquer software. Se voc√™ n√£o fez faculdade de Ci√™ncia da Computa√ß√£o, saiba que existe at√© uma mat√©ria s√≥ pensando em como se criar estrutura de dados para arquivos, isso porque ao se ler um arquivos nos deparamos com alguns problemas que deveriam ser √≥bvios: (1) o tempo de leitura √© muito inferior ao tempo de acesso a mem√≥ria, (2) os dados s√£o armazenados em blocos que n√£o s√£o facilmente rearranj√°veis e (3) a leitura de blocos pr√≥ximos √© mais r√°pida que a leitura de blocos distantes. Os discos mais novos n√£o possuem o problema (3), mas mesmo assim ler e escrever de arquivo n√£o pode ser feito da mesma forma que ler e escrever na mem√≥ria.

_‚Äî  Escrever na mem√≥ria?!?! Eu nunca escrevi na mem√≥ria!!!_

Todo programa, ao ser executado, est√° armazenado na mem√≥ria. Essa √© uma opera√ß√£o t√£o comum que √© transparente para linguagens alto n√≠vel. Se estiv√©ssemos escrevendo em C seria preciso alocar e desalocar mem√≥ria. Mas em Java a aloca√ß√£o √© feita com um `new` e a mem√≥ria √© desalocada automaticamente. Mas n√£o √© poss√≠vel alocar espa√ßa em disco.

Se compararmos a escrita e mem√≥ria com a escrita em disco, ou interface de redes, vemos que a primeira √© t√£o r√°pida que pode ser considerada imediata. J√° os outros tipos de escrita n√£o podem ser consideradas imediatas, por isso surgiram uma s√©rie de interfaces capazes de avisar ao software quando o dado est√° pronto para ser lido. √â nesse ponto que diferenciamos IO de NIO! O pacote `java.io` s√£o classes usadas para leitura/escrita bloqueante, enquanto o pacote `java.nio` s√£o classes de leitura/escrita n√£o bloqueante. E como NIO √© mais recente que o IO tradicional, seu pacote foi inserido em uma vers√£o do Java bem mais recente (JDK 1.4).

[#cap-05-arquivos-sockets-linux]
== Arquivos, Sockets e Linux üêß

Uma das grandes vantagens do Sistema Operacional Linux √© que tudo s√£o arquivos. Quase todas as funcionalidades do sistema operacional s√£o expostas atrav√©s de arquivos mapeados no sistema de arquivos. Assim ao inv√©s de fazer uma chamada de sistema complexa para, por exemplo, obter o tempo que a m√°quina est√° em opera√ß√£o, basta ler o arquivo `/proc/uptime`. Ou ler o arquivo `/proc/cpuinfo` para obter uma s√©rie de informa√ß√µes sobre a CPU. 

Essa foi uma escolha arquitetural do sistema que se tornou bastante eficaz porque cria uma interface comum entre diversas opera√ß√µes. Por exemplo, se voc√™ for procurar no Windows a maneira de se ver todos os processo em execu√ß√£o, ver√° que tem uma https://docs.microsoft.com/pt-br/windows/win32/psapi/enumerating-all-processes[API (_lembre-se que API n√£o se refere s√≥ a API REST_) complexa], mas em um Linux basta executar `ls /proc` e todos os diret√≥rios com n√∫meros s√£o processos. Para saber mais informa√ß√µes dos processos, basta acessar alguns arquivos dentro dessas pastas.

Essa informa√ß√£o pode parecer perdida, mas ela tem uma rela√ß√£o profunda com o que veremos a seguir. Quando o Linux escolhe mapear tudo como arquivo, a escolha feita √© por se tratar diversas formas de dados por uma mesma interface. Arquivos s√£o f√°ceis de serem lidos, ent√£o ao expor tudo como arquivo √© f√°cil conseguir acessar essas informa√ß√µes. A JVM tamb√©m traz a mesma abordagem! Tudo em serializa√ß√£o vai se resumir a poucas classes. A opera√ß√£o de leitura de um arquivo ou leitura de um socket s√£o t√£o semelhantes que podem ser executadas pelo mesmo c√≥digo.

[#cap-05-apresentacao-pacote]
== Apresenta√ß√£o do pacote `java.io`

Para entendermos o pacote `java.io` primeiro precisamos entender o que √© um Stream (ou fluxo em tradu√ß√£o livre). N√£o confunda Stream de I/O com Stream de Collections, eles tem um conceito parecido, mas s√£o aplicados em locais diferentes. Stream significa fluxo e quando falamos de Stream estamos falando de uma informa√ß√£o que flui em sentido √∫nico. 

Para entender melhor √© preciso pensar em como era feito antes... As bibliotecas do C para leitura de arquivo/socket n√£o fazem diferencia√ß√£o entre as interfaces de leitura e escrita, ao se criar um canal de comunica√ß√£o temos um inteiro que identifica o canal e esse inteiro pode ser usado tanto para leitura como para escrita. Observe a documenta√ß√£o das fun√ß√µes https://man7.org/linux/man-pages/man2/read.2.html[`read`] e https://man7.org/linux/man-pages/man2/write.2.html[`write`] e veja que elas recebem os mesmo argumentos.


[.text-center]
.Documenta√ß√£o da fun√ß√£o read
image::java-101/cap-05/read.PNG[id=cap-05-c-read, link=https://man7.org/linux/man-pages/man2/read.2.html, align="center"]


[.text-center]
.Documenta√ß√£o da fun√ß√£o write
image::java-101/cap-05/write.PNG[id=cap-05-c-write, link=https://man7.org/linux/man-pages/man2/write.2.html, align="center"]

Em Java foi decidido que haveria uma diferencia√ß√£o l√≥gica entre leitura e escrita. Ao se ler um arquivo poder√≠amos ter o fluxo de leitura (InputStream ou Reader) e o fluxo de escrita (`OutputStream` ou `Writer`). Cada um desses fluxos teria uma orienta√ß√£o √∫nica, isso significa que um InputStream apenas l√™ e o `OutputStream` apenas escreve. √â por isso que se usa o nome Stream.

Essa √© a primeira informa√ß√£o importante do pacote `java.io`: **As interfaces de leitura s√£o separadas das interfaces de escrita!** Para apresentar o pacote em um diagrama de classes foi at√© preciso criar essa separa√ß√£o para possibilitar que melhor visualiza√ß√£o.

Outro ponto da biblioteca C que explica o funcionamento do pacote `java.io` s√£o as fun√ß√µes https://man7.org/linux/man-pages/man2/open.2.html[`open`] e https://man7.org/linux/man-pages/man2/close.2.html[`close`]. Em qualquer sistema operacional para se realizar a leitura em arquivo, ou em um socket, s√≥ √© poss√≠vel com a aloca√ß√£o de recurso. Isso √© feito para evitar que processos diferentes criem estados inconsistentes. Quando um processo chama a fun√ß√£o `open` para um determinado arquivo, ele n√£o poder√° ser aberto por outro processo enquanto n√£o for liberado atrav√©s da fun√ß√£o `close`. Se a fun√ß√£o `close` n√£o for chamada, o arquivo s√≥ ser√° liberado quando o processo morrer o que pode tamb√©m gerar um estado inconsistente. Por isso era importante garantir na escrita do c√≥digo que a fun√ß√£o close sempre fosse chamada e que o arquivo sempre estivesse em um estado consistente. Lembre-se que leitura e escrita n√£o s√£o processos imediatos, se o programa finalizar ou o arquivo for fechado antes da escrita terminar, o arquivo fica em um estado inconsistente.

[.text-center]
.Documenta√ß√£o da fun√ß√£o open
image::java-101/cap-05/open.PNG[id=cap-05-c-open, link=https://man7.org/linux/man-pages/man2/open.2.html, align="center"]

[.text-center]
.Documenta√ß√£o da fun√ß√£o close
image::java-101/cap-05/close.PNG[id=cap-05-c-close, link=https://man7.org/linux/man-pages/man2/close.2.html, align="center"]

Agora volta ao Java... Em C era preciso criar mecanismos de garantir que o arquivo estava fechado antes que o programa finalizasse. Em Java isso foi internalizado na linguagem atrav√©s de alguns mecanismos. Por isso temos as interfaces `Closeable` e `AutoCloseable`. Se um objeto precisa liberar recursos depois de usado, ele deve implementar a interface `Closeable` e o m√©todo `close` deve ser chamado. At√© a vers√£o 6 do Java era comum ver o `close` sendo chamado dentro do bloco `finally` de um `try {} catch {} finally {}`.

[source,java]
----
Reader reader = null;
try {
    reader = // inicia reader
    // l√™ dados
} catch (IOException ioe) {
    // trata exce√ß√£o
} finally {
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException ioe) {
            // trata exce√ß√£o
        }
    }
}
----

Como esse c√≥digo tem muito _boilerplate_ (c√≥digo sem significado √∫nico, repetido), o Java 7 trouxe um recurso na sintaxe chamado _try-with-resources_. Agora todo inicio de um _try-catch_ √© poss√≠vel declarar um ou mais objetos que devem implementar a nova interface chamada `AutoCloseable`. Como esse √© um recurso da linguagem, a interface `AutoCloseable` n√£o faz parte do pacote `java.io`, ao contr√°rio da interface `Closeable`, mas do package `java.lang`. Assim o bloco finally poderia ser removido sem preju√≠zo nenhum a l√≥gica do programa.

[source,java]
----
try (Reader reader = /* inicia reader */) {
    // l√™ dados
} catch (IOException ioe) {
    // trata exce√ß√£o
}
----

Agora que sabemos que (1) objetos de I/O devem liberar recursos e que as classes de I/O s√£o do tipo `Closeable`, observe as principais classes do pacote. Vamos explorar um pouco delas.

////
@startuml
title
Java I/O
end title

interface Serializable {}

interface AutoCloseable {
    + close()
}

interface Closeable {
    + close()
}

interface Readable {
    + int read(CharBuffer cb)
}

abstract class InputStream {
    + int available()
    + void close()
    + void mark(int readlimit)
    + boolean markSupported()
    {abstract} + int read()
    + int read(byte[] b)
    + int read(byte[] b, int off, int len)
    + void reset()
    + long skip(long n)
}


abstract class Reader {
    + void mark(int readAheadLimit)
    + boolean markSupported()
    + int read()
    + int read(char[] cbuf)
    + {abstract} int read(char[] cbuf, int off, int len)
    + int read(CharBuffer target)
    + boolean ready()
    + void reset()
    + long skip(long n)
}

together {
    class ObjectInputStream {
        + boolean readBoolean()
        + byte readByte()
        + char readChar()
        + double readDouble()
        + float readFloat()
        + int readInt()
        + long readLong()
        + Object readObject()
        + short readShort()
    }


    class ByteArrayInputStream {
    }

    class BufferedInputStream {
    }

    class FileInputStream {
    + FileChannel getChannel()
    + FileDescriptor getFD()
    }
}



AutoCloseable <|-- Closeable
Closeable <|-- InputStream
InputStream <|-- ObjectInputStream 
InputStream <|-- ByteArrayInputStream
InputStream <|-- BufferedInputStream
InputStream <|-- FileInputStream 


together {
    class BufferedReader {
        + Stream<String> lines()
        + String readLine()
    }
    class LineNumberReader {
        + String readLine()
        + void setLineNumber(int lineNumber)
    }
    class CharArrayReader {}
    class InputStreamReader {}
    class FileReader {}
}

Closeable <|-- Reader 
Readable <|-- Reader 

Reader <|-- BufferedReader
Reader <|-- LineNumberReader
Reader <|-- CharArrayReader
Reader <|-- InputStreamReader
InputStreamReader <|-- FileReader

@enduml
////

[.text-center]
.Java I/O classes de leitura
image::java-101/cap-05/IO-Read.png[id=cap-05-io-read, align="center"]

////
@startuml
title
Java I/O
end title

interface Serializable {}

interface AutoCloseable {
    + close()
}

interface Closeable {
    + close()
}

together {
interface Flushable {
    + void flush()
}

interface Appendable {
    + Appendable append(char c)
    + Appendable append(CharSequence csq)
    + Appendable append(CharSequence c, int start, int end)
}
}

abstract class OutputStream {
    + void write(byte[] b)
    + void write(byte[] b, int off, int len)
    {abstract} + void write(int b)
}

abstract class Writer {
    + Writer append(char c)
    + Writer append(CharSequence csq)
    + Writer append(CharSequence csq, int start, int end)
    + void write(char[] cbuf)
    {abstract} + void write(char[] cbuf, int off, int len)
    + void write(int c)
    + void write(String str)
    + void write(String str, int off, int len)
}

AutoCloseable <|-- Closeable

together {
    class ObjectOutputStream {
        + void writeBoolean(boolean val)
        + void writeByte(int val)
        + void writeBytes(String str)
        + void writeChar(int val)
        + void writeChars(String str)
        + void writeDouble(double val)
        + void writeFloat(float val)
        + void writeInt(int val)
        + void writeLong(long val)
        + void writeObject(Object obj)
        + void writeShort(int val)
    }

    class BufferedOutputStream {
    }

    class ByteArrayOutputStream {
    }

    class FileOutputStream {
        + FileChannel getChannel()
        + FileDescriptor getFD()
    }

Closeable <|-- OutputStream 
Flushable <|-- OutputStream 
OutputStream <|-- ObjectOutputStream 
OutputStream <|-- BufferedOutputStream
OutputStream <|-- ByteArrayOutputStream 
OutputStream <|-- FileOutputStream 

together {
    class BufferedWriter {
        + void newLine()
        + void write(String s, int off, int len)
    }
    class CharArrayWriter {
        + void writeTo(Writer out)
    }
    class OutputStreamWriter {
        + String getEncoding()
    }
    class FileWriter {}
    class PrintWriter {}
}

Closeable <|-- Writer 
Flushable <|-- Writer 
Appendable <|-- Writer 

Writer <|-- BufferedWriter
Writer <|-- CharArrayWriter
Writer <|-- OutputStreamWriter
Writer <|-- PrintWriter
OutputStreamWriter <|-- FileWriter
@enduml
////

[.text-center]
.Java I/O classes de escrita
image::java-101/cap-05/IO-Write.png[id=cap-05-io-write, align="center"]

== Casos de Uso

Para explorar melhor essas classes, vamos dividir o pacote em 5 casos de usos bem comuns para biblioteca I/O.

1. Como ler um arquivo?
2. Como escrever um arquivo?
3. Como ler dados do console?
4. Como ler/escrever em Socket?
5. Lidando objetos complexos

=== 1. Como ler um arquivo?

Falamos anteriormente que a diferen√ßa entre um InputStream e um Reader √© que o InputStream trabalha com bytes enquanto o Reader com caracteres. Agora vamos mostrar um exemplo pr√°tico? Imagina que voc√™ tem um arquivo texto em formato JSON, como fazer pra o ler? Se pensou em ler usando um Reader... v√° com calma! A primeira coisa a fazer √© decidir qual biblioteca vai ser usada para ler o JSON. A escolha deve come√ßar pelo elemento mais complexo.

Para se ler um JSON, temos uma biblioteca praticamente onipresente: https://github.com/FasterXML/jackson-databind/[Jackson Databind]! O cora√ß√£o dessa biblioteca √© a classe https://fasterxml.github.io/jackson-databind/javadoc/2.13/com/fasterxml/jackson/databind/ObjectMapper.html[ObjectMapper] e ela define v√°rias formas de se escrever em arquivo, a forma mais f√°cil nem chega a usar Stream ou Readers. O c√≥digo abaixo foi retirado a pr√≥pria documenta√ß√£o do ObjectMapper, observe que n√£o se usa nem InputStream/OutputStream ou Readers/Writers.

[source,java]
----
final ObjectMapper mapper = new ObjectMapper(); // can use static singleton, inject: just make sure to reuse!
MyValue value = new MyValue();
// ... and configure
File newState = new File("my-stuff.json");
mapper.writeValue(newState, value); // writes JSON serialization of MyValue instance
// or, read
MyValue older = mapper.readValue(new File("my-older-stuff.json"), MyValue.class);

// Or if you prefer JSON Tree representation:
JsonNode root = mapper.readTree(newState);
// and find values by, for example, using a JsonPointer expression:
int age = root.at("/personal/age").getValueAsInt(); 
----

Mas isso n√£o impede que se use eles para ler dados de um arquivo. A primeira miss√£o que temos √© mapear o objeto que devemos ler como um POJO. Em um projeto pessoal eu criei uma interface para inspecionar Cluster Kafka, o https://blog.vepo.dev/projects/kafka-tool[Kafka Tool]. Nesse projeto, todas as configura√ß√µes s√£o salvas em arquivos JSON no diret√≥rio `~/.kafka-tool` (arquivos come√ßados com `.` s√£o considerados ocultos no Linux), assim para armazenar as informa√ß√µes de Brokers √© preciso primeiro mapear um broker. Depois de mapeador o broker √© preciso carregar a lista de brokers do arquivo, para isso basta usar o c√≥digo abaixo.

[source,java]
----
Path kafkaToolConfigPath = PAths.get(System.getProperty("user.home"), ".kafka-tool");
if (!kafkaToolConfigPath.toFile().exists()) {
    
    Path propertiesPath = kafkaToolConfigPath.resolve("kafka-properties.json");
    if (propertiesPath.toFile().exists()) {
        try (BufferedReader reader = Files.newBufferedReader(propertiesPath)) {
            return Optional.of(reader.lines()
                                     .collect(Collectors.joining()))
                           .filter(Predicate.not(String::isBlank))
                           .flatMap(value -> handleIoException(() -> mapper.readValue(value, KafkaBroker[].class)));
        } catch (IOException e) {
            logger.error("Error reading file!", e);
        }
    }
}
return Optional.empty();
----

Para ler usamos um https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html[`BufferedReader`] porque ele permite ler todo o arquivo em texto facilmente, para isso usamos a o m√©todo https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedReader-java.nio.file.Path-[`Files.newBufferedReader`], que pode ser lido atrav√©s do m√©todo https://fasterxml.github.io/jackson-databind/javadoc/2.13/com/fasterxml/jackson/databind/ObjectMapper.html#readValue-java.lang.String-java.lang.Class-[`ObjectMapper.readValue`] que aceita `String`. Mas tamb√©m pod√≠amos abrir um `InputStream` usando https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newInputStream-java.nio.file.Path-java.nio.file.OpenOption...-[`Files.newInputStream`] e usar ele diretamente como par√¢metro https://fasterxml.github.io/jackson-databind/javadoc/2.13/com/fasterxml/jackson/databind/ObjectMapper.html#readValue-java.io.InputStream-java.lang.Class-[`ObjectMapper.readValue`]


=== 2. Como escrever um arquivo?

De forma bem similar podemos escreve em arquivos usando as mesmas APIs. 

[source,java]
----
Path kafkaToolConfigPath = PAths.get(System.getProperty("user.home"), ".kafka-tool");
if (!kafkaToolConfigPath.toFile().exists()) {
    kafkaToolConfigPath.toFile().mkdir();
}

Path propertiesPath = kafkaToolConfigPath.resolve("kafka-properties.json");
ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT)
try (BufferedWriter writer = Files.newBufferedWriter(propertiesPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {
    writer.write(mapper.writeValueAsString(brokers));
} catch (IOException e) {
    logger.error("Error saving file!", e);
}
----

Para escrever usamos um https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html[`BufferedWriter`], atrav√©s do https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedWriter-java.nio.file.Path-java.nio.file.OpenOption...-[`Files.newBufferedWriter`], porque √© uma op√ß√£o vi√°vel para se usar com https://fasterxml.github.io/jackson-databind/javadoc/2.13/com/fasterxml/jackson/databind/ObjectMapper.html#writeValueAsString-java.lang.Object-[`ObjectMapper.writeValueAsString`]. Mas da mesma forma pod√≠amos usar https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html[`OutputStream`], atrav√©s do https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newOutputStream-java.nio.file.Path-java.nio.file.OpenOption...-[`Files.newOutputStream`], porque tamb√©m √© uma op√ß√£o vi√°vel para se usar com https://fasterxml.github.io/jackson-databind/javadoc/2.13/com/fasterxml/jackson/databind/ObjectMapper.html#writeValueAsBytes-java.lang.Object-[`ObjectMapper.writeValueAsBytes`]

=== 3. Como ler dados do console?

Toda aplica√ß√£o pode rodar em modo de linha de comando. Linha de comando √© bastante √∫til porque possibilita que as aplica√ß√µes sejam integradas a scripts de execu√ß√£o seguindo a Filosofia Unix: **_Escreva programas para lidar com fluxos de texto, porque essa √© uma interface universal_**.

A primeira informa√ß√£o importante √© saber que os streams de entrada, sa√≠da e erro est√£o expostos como vari√°veis globais na classe https://docs.oracle.com/javase/8/docs/api/java/lang/System.html[`System`]. Assim podemos facilmente escrever um programa que l√™ da linha de comando com algumas linhas.

[source,java]
----
try(BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
    String name = reader.readLine();
    System.out.println(name);
}
----

Esse c√≥digo √© certo e funciona, mas existe uma outra classe que facilita em muito o tratamento de dados que vem do console, √© a classe https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html[`Scanner`]. Com ela √© poss√≠vel tratar os dados de entrada de forma mais f√°cil. Por exemplo se eu quiser fazer um programa para l√™ n√∫meros do console, √© poss√≠vel fazer com poucas linhas.

[source,java]
----
try(Scanner in = new Scanner(System.in)) {
    System.out.print("Qual o seu nome? ");
    String nome = in.nextLine();
    System.out.print("Quantos anos voc√™ tem? ");
    int idade = in.nextInt();
    System.out.println("Oi " + nome + "! Voc√™ tem " + idade + " anos!");
}
----

=== 4. Como ler/escrever em Socket?

Sockets devem ser usados com parcim√¥nia! Sockets permitem que dois processos se comuniquem entre si atrav√©s de uma conex√£o TCP direta. O problema em usar Sockets √© que em muitos casos voc√™ pode estar reimplementando um protocolo j√° conhecido. Mas as vantagens de se usar socket √© que seu programa vai ter liberdade de se comunicar. Quando temos dois programas se comunicando por socket um deles ser√° o cliente e o outro ser√° o servidor, √© o que chamamos de Socket Server.

.Caso de Uso
[sidebar]
Eu j√° implementei um caso de uso bastante complexo usando Socket, mas era porque t√≠nhamos um servidor de gera√ß√£o de voz. Os clientes enviavam texto e outros par√¢metros e recebiam de volta Stream de dados de acordo com o formato requerido (MP3, WAV, etc...).

N√£o vamos entrar aqui em detalhes sobre como a classe Socket funciona, mas ao abrir um socket, ela vai dispor de dois Stream para leitura e escrita de dados. Assim podemos ter o servidor abaixo.

[source,java]
----
AtomicBoolean running = new AtomicBoolean(true);
ExecutorService threadPool = Executors.newFixedThreadPool(10); // thread para processar socket
try(ServerSocket server = new ServerSocket(5555)) {            // abre socket na porta 5555
    while (running.get()) {
        Socket socket = server.accept();                       // conex√£o aberta com cliente
        threadPool.submit(() -> {                              // Se n√£o tratar dentro de uma thread n√£o √© poss√≠vel abrir outras conex√µes
            try {
                process(socket.getInputStream(),               // encapsula toda comunica√ß√£o
                        socket.getOutputStream());
            } finally {
                socket.close();                               // S√≥ fecha o socket depois de finalizada a comunica√ß√£o
            }
        });
    }
}
----

J√° o cliente √© um pouco mais simples porque n√£o se espera que ele se conecte com mais de um servidor.

[source,java]
----
try (Socket socket = new Socket("localhost", 5555)) {
    process(socket.getInputStream(), socket.getOutputStream());
}
----

Eu n√£o recomendo a voc√™ escrever um servidor socket em nenhuma hip√≥tese. Caso voc√™ tenha um protocolo complexo que deve ser feito atrav√©s de um servidor socket, eu recomendo usar o projeto https://netty.io/[Netty] para que voc√™ consiga focar nas regras de neg√≥cios deixando funcionalidades como serializa√ß√£o, controle de threads e seguran√ßa como responsabilidade da biblioteca.

=== 5. Lidando objetos complexos

Se voc√™ foi atento deve ter reparado que no diagrama de classe tem duas classes que parecem bastante √∫teis: https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html[`ObjectInputStream`] e https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html[`ObjectOutputStream`]. Essas duas classes permitem serializar qualquer objeto da JVM e enviar para outra JVM, √© por causa dessas classes que existe a interface https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html[`Serializable`] a qual eu citei na minha primeira pergunta e at√© agora n√£o respondi. Pois vamos entender o motivo de deixar essa resposta por √∫ltimo?

Para serializar um objeto eu devo usar a interface https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html[`Serializable`]? N√£o! Voc√™ pode usar qualquer biblioteca com formatos de serializa√ß√£o que s√£o compreendidos por v√°rias linguagens. A interface `Serializable` √© usada para serializar objetos que s√≥ podem ser carregados na JVM atrav√©s das classes `ObjectInputStream` e `ObjectOutputStream`. MAS essas classes n√£o deve ser usadas porque elas tem v√°rias falhas de seguran√ßa que podem ser exploradas. Ent√£o resposta curta: **N√£o use essas classes!**

[#cap-05-proximos-passos]
== Pr√≥ximos passos

Eu espero que voc√™ tenha compreendido que como ler dados de v√°rias fontes como arquivos ou sockets. Agora √© hora de voc√™ aprender a usar bibliotecas de leituras de arquivos. Recomendo que voc√™ explore a biblioteca Jackson, assim como outras bibliotecas para se escrever JSON. Um bom exerc√≠cio √© comparar a performance de escrita entre v√°rias bibliotecas e escolher a que voc√™ vai usar sempre.

Outros exerc√≠cios s√£o tentar conhecer a biblioteca de leitura e XML, https://yaml.org/[YAML], https://toml.io/en/[TOML] ou qualquer outro formato que lhe interessar.
